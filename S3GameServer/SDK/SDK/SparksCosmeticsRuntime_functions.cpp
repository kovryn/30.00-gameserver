#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SparksCosmeticsRuntime

#include "Basic.hpp"

#include "SparksCosmeticsRuntime_classes.hpp"
#include "SparksCosmeticsRuntime_parameters.hpp"


namespace SDK
{

// Function SparksCosmeticsRuntime.FortAnimNotifyState_SpawnSparksProp.InitNewNotify
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// ESparksInstrumentType                   InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InLeftHand                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InAuxMesh                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSocketName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         InSkipActorsWithTag                                    (Parm, NativeAccessSpecifierPublic)
// int32                                   InPropId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    InDefaultMesh                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortAnimNotifyState_SpawnSparksProp::InitNewNotify(ESparksInstrumentType InType, bool InLeftHand, bool InAuxMesh, class FName InSocketName, const struct FGameplayTagQuery& InSkipActorsWithTag, int32 InPropId, class USkeletalMesh* InDefaultMesh) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortAnimNotifyState_SpawnSparksProp", "InitNewNotify");

	Params::FortAnimNotifyState_SpawnSparksProp_InitNewNotify Parms{};

	Parms.InType = InType;
	Parms.InLeftHand = InLeftHand;
	Parms.InAuxMesh = InAuxMesh;
	Parms.InSocketName = InSocketName;
	Parms.InSkipActorsWithTag = std::move(InSkipActorsWithTag);
	Parms.InPropId = InPropId;
	Parms.InDefaultMesh = InDefaultMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetInstrumentType
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksAccountItemDefinition::GetInstrumentType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksAccountItemDefinition", "GetInstrumentType");

	Params::SparksAccountItemDefinition_GetInstrumentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetItemSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksAccountItemSubtype USparksAccountItemDefinition::GetItemSubtype() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksAccountItemDefinition", "GetItemSubtype");

	Params::SparksAccountItemDefinition_GetItemSubtype Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetVariantChannelOptionNames
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              ChannelTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText*                            OutChannelName                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<class FString>*                  OutNames                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksAccountItemDefinition::GetVariantChannelOptionNames(const struct FGameplayTag& ChannelTag, class FText* OutChannelName, TArray<class FString>* OutNames) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksAccountItemDefinition", "GetVariantChannelOptionNames");

	Params::SparksAccountItemDefinition_GetVariantChannelOptionNames Parms{};

	Parms.ChannelTag = std::move(ChannelTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChannelName != nullptr)
		*OutChannelName = std::move(Parms.OutChannelName);

	if (OutNames != nullptr)
		*OutNames = std::move(Parms.OutNames);
}


// Function SparksCosmeticsRuntime.SparksAccountItemDefinition.GetVariantChannelTags
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>*            OutChannelTags                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksAccountItemDefinition::GetVariantChannelTags(TArray<struct FGameplayTag>* OutChannelTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksAccountItemDefinition", "GetVariantChannelTags");

	Params::SparksAccountItemDefinition_GetVariantChannelTags Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChannelTags != nullptr)
		*OutChannelTags = std::move(Parms.OutChannelTags);
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetSparksCosmeticCatalog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksCosmeticCatalog*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksCosmeticCatalog* USparksCosmeticCatalog::GetSparksCosmeticCatalog(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SparksCosmeticCatalog", "GetSparksCosmeticCatalog");

	Params::SparksCosmeticCatalog_GetSparksCosmeticCatalog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetItemDefFromAssetID
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FPrimaryAssetId&           AssetId                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksAccountItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksAccountItemDefinition* USparksCosmeticCatalog::GetItemDefFromAssetID(const struct FPrimaryAssetId& AssetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticCatalog", "GetItemDefFromAssetID");

	Params::SparksCosmeticCatalog_GetItemDefFromAssetID Parms{};

	Parms.AssetId = std::move(AssetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetActiveItemDefNamesForSubtype
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> USparksCosmeticCatalog::GetActiveItemDefNamesForSubtype(ESparksAccountItemSubtype Subtype) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticCatalog", "GetActiveItemDefNamesForSubtype");

	Params::SparksCosmeticCatalog_GetActiveItemDefNamesForSubtype Parms{};

	Parms.Subtype = Subtype;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetActiveItemDefNamesForSubtypeAndInstrument
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> USparksCosmeticCatalog::GetActiveItemDefNamesForSubtypeAndInstrument(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticCatalog", "GetActiveItemDefNamesForSubtypeAndInstrument");

	Params::SparksCosmeticCatalog_GetActiveItemDefNamesForSubtypeAndInstrument Parms{};

	Parms.Subtype = Subtype;
	Parms.Instrument = Instrument;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticCatalog.GetItemDef
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             InItemName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USparksAccountItemDefinition*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksAccountItemDefinition* USparksCosmeticCatalog::GetItemDef(class FName InItemName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticCatalog", "GetItemDef");

	Params::SparksCosmeticCatalog_GetItemDef Parms{};

	Parms.InItemName = InItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.AuraStart
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::AuraStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "AuraStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.AuraStop
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::AuraStop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "AuraStop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.Debug_BP_ShowCosmeticPicker
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bShow                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::Debug_BP_ShowCosmeticPicker(bool bShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "Debug_BP_ShowCosmeticPicker");

	Params::SparksCosmeticComponent_Debug_BP_ShowCosmeticPicker Parms{};

	Parms.bShow = bShow;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.DebugForceAuraState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::DebugForceAuraState(bool bShouldBeActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "DebugForceAuraState");

	Params::SparksCosmeticComponent_DebugForceAuraState Parms{};

	Parms.bShouldBeActive = bShouldBeActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.DoCacheValidJamTracks
// (Final, Native, Private)

void USparksCosmeticComponent::DoCacheValidJamTracks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "DoCacheValidJamTracks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetCosmeticItems
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USparksAccountItemDefinition*>*ItemDefs                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::GetCosmeticItems(TArray<class USparksAccountItemDefinition*>* ItemDefs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetCosmeticItems");

	Params::SparksCosmeticComponent_GetCosmeticItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ItemDefs != nullptr)
		*ItemDefs = std::move(Parms.ItemDefs);
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetEquippedJamSongShortnameForIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksCosmeticComponent::GetEquippedJamSongShortnameForIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetEquippedJamSongShortnameForIndex");

	Params::SparksCosmeticComponent_GetEquippedJamSongShortnameForIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetEquippedJamSongUIDForIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USparksCosmeticComponent::GetEquippedJamSongUIDForIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetEquippedJamSongUIDForIndex");

	Params::SparksCosmeticComponent_GetEquippedJamSongUIDForIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetOwnedJamSongShortnameForIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksCosmeticComponent::GetOwnedJamSongShortnameForIndex(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetOwnedJamSongShortnameForIndex");

	Params::SparksCosmeticComponent_GetOwnedJamSongShortnameForIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetOwnedJamTracksCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCosmeticComponent::GetOwnedJamTracksCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetOwnedJamTracksCount");

	Params::SparksCosmeticComponent_GetOwnedJamTracksCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.OnMaterialOverridesCleared
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerPawn*                  Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::OnMaterialOverridesCleared(class AFortPlayerPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "OnMaterialOverridesCleared");

	Params::SparksCosmeticComponent_OnMaterialOverridesCleared Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.OnWeaponChanged
// (Final, Native, Protected)
// Parameters:
// class AFortWeapon*                      NewWeapon                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortWeapon*                      PrevWeapon                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::OnWeaponChanged(class AFortWeapon* NewWeapon, class AFortWeapon* PrevWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "OnWeaponChanged");

	Params::SparksCosmeticComponent_OnWeaponChanged Parms{};

	Parms.NewWeapon = NewWeapon;
	Parms.PrevWeapon = PrevWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.RefreshMCP
// (Final, Native, Protected, BlueprintCallable)

void USparksCosmeticComponent::RefreshMCP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "RefreshMCP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveAuraItemDef
// (Final, Native, Private)
// Parameters:
// class USparksAuraItemDefinition*        NewAuraItemDef                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveAuraItemDef(class USparksAuraItemDefinition* NewAuraItemDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetActiveAuraItemDef");

	Params::SparksCosmeticComponent_SetActiveAuraItemDef Parms{};

	Parms.NewAuraItemDef = NewAuraItemDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveInstrumentItemDef
// (Final, Native, Private)
// Parameters:
// class USparksInstrumentItemDefBase*     InstrumentItemDef                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveInstrumentItemDef(class USparksInstrumentItemDefBase* InstrumentItemDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetActiveInstrumentItemDef");

	Params::SparksCosmeticComponent_SetActiveInstrumentItemDef Parms{};

	Parms.InstrumentItemDef = InstrumentItemDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveItemDef
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USparksAccountItemDefinition*     NewItemDef                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveItemDef(class USparksAccountItemDefinition* NewItemDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetActiveItemDef");

	Params::SparksCosmeticComponent_SetActiveItemDef Parms{};

	Parms.NewItemDef = NewItemDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetActiveSpotlightAnimDef
// (Final, Native, Private)
// Parameters:
// class USparksSpotlightAnimDefinition*   NewSpotlightDef                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetActiveSpotlightAnimDef(class USparksSpotlightAnimDefinition* NewSpotlightDef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetActiveSpotlightAnimDef");

	Params::SparksCosmeticComponent_SetActiveSpotlightAnimDef Parms{};

	Parms.NewSpotlightDef = NewSpotlightDef;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetAuraState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bShouldBeActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetAuraState(bool bShouldBeActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetAuraState");

	Params::SparksCosmeticComponent_SetAuraState Parms{};

	Parms.bShouldBeActive = bShouldBeActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.SetVariantChoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              VariantChannel                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Value                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticComponent::SetVariantChoice(ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel, const class FString& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "SetVariantChoice");

	Params::SparksCosmeticComponent_SetVariantChoice Parms{};

	Parms.Subtype = Subtype;
	Parms.InstrumentType = InstrumentType;
	Parms.VariantChannel = std::move(VariantChannel);
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetAccountItemTypeFromInstrumentType
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksAccountItemSubtype               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksAccountItemSubtype USparksCosmeticComponent::GetAccountItemTypeFromInstrumentType(ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetAccountItemTypeFromInstrumentType");

	Params::SparksCosmeticComponent_GetAccountItemTypeFromInstrumentType Parms{};

	Parms.Instrument = Instrument;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetChoice
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoice*            OutChoice                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              VariantChannel                                         (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetChoice(struct FSparksVariantChoice* OutChoice, ESparksAccountItemSubtype Subtype, ESparksInstrumentType InstrumentType, const struct FGameplayTag& VariantChannel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetChoice");

	Params::SparksCosmeticComponent_GetChoice Parms{};

	Parms.Subtype = Subtype;
	Parms.InstrumentType = InstrumentType;
	Parms.VariantChannel = std::move(VariantChannel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutChoice != nullptr)
		*OutChoice = std::move(Parms.OutChoice);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetCosmeticItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksAccountItemSubtype               Subtype                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class USparksAccountItemDefinition*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class USparksAccountItemDefinition* USparksCosmeticComponent::GetCosmeticItem(ESparksAccountItemSubtype Subtype, ESparksInstrumentType Instrument) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetCosmeticItem");

	Params::SparksCosmeticComponent_GetCosmeticItem Parms{};

	Parms.Subtype = Subtype;
	Parms.Instrument = Instrument;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetEquippedJamTracksCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USparksCosmeticComponent::GetEquippedJamTracksCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetEquippedJamTracksCount");

	Params::SparksCosmeticComponent_GetEquippedJamTracksCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentAuxiliaryCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh**                   OutMesh                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance**               OutMaterial                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance**               OutMaterial2                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentAuxiliaryCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class UMaterialInstance** OutMaterial2) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetInstrumentAuxiliaryCosmetics");

	Params::SparksCosmeticComponent_GetInstrumentAuxiliaryCosmetics Parms{};

	Parms.InstrumentType = InstrumentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	if (OutMaterial2 != nullptr)
		*OutMaterial2 = Parms.OutMaterial2;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentAuxiliaryVFX
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset**                  OutFX                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentAuxiliaryVFX(ESparksInstrumentType InstrumentType, class UFXSystemAsset** OutFX) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetInstrumentAuxiliaryVFX");

	Params::SparksCosmeticComponent_GetInstrumentAuxiliaryVFX Parms{};

	Parms.InstrumentType = InstrumentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFX != nullptr)
		*OutFX = Parms.OutFX;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentCosmetics
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh**                   OutMesh                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance**               OutMaterial                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMesh**                   OutLHMesh                                              (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance**               OutLHMaterial                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentCosmetics(ESparksInstrumentType InstrumentType, class USkeletalMesh** OutMesh, class UMaterialInstance** OutMaterial, class USkeletalMesh** OutLHMesh, class UMaterialInstance** OutLHMaterial) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetInstrumentCosmetics");

	Params::SparksCosmeticComponent_GetInstrumentCosmetics Parms{};

	Parms.InstrumentType = InstrumentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMesh != nullptr)
		*OutMesh = Parms.OutMesh;

	if (OutMaterial != nullptr)
		*OutMaterial = Parms.OutMaterial;

	if (OutLHMesh != nullptr)
		*OutLHMesh = Parms.OutLHMesh;

	if (OutLHMaterial != nullptr)
		*OutLHMaterial = Parms.OutLHMaterial;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetInstrumentVFX
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset**                  OutFX                                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFXSystemAsset**                  OutLHFX                                                (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksCosmeticComponent::GetInstrumentVFX(ESparksInstrumentType InstrumentType, class UFXSystemAsset** OutFX, class UFXSystemAsset** OutLHFX) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetInstrumentVFX");

	Params::SparksCosmeticComponent_GetInstrumentVFX Parms{};

	Parms.InstrumentType = InstrumentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFX != nullptr)
		*OutFX = Parms.OutFX;

	if (OutLHFX != nullptr)
		*OutLHFX = Parms.OutLHFX;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticComponent.GetSpotlightAnim
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   InstrumentType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelSequence*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelSequence* USparksCosmeticComponent::GetSpotlightAnim(ESparksInstrumentType InstrumentType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticComponent", "GetSpotlightAnim");

	Params::SparksCosmeticComponent_GetSpotlightAnim Parms{};

	Parms.InstrumentType = InstrumentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksCosmeticsCheatManager.GrantSparksCosmeticsLoadedAssets
// (Final, BlueprintAuthorityOnly, Exec, Native, Private, Const)

void USparksCosmeticsCheatManager::GrantSparksCosmeticsLoadedAssets() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticsCheatManager", "GrantSparksCosmeticsLoadedAssets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksCosmeticsCheatManager.GrantSparksSongsLoadedAssets
// (Final, BlueprintAuthorityOnly, Exec, Native, Private, Const)
// Parameters:
// bool                                    bIncludeSongsWithoutCatalogData                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksCosmeticsCheatManager::GrantSparksSongsLoadedAssets(bool bIncludeSongsWithoutCatalogData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksCosmeticsCheatManager", "GrantSparksSongsLoadedAssets");

	Params::SparksCosmeticsCheatManager_GrantSparksSongsLoadedAssets Parms{};

	Parms.bIncludeSongsWithoutCatalogData = bIncludeSongsWithoutCatalogData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksInstrumentComponentBase.DestroySpawnedVFX
// (Final, Native, Public)

void USparksInstrumentComponentBase::DestroySpawnedVFX()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentComponentBase", "DestroySpawnedVFX");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksInstrumentComponentBase.GetInstrumentType
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksInstrumentComponentBase::GetInstrumentType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentComponentBase", "GetInstrumentType");

	Params::SparksInstrumentComponentBase_GetInstrumentType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetAuxFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetAuxFXSystem");

	Params::SparksInstrumentItemDefBase_GetAuxFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetAuxiliaryMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetAuxiliaryMaterial");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMaterial Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMaterial2
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetAuxiliaryMaterial2(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetAuxiliaryMaterial2");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMaterial2 Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetAuxiliaryMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetAuxiliaryMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetAuxiliaryMesh");

	Params::SparksInstrumentItemDefBase_GetAuxiliaryMesh Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLeftHandMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetLeftHandMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetLeftHandMaterial");

	Params::SparksInstrumentItemDefBase_GetLeftHandMaterial Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLeftHandMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetLeftHandMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetLeftHandMesh");

	Params::SparksInstrumentItemDefBase_GetLeftHandMesh Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetLHFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetLHFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetLHFXSystem");

	Params::SparksInstrumentItemDefBase_GetLHFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMainFXSystem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UFXSystemAsset*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFXSystemAsset* USparksInstrumentItemDefBase::GetMainFXSystem(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetMainFXSystem");

	Params::SparksInstrumentItemDefBase_GetMainFXSystem Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMaterial
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* USparksInstrumentItemDefBase::GetMaterial(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetMaterial");

	Params::SparksInstrumentItemDefBase_GetMaterial Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentItemDefBase.GetMesh
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSparksVariantChoices&     Choices                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USkeletalMesh*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMesh* USparksInstrumentItemDefBase::GetMesh(const struct FSparksVariantChoices& Choices) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentItemDefBase", "GetMesh");

	Params::SparksInstrumentItemDefBase_GetMesh Parms{};

	Parms.Choices = std::move(Choices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksInstrumentPreviewActor.GetCurrentChoices
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSparksVariantChoices            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSparksVariantChoices ASparksInstrumentPreviewActor::GetCurrentChoices() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksInstrumentPreviewActor", "GetCurrentChoices");

	Params::SparksInstrumentPreviewActor_GetCurrentChoices Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksItemPreviewOffPawnActor.GetInstrumentType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType ASparksItemPreviewOffPawnActor::GetInstrumentType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksItemPreviewOffPawnActor", "GetInstrumentType");

	Params::SparksItemPreviewOffPawnActor_GetInstrumentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamLoopType
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFMJamLoopType                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFMJamLoopType USparksJamEmoteItemDefinition::GetJamLoopType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksJamEmoteItemDefinition", "GetJamLoopType");

	Params::SparksJamEmoteItemDefinition_GetJamLoopType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamSongMetaData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCatalogData*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCatalogData* USparksJamEmoteItemDefinition::GetJamSongMetaData(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksJamEmoteItemDefinition", "GetJamSongMetaData");

	Params::SparksJamEmoteItemDefinition_GetJamSongMetaData Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetJamSongShortName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USparksJamEmoteItemDefinition::GetJamSongShortName(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksJamEmoteItemDefinition", "GetJamSongShortName");

	Params::SparksJamEmoteItemDefinition_GetJamSongShortName Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.GetSongItemDef
// (Final, RequiredAPI, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USparksSongItemDefinition*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USparksSongItemDefinition* USparksJamEmoteItemDefinition::GetSongItemDef() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksJamEmoteItemDefinition", "GetSongItemDef");

	Params::SparksJamEmoteItemDefinition_GetSongItemDef Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksJamEmoteItemDefinition.IsJamLoopEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AFortPlayerController*      PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USparksJamEmoteItemDefinition::IsJamLoopEnabled(const class AFortPlayerController* PlayerController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksJamEmoteItemDefinition", "IsJamLoopEnabled");

	Params::SparksJamEmoteItemDefinition_IsJamLoopEnabled Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksPlayerStateComponent.SetSparksInstrumentChoice
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// ESparksInstrumentType                   Instrument                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USparksPlayerStateComponent::SetSparksInstrumentChoice(ESparksInstrumentType Instrument)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksPlayerStateComponent", "SetSparksInstrumentChoice");

	Params::SparksPlayerStateComponent_SetSparksInstrumentChoice Parms{};

	Parms.Instrument = Instrument;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SparksCosmeticsRuntime.SparksPlayerStateComponent.GetSparksInstrumentChoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ESparksInstrumentType                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESparksInstrumentType USparksPlayerStateComponent::GetSparksInstrumentChoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksPlayerStateComponent", "GetSparksInstrumentChoice");

	Params::SparksPlayerStateComponent_GetSparksInstrumentChoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SparksCosmeticsRuntime.SparksSongPreviewActor.OnSongTextureLoaded
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       CoverArt                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASparksSongPreviewActor::OnSongTextureLoaded(class UTexture2D* CoverArt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksSongPreviewActor", "OnSongTextureLoaded");

	Params::SparksSongPreviewActor_OnSongTextureLoaded Parms{};

	Parms.CoverArt = CoverArt;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SparksCosmeticsRuntime.SparksSongPreviewActor.StartSongPreview
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ASparksSongPreviewActor::StartSongPreview()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SparksSongPreviewActor", "StartSongPreview");

	UObject::ProcessEvent(Func, nullptr);
}

}

