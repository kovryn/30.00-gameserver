#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarCore

#include "Basic.hpp"

#include "DelMarCore_classes.hpp"
#include "DelMarCore_parameters.hpp"


namespace SDK
{

// Function DelMarCore.DelMarActorMover.InitializeMovement
// (Final, Native, Protected, BlueprintCallable)

void ADelMarActorMover::InitializeMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActorMover", "InitializeMovement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarActorMover.OnRep_ServerStartTime
// (Final, Native, Protected)

void ADelMarActorMover::OnRep_ServerStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActorMover", "OnRep_ServerStartTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAIController.HandleGroundedStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarAIController::HandleGroundedStateChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAIController", "HandleGroundedStateChanged");

	Params::DelMarAIController_HandleGroundedStateChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAIService.HandlePlayerRegistered
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerState*                 RegisteredPlayerState                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarAIService::HandlePlayerRegistered(class AFortPlayerState* RegisteredPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAIService", "HandlePlayerRegistered");

	Params::DelMarAIService_HandlePlayerRegistered Parms{};

	Parms.RegisteredPlayerState = RegisteredPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAIService.HandlePlayerUnregistered
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerState*                 UnregisteredPlayerState                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetAsInactive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarAIService::HandlePlayerUnregistered(class AFortPlayerState* UnregisteredPlayerState, bool bSetAsInactive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAIService", "HandlePlayerUnregistered");

	Params::DelMarAIService_HandlePlayerUnregistered Parms{};

	Parms.UnregisteredPlayerState = UnregisteredPlayerState;
	Parms.bSetAsInactive = bSetAsInactive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAIService.GetMaxNumberOfPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarAIService::GetMaxNumberOfPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAIService", "GetMaxNumberOfPlayers");

	Params::DelMarAIService_GetMaxNumberOfPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAIService.GetRegisteredAIBotControllers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ADelMarAIController*>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ADelMarAIController*> UDelMarAIService::GetRegisteredAIBotControllers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAIService", "GetRegisteredAIBotControllers");

	Params::DelMarAIService_GetRegisteredAIBotControllers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBTService_FindDriveGoal.HandleKickflipActivated
// (Final, Native, Protected)
// Parameters:
// bool                                    bLeft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBTService_FindDriveGoal::HandleKickflipActivated(bool bLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBTService_FindDriveGoal", "HandleKickflipActivated");

	Params::DelMarBTService_FindDriveGoal_HandleKickflipActivated Parms{};

	Parms.bLeft = bLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarBTService_FindDriveGoal.HandleVehicleAnyWheelsOnGroundStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnyWheelsOnGround                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBTService_FindDriveGoal::HandleVehicleAnyWheelsOnGroundStateChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bAnyWheelsOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBTService_FindDriveGoal", "HandleVehicleAnyWheelsOnGroundStateChanged");

	Params::DelMarBTService_FindDriveGoal_HandleVehicleAnyWheelsOnGroundStateChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bAnyWheelsOnGround = bAnyWheelsOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarBTTask_DriveTrack.HandleTurboActivated
// (Final, Native, Protected)

void UDelMarBTTask_DriveTrack::HandleTurboActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBTTask_DriveTrack", "HandleTurboActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarBTTask_DriveTrack.HandleVehicleAnyWheelsOnGroundStateChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnyWheelsOnGround                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBTTask_DriveTrack::HandleVehicleAnyWheelsOnGroundStateChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bAnyWheelsOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBTTask_DriveTrack", "HandleVehicleAnyWheelsOnGroundStateChanged");

	Params::DelMarBTTask_DriveTrack_HandleVehicleAnyWheelsOnGroundStateChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bAnyWheelsOnGround = bAnyWheelsOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarBTTask_DriveTrack.TurboBonusZoneStateChanged
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBTTask_DriveTrack::TurboBonusZoneStateChanged(EDelMarTurboZoneState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBTTask_DriveTrack", "TurboBonusZoneStateChanged");

	Params::DelMarBTTask_DriveTrack_TurboBonusZoneStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.FinalizeRegisteredPlayerInitialization
// (Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::FinalizeRegisteredPlayerInitialization(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "FinalizeRegisteredPlayerInitialization");

	Params::DelMarRaceManager_FinalizeRegisteredPlayerInitialization Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.FinishRace
// (Native, Public, BlueprintCallable)

void ADelMarRaceManager::FinishRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "FinishRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.HandleRegisteredPlayerPawnSet
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::HandleRegisteredPlayerPawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "HandleRegisteredPlayerPawnSet");

	Params::DelMarRaceManager_HandleRegisteredPlayerPawnSet Parms{};

	Parms.Player = Player;
	Parms.NewPawn = NewPawn;
	Parms.OldPawn = OldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.NetMulticast_FinishRace
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// double                                  RaceFinishedTime                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::NetMulticast_FinishRace(double RaceFinishedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "NetMulticast_FinishRace");

	Params::DelMarRaceManager_NetMulticast_FinishRace Parms{};

	Parms.RaceFinishedTime = RaceFinishedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.NetMulticast_ResetRace
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// bool                                    bNextRound                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::NetMulticast_ResetRace(bool bNextRound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "NetMulticast_ResetRace");

	Params::DelMarRaceManager_NetMulticast_ResetRace Parms{};

	Parms.bNextRound = bNextRound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.NetMulticast_ResetRun
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const class AFortPlayerState*           InPlayerState                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerTriggered                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::NetMulticast_ResetRun(const class AFortPlayerState* InPlayerState, bool bPlayerTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "NetMulticast_ResetRun");

	Params::DelMarRaceManager_NetMulticast_ResetRun Parms{};

	Parms.InPlayerState = InPlayerState;
	Parms.bPlayerTriggered = bPlayerTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.OnRep_ActiveRaceLevelConfig
// (Final, Native, Protected)

void ADelMarRaceManager::OnRep_ActiveRaceLevelConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "OnRep_ActiveRaceLevelConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.RegisterPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::RegisterPlayerController(class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "RegisterPlayerController");

	Params::DelMarRaceManager_RegisterPlayerController Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.RegisterPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::RegisterPlayerState(class AFortPlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "RegisterPlayerState");

	Params::DelMarRaceManager_RegisterPlayerState Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.RequestCountdownForPlayer
// (Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::RequestCountdownForPlayer(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "RequestCountdownForPlayer");

	Params::DelMarRaceManager_RequestCountdownForPlayer Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.RequestStartRace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipCountdown                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::RequestStartRace(bool bSkipCountdown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "RequestStartRace");

	Params::DelMarRaceManager_RequestStartRace Parms{};

	Parms.bSkipCountdown = bSkipCountdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.ResetRace
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsRoundReset                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::ResetRace(bool bIsRoundReset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "ResetRace");

	Params::DelMarRaceManager_ResetRace Parms{};

	Parms.bIsRoundReset = bIsRoundReset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.ResetRun
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerTriggered                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::ResetRun(class AFortPlayerState* PlayerState, bool bPlayerTriggered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "ResetRun");

	Params::DelMarRaceManager_ResetRun Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bPlayerTriggered = bPlayerTriggered;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.SetActiveRaceLevelConfig
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarRaceLevelConfig*           InRaceLevelConfig                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::SetActiveRaceLevelConfig(class ADelMarRaceLevelConfig* InRaceLevelConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "SetActiveRaceLevelConfig");

	Params::DelMarRaceManager_SetActiveRaceLevelConfig Parms{};

	Parms.InRaceLevelConfig = InRaceLevelConfig;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.SetPlayerAsSpectator
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::SetPlayerAsSpectator(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "SetPlayerAsSpectator");

	Params::DelMarRaceManager_SetPlayerAsSpectator Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.SetSpectatorAsPlayer
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::SetSpectatorAsPlayer(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "SetSpectatorAsPlayer");

	Params::DelMarRaceManager_SetSpectatorAsPlayer Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.UnregisterAllPlayers
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSetAsInactive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::UnregisterAllPlayers(bool bSetAsInactive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "UnregisterAllPlayers");

	Params::DelMarRaceManager_UnregisterAllPlayers Parms{};

	Parms.bSetAsInactive = bSetAsInactive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.UnregisterPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetAsInactive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::UnregisterPlayerController(class AController* InController, bool bSetAsInactive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "UnregisterPlayerController");

	Params::DelMarRaceManager_UnregisterPlayerController Parms{};

	Parms.InController = InController;
	Parms.bSetAsInactive = bSetAsInactive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.UnregisterPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSetAsInactive                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarRaceManager::UnregisterPlayerState(class AFortPlayerState* InPlayerState, bool bSetAsInactive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "UnregisterPlayerState");

	Params::DelMarRaceManager_UnregisterPlayerState Parms{};

	Parms.InPlayerState = InPlayerState;
	Parms.bSetAsInactive = bSetAsInactive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManager.GetActiveRaceLevelConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarRaceLevelConfig*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarRaceLevelConfig* ADelMarRaceManager::GetActiveRaceLevelConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetActiveRaceLevelConfig");

	Params::DelMarRaceManager_GetActiveRaceLevelConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetActiveRacers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AFortPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AFortPlayerState*> ADelMarRaceManager::GetActiveRacers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetActiveRacers");

	Params::DelMarRaceManager_GetActiveRacers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetCurrentRaceMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarRaceMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarRaceMode ADelMarRaceManager::GetCurrentRaceMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetCurrentRaceMode");

	Params::DelMarRaceManager_GetCurrentRaceMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetCurrentSpawnMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarRaceSpawnMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarRaceSpawnMode ADelMarRaceManager::GetCurrentSpawnMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetCurrentSpawnMode");

	Params::DelMarRaceManager_GetCurrentSpawnMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetEliminationManagerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarEliminationRaceManagerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarEliminationRaceManagerComponent* ADelMarRaceManager::GetEliminationManagerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetEliminationManagerComponent");

	Params::DelMarRaceManager_GetEliminationManagerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetManagedPlayerStatesArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AFortPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AFortPlayerState*> ADelMarRaceManager::GetManagedPlayerStatesArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetManagedPlayerStatesArray");

	Params::DelMarRaceManager_GetManagedPlayerStatesArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetNumberOfLapsForRace
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarRaceManager::GetNumberOfLapsForRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetNumberOfLapsForRace");

	Params::DelMarRaceManager_GetNumberOfLapsForRace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetNumInactiveRacers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarRaceManager::GetNumInactiveRacers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetNumInactiveRacers");

	Params::DelMarRaceManager_GetNumInactiveRacers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetPositionalTracker
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarPositionalTrackerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarPositionalTrackerComponent* ADelMarRaceManager::GetPositionalTracker() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetPositionalTracker");

	Params::DelMarRaceManager_GetPositionalTracker Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetRaceConfig
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarRaceConfigComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarRaceConfigComponent* ADelMarRaceManager::GetRaceConfig() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetRaceConfig");

	Params::DelMarRaceManager_GetRaceConfig Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetRespawnManagerComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarRespawnManagerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarRespawnManagerComponent* ADelMarRaceManager::GetRespawnManagerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetRespawnManagerComponent");

	Params::DelMarRaceManager_GetRespawnManagerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetRubberbandingManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarRubberbandingManagerComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarRubberbandingManagerComponent* ADelMarRaceManager::GetRubberbandingManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetRubberbandingManager");

	Params::DelMarRaceManager_GetRubberbandingManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetSpectators
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class AFortPlayerState*>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AFortPlayerState*> ADelMarRaceManager::GetSpectators() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetSpectators");

	Params::DelMarRaceManager_GetSpectators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.GetTimeManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarTimeManagerComponent*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTimeManagerComponent* ADelMarRaceManager::GetTimeManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "GetTimeManager");

	Params::DelMarRaceManager_GetTimeManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.IsActiveRacer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AFortPlayerState*           PlayerState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarRaceManager::IsActiveRacer(const class AFortPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "IsActiveRacer");

	Params::DelMarRaceManager_IsActiveRacer Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManager.IsSpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AFortPlayerState*           PlayerState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarRaceManager::IsSpectator(const class AFortPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManager", "IsSpectator");

	Params::DelMarRaceManager_IsSpectator Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarChallengeRaceManager.NetMulticast_StartOvertime
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const double                            RaceFinishTimestamp                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarChallengeRaceManager::NetMulticast_StartOvertime(const double RaceFinishTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarChallengeRaceManager", "NetMulticast_StartOvertime");

	Params::DelMarChallengeRaceManager_NetMulticast_StartOvertime Parms{};

	Parms.RaceFinishTimestamp = RaceFinishTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarStateMachine.OnRep_RequestedStateTag
// (Final, Native, Protected)

void UDelMarStateMachine::OnRep_RequestedStateTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "OnRep_RequestedStateTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarStateMachine.RequestState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              StateTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStateMachine::RequestState(const struct FGameplayTag& StateTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "RequestState");

	Params::DelMarStateMachine_RequestState Parms{};

	Parms.StateTag = std::move(StateTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarStateMachine.GetActiveStateByTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelMarState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarState* UDelMarStateMachine::GetActiveStateByTag(const struct FGameplayTag& GameplayTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "GetActiveStateByTag");

	Params::DelMarStateMachine_GetActiveStateByTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarStateMachine.GetCurrentState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarState*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarState* UDelMarStateMachine::GetCurrentState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "GetCurrentState");

	Params::DelMarStateMachine_GetCurrentState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarStateMachine.GetCurrentStateTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDelMarStateMachine::GetCurrentStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "GetCurrentStateTag");

	Params::DelMarStateMachine_GetCurrentStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarStateMachine.GetRequestedStateTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDelMarStateMachine::GetRequestedStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateMachine", "GetRequestedStateTag");

	Params::DelMarStateMachine_GetRequestedStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.ExitSpectate
// (Final, Native, Protected)

void UDelMarSpectatorControllerComponent::ExitSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "ExitSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.NetMulticast_BeginSpectating
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void UDelMarSpectatorControllerComponent::NetMulticast_BeginSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "NetMulticast_BeginSpectating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.NetMulticast_FinishSpectating
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void UDelMarSpectatorControllerComponent::NetMulticast_FinishSpectating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "NetMulticast_FinishSpectating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.ServerSetSpectatorTarget
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSpectatorControllerComponent::ServerSetSpectatorTarget(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "ServerSetSpectatorTarget");

	Params::DelMarSpectatorControllerComponent_ServerSetSpectatorTarget Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.SetIsLateJoinSpectator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewLateJoinSpectator                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSpectatorControllerComponent::SetIsLateJoinSpectator(bool bNewLateJoinSpectator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "SetIsLateJoinSpectator");

	Params::DelMarSpectatorControllerComponent_SetIsLateJoinSpectator Parms{};

	Parms.bNewLateJoinSpectator = bNewLateJoinSpectator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.SetSpectatorTarget
// (Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSpectatorControllerComponent::SetSpectatorTarget(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "SetSpectatorTarget");

	Params::DelMarSpectatorControllerComponent_SetSpectatorTarget Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.SpectateNextPlayer
// (Final, Native, Protected)

void UDelMarSpectatorControllerComponent::SpectateNextPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "SpectateNextPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.SpectatePrevPlayer
// (Final, Native, Protected)

void UDelMarSpectatorControllerComponent::SpectatePrevPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "SpectatePrevPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpectatorControllerComponent.IsLateJoinSpectator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarSpectatorControllerComponent::IsLateJoinSpectator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpectatorControllerComponent", "IsLateJoinSpectator");

	Params::DelMarSpectatorControllerComponent_IsLateJoinSpectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarChallengeSpectatorControllerComponent.ClientUpdateFinishedSpectatorTarget
// (Net, NetReliable, Native, Event, Protected, NetClient, BlueprintCallable)

void UDelMarChallengeSpectatorControllerComponent::ClientUpdateFinishedSpectatorTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarChallengeSpectatorControllerComponent", "ClientUpdateFinishedSpectatorTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeManagerComponent.ResetClocks
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UDelMarTimeManagerComponent::ResetClocks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "ResetClocks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeManagerComponent.StartCountdownForPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ServerCountdownStartTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ServerRunStartTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTimeManagerComponent::StartCountdownForPlayer(class AFortPlayerState* PlayerState, double ServerCountdownStartTime, double ServerRunStartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "StartCountdownForPlayer");

	Params::DelMarTimeManagerComponent_StartCountdownForPlayer Parms{};

	Parms.PlayerState = PlayerState;
	Parms.ServerCountdownStartTime = ServerCountdownStartTime;
	Parms.ServerRunStartTime = ServerRunStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeManagerComponent.StartCountdownForRace
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// double                                  ServerCountdownStartTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ServerRunStartTime                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  InServerCountdownIntervalTime                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTimeManagerComponent::StartCountdownForRace(double ServerCountdownStartTime, double ServerRunStartTime, double InServerCountdownIntervalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "StartCountdownForRace");

	Params::DelMarTimeManagerComponent_StartCountdownForRace Parms{};

	Parms.ServerCountdownStartTime = ServerCountdownStartTime;
	Parms.ServerRunStartTime = ServerRunStartTime;
	Parms.InServerCountdownIntervalTime = InServerCountdownIntervalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetRaceTimeRemaining
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetRaceTimeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetRaceTimeRemaining");

	Params::DelMarTimeManagerComponent_GetRaceTimeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetSecondsRemainingTillRaceStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetSecondsRemainingTillRaceStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetSecondsRemainingTillRaceStart");

	Params::DelMarTimeManagerComponent_GetSecondsRemainingTillRaceStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetSecondsSinceRaceStart
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetSecondsSinceRaceStart() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetSecondsSinceRaceStart");

	Params::DelMarTimeManagerComponent_GetSecondsSinceRaceStart Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetServerCountdownIntervalTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetServerCountdownIntervalTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetServerCountdownIntervalTime");

	Params::DelMarTimeManagerComponent_GetServerCountdownIntervalTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetServerRaceFinishTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetServerRaceFinishTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetServerRaceFinishTime");

	Params::DelMarTimeManagerComponent_GetServerRaceFinishTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeManagerComponent.GetServerRaceStartTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTimeManagerComponent::GetServerRaceStartTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeManagerComponent", "GetServerRaceStartTime");

	Params::DelMarTimeManagerComponent_GetServerRaceStartTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCompetitiveRaceManager.HandleFinalRacePositionsUpdated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<struct FDelMarFinalRacePositionEntry>&FinalRacePositions                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDelMarEvent_RunRecorded&  RecordedRun                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ADelMarCompetitiveRaceManager::HandleFinalRacePositionsUpdated(const TArray<struct FDelMarFinalRacePositionEntry>& FinalRacePositions, const struct FDelMarEvent_RunRecorded& RecordedRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCompetitiveRaceManager", "HandleFinalRacePositionsUpdated");

	Params::DelMarCompetitiveRaceManager_HandleFinalRacePositionsUpdated Parms{};

	Parms.FinalRacePositions = std::move(FinalRacePositions);
	Parms.RecordedRun = std::move(RecordedRun);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCompetitiveRaceManager.OnRep_FirstPlayerFinishedTimestamp
// (Final, Native, Protected)

void ADelMarCompetitiveRaceManager::OnRep_FirstPlayerFinishedTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCompetitiveRaceManager", "OnRep_FirstPlayerFinishedTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarConnectedHintComponent.BeginPlay
// (Native, Public)

void UDelMarConnectedHintComponent::BeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarConnectedHintComponent", "BeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarConnectedHintComponent.HandleActorBeginOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarConnectedHintComponent::HandleActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarConnectedHintComponent", "HandleActorBeginOverlap");

	Params::DelMarConnectedHintComponent_HandleActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarConnectedHintComponent.HandleActorEndOverlap
// (Final, Native, Public)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarConnectedHintComponent::HandleActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarConnectedHintComponent", "HandleActorEndOverlap");

	Params::DelMarConnectedHintComponent_HandleActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarConnectedHintComponent.HandleVehicleActionPerformed
// (Final, Native, Protected)

void UDelMarConnectedHintComponent::HandleVehicleActionPerformed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarConnectedHintComponent", "HandleVehicleActionPerformed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarConnectedHintComponent.PassNuxHintTypeToConnectedHintComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              HintTypeTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarConnectedHintComponent::PassNuxHintTypeToConnectedHintComponent(const struct FGameplayTag& HintTypeTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarConnectedHintComponent", "PassNuxHintTypeToConnectedHintComponent");

	Params::DelMarConnectedHintComponent_PassNuxHintTypeToConnectedHintComponent Parms{};

	Parms.HintTypeTag = std::move(HintTypeTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCoreOobTubePositionalRenderingComponent.HandleAIPawnSpawned
// (Final, Native, Private)
// Parameters:
// class AAIController*                    BotController                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        BotPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCoreOobTubePositionalRenderingComponent::HandleAIPawnSpawned(class AAIController* BotController, class AFortPawn* BotPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCoreOobTubePositionalRenderingComponent", "HandleAIPawnSpawned");

	Params::DelMarCoreOobTubePositionalRenderingComponent_HandleAIPawnSpawned Parms{};

	Parms.BotController = BotController;
	Parms.BotPawn = BotPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCoreOobTubePositionalRenderingComponent.HandleViewTargetChanged
// (Final, Native, Private)
// Parameters:
// class AFortPlayerController*            FortPC                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCoreOobTubePositionalRenderingComponent::HandleViewTargetChanged(class AFortPlayerController* FortPC, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCoreOobTubePositionalRenderingComponent", "HandleViewTargetChanged");

	Params::DelMarCoreOobTubePositionalRenderingComponent_HandleViewTargetChanged Parms{};

	Parms.FortPC = FortPC;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCoreSplineMeshComponent.OnBeginActorOverlap
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UDelMarCoreSplineMeshComponent::OnBeginActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCoreSplineMeshComponent", "OnBeginActorOverlap");

	Params::DelMarCoreSplineMeshComponent_OnBeginActorOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCosmeticsDatabase.GetItemsForSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UDelMarCosmeticItemDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UDelMarCosmeticItemDefinition*> UDelMarCosmeticsDatabase::GetItemsForSlot(const struct FGameplayTag& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticsDatabase", "GetItemsForSlot");

	Params::DelMarCosmeticsDatabase_GetItemsForSlot Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCosmeticsDatabase.GetSlotInfos
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FDelMarCosmeticSlotInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FDelMarCosmeticSlotInfo> UDelMarCosmeticsDatabase::GetSlotInfos() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticsDatabase", "GetSlotInfos");

	Params::DelMarCosmeticsDatabase_GetSlotInfos Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarDriverInteractionComponent.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarDriverInteractionComponent::HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDriverInteractionComponent", "HandleViewTargetChanged");

	Params::DelMarDriverInteractionComponent_HandleViewTargetChanged Parms{};

	Parms.InController = InController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarFlowAnalyticsControllerComponent.TutorialComplete
// (Final, Native, Public, BlueprintCallable)

void UDelMarFlowAnalyticsControllerComponent::TutorialComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarFlowAnalyticsControllerComponent", "TutorialComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarFlowAnalyticsControllerComponent.TutorialGoRace
// (Final, Native, Public, BlueprintCallable)

void UDelMarFlowAnalyticsControllerComponent::TutorialGoRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarFlowAnalyticsControllerComponent", "TutorialGoRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarFlowAnalyticsControllerComponent.TutorialKeepTraining
// (Final, Native, Public, BlueprintCallable)

void UDelMarFlowAnalyticsControllerComponent::TutorialKeepTraining()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarFlowAnalyticsControllerComponent", "TutorialKeepTraining");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarFlowAnalyticsControllerComponent.TutorialReplay
// (Final, Native, Public, BlueprintCallable)

void UDelMarFlowAnalyticsControllerComponent::TutorialReplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarFlowAnalyticsControllerComponent", "TutorialReplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostSessionComponent.StartSession
// (Native, Public, BlueprintCallable)

void UDelMarGhostSessionComponent::StartSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostSessionComponent", "StartSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostSessionComponent.StopSession
// (Native, Public, BlueprintCallable)

void UDelMarGhostSessionComponent::StopSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostSessionComponent", "StopSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostSessionComponent.IsSessionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarGhostSessionComponent::IsSessionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostSessionComponent", "IsSessionActive");

	Params::DelMarGhostSessionComponent_IsSessionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarGhostPlaybackSessionComponent.SetPlaybackLog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDelMarGhostReplayLog*            InLog                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarGhostPlaybackSessionComponent::SetPlaybackLog(class UDelMarGhostReplayLog* InLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostPlaybackSessionComponent", "SetPlaybackLog");

	Params::DelMarGhostPlaybackSessionComponent_SetPlaybackLog Parms{};

	Parms.InLog = InLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostPlaybackTrigger.BP_HandlePlaybackCompleted
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarGhostPlaybackTrigger::BP_HandlePlaybackCompleted(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostPlaybackTrigger", "BP_HandlePlaybackCompleted");

	Params::DelMarGhostPlaybackTrigger_BP_HandlePlaybackCompleted Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarGhostPlaybackTrigger.HandlePlaybackCompleted
// (Final, Native, Protected)

void ADelMarGhostPlaybackTrigger::HandlePlaybackCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostPlaybackTrigger", "HandlePlaybackCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostPlaybackTrigger.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADelMarGhostPlaybackTrigger::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostPlaybackTrigger", "OnBeginOverlap");

	Params::DelMarGhostPlaybackTrigger_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGhostRecordingSessionComponent.SetRecordOffPhysicsDelegate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarGhostRecordingSessionComponent::SetRecordOffPhysicsDelegate(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostRecordingSessionComponent", "SetRecordOffPhysicsDelegate");

	Params::DelMarGhostRecordingSessionComponent_SetRecordOffPhysicsDelegate Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGlobalLeaderboardControllerComponent.ClientNewPersonalBest
// (Net, NetReliable, Native, Event, Protected, NetClient)
// Parameters:
// const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest&PersonalBestEvent                                      (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarGlobalLeaderboardControllerComponent::ClientNewPersonalBest(const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest& PersonalBestEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGlobalLeaderboardControllerComponent", "ClientNewPersonalBest");

	Params::DelMarGlobalLeaderboardControllerComponent_ClientNewPersonalBest Parms{};

	Parms.PersonalBestEvent = std::move(PersonalBestEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGlobalLeaderboardControllerComponent.ClientUpdateLeaderboards
// (Net, NetReliable, Native, Event, Protected, NetClient)

void UDelMarGlobalLeaderboardControllerComponent::ClientUpdateLeaderboards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGlobalLeaderboardControllerComponent", "ClientUpdateLeaderboards");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGlobalLeaderboardControllerComponent.OnRep_LeaderboardSettings
// (Final, Native, Private)

void UDelMarGlobalLeaderboardControllerComponent::OnRep_LeaderboardSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGlobalLeaderboardControllerComponent", "OnRep_LeaderboardSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGlobalLeaderboardControllerComponent.ServerNewPersonalBest
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest&PersonalBestRetrievedEvent                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarGlobalLeaderboardControllerComponent::ServerNewPersonalBest(const struct FDelMarEvent_GlobalLeaderboardNewPersonalBest& PersonalBestRetrievedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGlobalLeaderboardControllerComponent", "ServerNewPersonalBest");

	Params::DelMarGlobalLeaderboardControllerComponent_ServerNewPersonalBest Parms{};

	Parms.PersonalBestRetrievedEvent = std::move(PersonalBestRetrievedEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.BP_OnTutorialZoneComplete
// (Event, Protected, BlueprintEvent)

void ADelMarGuidedTutorialZoneActor::BP_OnTutorialZoneComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "BP_OnTutorialZoneComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.BP_OnTutorialZoneFailed
// (Event, Protected, BlueprintEvent)

void ADelMarGuidedTutorialZoneActor::BP_OnTutorialZoneFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "BP_OnTutorialZoneFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.BP_OnTutorialZoneStarted
// (Event, Protected, BlueprintEvent)

void ADelMarGuidedTutorialZoneActor::BP_OnTutorialZoneStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "BP_OnTutorialZoneStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.HandleVehicleDemolished
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarGuidedTutorialZoneActor::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "HandleVehicleDemolished");

	Params::DelMarGuidedTutorialZoneActor_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADelMarGuidedTutorialZoneActor::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "OnBeginOverlap");

	Params::DelMarGuidedTutorialZoneActor_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGuidedTutorialZoneActor.OnEndOverlap
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarGuidedTutorialZoneActor::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGuidedTutorialZoneActor", "OnEndOverlap");

	Params::DelMarGuidedTutorialZoneActor_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarInputModifierHazard.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADelMarInputModifierHazard::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarInputModifierHazard", "OnBeginOverlap");

	Params::DelMarInputModifierHazard_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPhysicsRateDevice.SetPhysicsRate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDelMarPhysicsRate                      PhysicsRate                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarPhysicsRateDevice::SetPhysicsRate(EDelMarPhysicsRate PhysicsRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPhysicsRateDevice", "SetPhysicsRate");

	Params::DelMarPhysicsRateDevice_SetPhysicsRate Parms{};

	Parms.PhysicsRate = PhysicsRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerActiveRaceManagerComponent.OnRep_ActiveRaceManager
// (Final, Native, Protected)
// Parameters:
// class ADelMarRaceManager*               PreviousRaceManager                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerActiveRaceManagerComponent::OnRep_ActiveRaceManager(class ADelMarRaceManager* PreviousRaceManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerActiveRaceManagerComponent", "OnRep_ActiveRaceManager");

	Params::DelMarPlayerActiveRaceManagerComponent_OnRep_ActiveRaceManager Parms{};

	Parms.PreviousRaceManager = PreviousRaceManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerActiveRaceManagerComponent.SetActiveRaceManager
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarRaceManager*               RaceManager                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerActiveRaceManagerComponent::SetActiveRaceManager(class ADelMarRaceManager* RaceManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerActiveRaceManagerComponent", "SetActiveRaceManager");

	Params::DelMarPlayerActiveRaceManagerComponent_SetActiveRaceManager Parms{};

	Parms.RaceManager = RaceManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerActiveRaceManagerComponent.GetActiveRaceManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarRaceManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarRaceManager* UDelMarPlayerActiveRaceManagerComponent::GetActiveRaceManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerActiveRaceManagerComponent", "GetActiveRaceManager");

	Params::DelMarPlayerActiveRaceManagerComponent_GetActiveRaceManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleDraftActivated
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleDraftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleDraftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleDriftBoostDeactivated
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleDriftBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleDriftBoostDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleDriftKickActivated
// (Final, Native, Protected)
// Parameters:
// float                                   DriftDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarVehicleDriftState                DriftState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleDriftKickActivated");

	Params::DelMarPlayerAnalyticsComponent_HandleDriftKickActivated Parms{};

	Parms.DriftDirection = DriftDirection;
	Parms.DriftState = DriftState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleKickflipActivated
// (Final, Native, Protected)
// Parameters:
// bool                                    bLeft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleKickflipActivated(bool bLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleKickflipActivated");

	Params::DelMarPlayerAnalyticsComponent_HandleKickflipActivated Parms{};

	Parms.bLeft = bLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandlePlayerResetRun
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandlePlayerResetRun(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandlePlayerResetRun");

	Params::DelMarPlayerAnalyticsComponent_HandlePlayerResetRun Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandlePotentialDriftBoostChanged
// (Final, Native, Protected)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandlePotentialDriftBoostChanged(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandlePotentialDriftBoostChanged");

	Params::DelMarPlayerAnalyticsComponent_HandlePotentialDriftBoostChanged Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleRaceFinished
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleRaceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleRaceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleRaceStarted
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleRaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleRaceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleTurboBonusZoneChanged
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   BonusZoneState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleTurboBonusZoneChanged(EDelMarTurboZoneState BonusZoneState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleTurboBonusZoneChanged");

	Params::DelMarPlayerAnalyticsComponent_HandleTurboBonusZoneChanged Parms{};

	Parms.BonusZoneState = BonusZoneState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleTurboChargeUsed
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleTurboChargeUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleTurboChargeUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleUnderthrustActivated
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleUnderthrustActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleUnderthrustActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleUnderthrustDeactivated
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleUnderthrustDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleUnderthrustDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleUnderthrustPercentChanged
// (Final, Native, Protected)
// Parameters:
// float                                   PercentageUnderthrustRemaining                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleUnderthrustPercentChanged(float PercentageUnderthrustRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleUnderthrustPercentChanged");

	Params::DelMarPlayerAnalyticsComponent_HandleUnderthrustPercentChanged Parms{};

	Parms.PercentageUnderthrustRemaining = PercentageUnderthrustRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleVehicleDemolished
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleVehicleDemolished");

	Params::DelMarPlayerAnalyticsComponent_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleVehicleHitHazard
// (Final, Native, Protected)

void UDelMarPlayerAnalyticsComponent::HandleVehicleHitHazard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleVehicleHitHazard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerAnalyticsComponent.HandleWorldBonusSpeedStackGained
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerAnalyticsComponent::HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerAnalyticsComponent", "HandleWorldBonusSpeedStackGained");

	Params::DelMarPlayerAnalyticsComponent_HandleWorldBonusSpeedStackGained Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.GetNumViewingSpectator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarPlayerRaceDataComponent::GetNumViewingSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "GetNumViewingSpectator");

	Params::DelMarPlayerRaceDataComponent_GetNumViewingSpectator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.GetViewingSpectators
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class APlayerState*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerState*> UDelMarPlayerRaceDataComponent::GetViewingSpectators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "GetViewingSpectators");

	Params::DelMarPlayerRaceDataComponent_GetViewingSpectators Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_CheckpointPassed_ParallelPath
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_CheckpointPassed_ParallelPath&CheckpointEvent                                        (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_CheckpointPassed_ParallelPath(const struct FDelMarEvent_CheckpointPassed_ParallelPath& CheckpointEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_CheckpointPassed_ParallelPath");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_CheckpointPassed_ParallelPath Parms{};

	Parms.CheckpointEvent = std::move(CheckpointEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_CheckpointPassedOutOfOrder_ParallelPath
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath&InCheckpointPassedOutOfOrderEvent                      (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_CheckpointPassedOutOfOrder_ParallelPath(const struct FDelMarEvent_CheckpointPassedOutOfOrder_ParallelPath& InCheckpointPassedOutOfOrderEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_CheckpointPassedOutOfOrder_ParallelPath");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_CheckpointPassedOutOfOrder_ParallelPath Parms{};

	Parms.InCheckpointPassedOutOfOrderEvent = std::move(InCheckpointPassedOutOfOrderEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_LapCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_LapComplete&  InLapEvent                                             (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_LapCompleted(const struct FDelMarEvent_LapComplete& InLapEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_LapCompleted");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_LapCompleted Parms{};

	Parms.InLapEvent = std::move(InLapEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_RaceCompleted
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// double                                  RunTime                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bValidRun                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_RaceCompleted(double RunTime, const bool bValidRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_RaceCompleted");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_RaceCompleted Parms{};

	Parms.RunTime = RunTime;
	Parms.bValidRun = bValidRun;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_SectionCompleted_ParallelPath
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_SectionComplete_ParallelPath&InSectionEvent                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_SectionCompleted_ParallelPath(const struct FDelMarEvent_SectionComplete_ParallelPath& InSectionEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_SectionCompleted_ParallelPath");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_SectionCompleted_ParallelPath Parms{};

	Parms.InSectionEvent = std::move(InSectionEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.NetMulticast_TeleportEntered
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_TeleportEnteredEvent&InCheckpointTeleportingEvent                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarPlayerRaceDataComponent::NetMulticast_TeleportEntered(const struct FDelMarEvent_TeleportEnteredEvent& InCheckpointTeleportingEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "NetMulticast_TeleportEntered");

	Params::DelMarPlayerRaceDataComponent_NetMulticast_TeleportEntered Parms{};

	Parms.InCheckpointTeleportingEvent = std::move(InCheckpointTeleportingEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerRaceDataComponent.OnRep_ViewingSpectators
// (Final, Native, Protected)

void UDelMarPlayerRaceDataComponent::OnRep_ViewingSpectators()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceDataComponent", "OnRep_ViewingSpectators");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerIdleComponent.OnPlayerDisconnected
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerStateAthena*           PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDisconnected                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerIdleComponent::OnPlayerDisconnected(class AFortPlayerStateAthena* PlayerState, bool bIsDisconnected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIdleComponent", "OnPlayerDisconnected");

	Params::DelMarPlayerIdleComponent_OnPlayerDisconnected Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bIsDisconnected = bIsDisconnected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerQuestDistanceTraveledComponent.HandleVehicleDemolished
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerQuestDistanceTraveledComponent::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerQuestDistanceTraveledComponent", "HandleVehicleDemolished");

	Params::DelMarPlayerQuestDistanceTraveledComponent_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerQuestMatchInfoComponent.HandleRaceStarted
// (Final, Native, Protected)

void UDelMarPlayerQuestMatchInfoComponent::HandleRaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerQuestMatchInfoComponent", "HandleRaceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerQuestMatchInfoComponent.HandleVehicleDemolished
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerQuestMatchInfoComponent::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerQuestMatchInfoComponent", "HandleVehicleDemolished");

	Params::DelMarPlayerQuestMatchInfoComponent_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerQuestMatchInfoComponent.HandleVehicleHitHazard
// (Final, Native, Protected)

void UDelMarPlayerQuestMatchInfoComponent::HandleVehicleHitHazard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerQuestMatchInfoComponent", "HandleVehicleHitHazard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarProxyGhostVisualComponent.HandlePartCustomizationUpdated
// (Final, Native, Protected)
// Parameters:
// const int32                             MeshPartIndex                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarProxyGhostVisualComponent::HandlePartCustomizationUpdated(const int32 MeshPartIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarProxyGhostVisualComponent", "HandlePartCustomizationUpdated");

	Params::DelMarProxyGhostVisualComponent_HandlePartCustomizationUpdated Parms{};

	Parms.MeshPartIndex = MeshPartIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarProxyGhostVisualComponent.HandleVehicleCosmeticsFinished
// (Final, Native, Protected)

void UDelMarProxyGhostVisualComponent::HandleVehicleCosmeticsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarProxyGhostVisualComponent", "HandleVehicleCosmeticsFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarProxyGhostVisualComponent.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarProxyGhostVisualComponent::HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarProxyGhostVisualComponent", "HandleViewTargetChanged");

	Params::DelMarProxyGhostVisualComponent_HandleViewTargetChanged Parms{};

	Parms.InController = InController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceInfoComponent.HandleRaceStarted
// (Final, Native, Protected)

void UDelMarRaceInfoComponent::HandleRaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceInfoComponent", "HandleRaceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceLevelConfig.SpawnRaceManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bFireInitializationEvent                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarRaceManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarRaceManager* ADelMarRaceLevelConfig::SpawnRaceManager(bool bFireInitializationEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceLevelConfig", "SpawnRaceManager");

	Params::DelMarRaceLevelConfig_SpawnRaceManager Parms{};

	Parms.bFireInitializationEvent = bFireInitializationEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceLevelConfig.GetRaceManagerClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ADelMarRaceManager>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class ADelMarRaceManager> ADelMarRaceLevelConfig::GetRaceManagerClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceLevelConfig", "GetRaceManagerClass");

	Params::DelMarRaceLevelConfig_GetRaceManagerClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceLevelConfig.GetRaceModeTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADelMarRaceLevelConfig::GetRaceModeTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceLevelConfig", "GetRaceModeTag");

	Params::DelMarRaceLevelConfig_GetRaceModeTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandleCountdownStarted
// (Final, Native, Protected)

void UDelMarRaceManagerVerbComponent::HandleCountdownStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandleCountdownStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandleFinalRacePositionsChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<struct FDelMarFinalRacePositionEntry>&FinalRacePositions                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDelMarEvent_RunRecorded&  RecordedRun                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRaceManagerVerbComponent::HandleFinalRacePositionsChanged(const TArray<struct FDelMarFinalRacePositionEntry>& FinalRacePositions, const struct FDelMarEvent_RunRecorded& RecordedRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandleFinalRacePositionsChanged");

	Params::DelMarRaceManagerVerbComponent_HandleFinalRacePositionsChanged Parms{};

	Parms.FinalRacePositions = std::move(FinalRacePositions);
	Parms.RecordedRun = std::move(RecordedRun);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandlePlayerLapCompleted
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_LapComplete&  LapCompleteEvent                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarRaceManagerVerbComponent::HandlePlayerLapCompleted(const struct FDelMarEvent_LapComplete& LapCompleteEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandlePlayerLapCompleted");

	Params::DelMarRaceManagerVerbComponent_HandlePlayerLapCompleted Parms{};

	Parms.LapCompleteEvent = std::move(LapCompleteEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandlePlayerPositionsChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<class AFortPlayerState*>&  RacePositions                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRaceManagerVerbComponent::HandlePlayerPositionsChanged(const TArray<class AFortPlayerState*>& RacePositions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandlePlayerPositionsChanged");

	Params::DelMarRaceManagerVerbComponent_HandlePlayerPositionsChanged Parms{};

	Parms.RacePositions = std::move(RacePositions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandleRaceFinished
// (Final, Native, Protected)

void UDelMarRaceManagerVerbComponent::HandleRaceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandleRaceFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceManagerVerbComponent.HandleRaceStarted
// (Final, Native, Protected)

void UDelMarRaceManagerVerbComponent::HandleRaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceManagerVerbComponent", "HandleRaceStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceMusicPlaylistComponent.SetMusicPlaylist
// (Native, Protected, BlueprintCallable)
// Parameters:
// class UDelMarRaceMusicPlaylist*         SetPlaylist                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnableMusic                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRaceMusicPlaylistComponent::SetMusicPlaylist(class UDelMarRaceMusicPlaylist* SetPlaylist, bool bEnableMusic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceMusicPlaylistComponent", "SetMusicPlaylist");

	Params::DelMarRaceMusicPlaylistComponent_SetMusicPlaylist Parms{};

	Parms.SetPlaylist = SetPlaylist;
	Parms.bEnableMusic = bEnableMusic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpeedUpDevice.BP_HandleSpeedEffectGranted
// (Event, Protected, BlueprintEvent)

void ADelMarSpeedUpDevice::BP_HandleSpeedEffectGranted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpeedUpDevice", "BP_HandleSpeedEffectGranted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarSpeedUpDevice.OnBeginOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADelMarSpeedUpDevice::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpeedUpDevice", "OnBeginOverlap");

	Params::DelMarSpeedUpDevice_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSpeedUpDevice.ShouldGrantSpeedEffect
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarSpeedUpDevice::ShouldGrantSpeedEffect(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSpeedUpDevice", "ShouldGrantSpeedEffect");

	Params::DelMarSpeedUpDevice_ShouldGrantSpeedEffect Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialInteractableSpline.BP_HandleAllSplineTriggersCompleted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           FinalCompletedTrigger                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTutorialInteractableSpline::BP_HandleAllSplineTriggersCompleted(class AActor* FinalCompletedTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "BP_HandleAllSplineTriggersCompleted");

	Params::DelMarTutorialInteractableSpline_BP_HandleAllSplineTriggersCompleted Parms{};

	Parms.FinalCompletedTrigger = FinalCompletedTrigger;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarTutorialInteractableSpline.HandleColliderOverlap
// (Final, Native, Protected)
// Parameters:
// class ADelMarTutorialTriggerActor*      InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTutorialInteractableSpline::HandleColliderOverlap(class ADelMarTutorialTriggerActor* InTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "HandleColliderOverlap");

	Params::DelMarTutorialInteractableSpline_HandleColliderOverlap Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialInteractableSpline.ResetTriggers
// (Final, Native, Public, BlueprintCallable)

void ADelMarTutorialInteractableSpline::ResetTriggers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "ResetTriggers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialInteractableSpline.GetHaveAllTriggersCompleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTutorialInteractableSpline::GetHaveAllTriggersCompleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "GetHaveAllTriggersCompleted");

	Params::DelMarTutorialInteractableSpline_GetHaveAllTriggersCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialInteractableSpline.GetTriggerIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTutorialTriggerActor*      InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTutorialInteractableSpline::GetTriggerIndex(class ADelMarTutorialTriggerActor* InTrigger) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "GetTriggerIndex");

	Params::DelMarTutorialInteractableSpline_GetTriggerIndex Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialInteractableSpline.GetTriggerIndexAsRatio
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTutorialTriggerActor*      InTrigger                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTutorialInteractableSpline::GetTriggerIndexAsRatio(class ADelMarTutorialTriggerActor* InTrigger) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialInteractableSpline", "GetTriggerIndexAsRatio");

	Params::DelMarTutorialInteractableSpline_GetTriggerIndexAsRatio Parms{};

	Parms.InTrigger = InTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialTriggerActor.BP_CanTriggerActor
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTutorialTriggerActor::BP_CanTriggerActor(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "BP_CanTriggerActor");

	Params::DelMarTutorialTriggerActor_BP_CanTriggerActor Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialTriggerActor.BP_HandleColliderReset
// (Event, Protected, BlueprintEvent)

void ADelMarTutorialTriggerActor::BP_HandleColliderReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "BP_HandleColliderReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarTutorialTriggerActor.BP_HandleColliderTriggered
// (Event, Protected, BlueprintEvent)

void ADelMarTutorialTriggerActor::BP_HandleColliderTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "BP_HandleColliderTriggered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarTutorialTriggerActor.CanTriggerActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTutorialTriggerActor::CanTriggerActor(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "CanTriggerActor");

	Params::DelMarTutorialTriggerActor_CanTriggerActor Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTutorialTriggerActor.HandleColliderOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ADelMarTutorialTriggerActor::HandleColliderOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "HandleColliderOverlap");

	Params::DelMarTutorialTriggerActor_HandleColliderOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialTriggerActor.ResetTrigger
// (Final, Native, Public, BlueprintCallable)

void ADelMarTutorialTriggerActor::ResetTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialTriggerActor", "ResetTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarUIInputControllerComponent.HandleHudWidgetExpandCompleted
// (Final, Native, Protected)

void UDelMarUIInputControllerComponent::HandleHudWidgetExpandCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUIInputControllerComponent", "HandleHudWidgetExpandCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarUIInputControllerComponent.HandleHudWidgetExpandTriggered
// (Final, Native, Protected)

void UDelMarUIInputControllerComponent::HandleHudWidgetExpandTriggered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUIInputControllerComponent", "HandleHudWidgetExpandTriggered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarUIInputControllerComponent.HandleToggleQuestList
// (Final, Native, Protected)

void UDelMarUIInputControllerComponent::HandleToggleQuestList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUIInputControllerComponent", "HandleToggleQuestList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_Jump.HandleJump
// (Final, Native, Public)

void UDelMarVehicleAction_Jump::HandleJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_Jump", "HandleJump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_Drift.HandleDrift
// (Final, Native, Public)
// Parameters:
// float                                   DriftDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarVehicleDriftState                DriftState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleAction_Drift::HandleDrift(float DriftDirection, EDelMarVehicleDriftState DriftState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_Drift", "HandleDrift");

	Params::DelMarVehicleAction_Drift_HandleDrift Parms{};

	Parms.DriftDirection = DriftDirection;
	Parms.DriftState = DriftState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_HazardHit.HandleHazardHit
// (Final, Native, Public)

void UDelMarVehicleAction_HazardHit::HandleHazardHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_HazardHit", "HandleHazardHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_KickFlip.HandleKickflip
// (Final, Native, Public)
// Parameters:
// bool                                    bLeftSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleAction_KickFlip::HandleKickflip(bool bLeftSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_KickFlip", "HandleKickflip");

	Params::DelMarVehicleAction_KickFlip_HandleKickflip Parms{};

	Parms.bLeftSide = bLeftSide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_Turbo.HandleTurbo
// (Final, Native, Public)

void UDelMarVehicleAction_Turbo::HandleTurbo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_Turbo", "HandleTurbo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleAction_Underthrust.HandleUnderthrust
// (Final, Native, Public)

void UDelMarVehicleAction_Underthrust::HandleUnderthrust()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleAction_Underthrust", "HandleUnderthrust");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnAirFreestyleDeactivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnAirFreestyleDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnAirFreestyleDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnAppliedTeleportRotation
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnAppliedTeleportRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnAppliedTeleportRotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnDriftBonusActivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnDriftBonusActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnDriftBonusActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnDriftBonusDeactivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnDriftBonusDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnDriftBonusDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnDriftKickActivated
// (Final, Native, Protected)
// Parameters:
// float                                   DriftDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarVehicleDriftState                DriftState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleCameraMode_V2::OnDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnDriftKickActivated");

	Params::DelMarVehicleCameraMode_V2_OnDriftKickActivated Parms{};

	Parms.DriftDirection = DriftDirection;
	Parms.DriftState = DriftState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnDriftKickDeactivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnDriftKickDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnDriftKickDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnStartlineBoostActivated
// (Final, Native, Protected)
// Parameters:
// float                                   StartlineBoostPerc                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleCameraMode_V2::OnStartlineBoostActivated(float StartlineBoostPerc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnStartlineBoostActivated");

	Params::DelMarVehicleCameraMode_V2_OnStartlineBoostActivated Parms{};

	Parms.StartlineBoostPerc = StartlineBoostPerc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnStartlineBoostDeactivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnStartlineBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnStartlineBoostDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnTurboActivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnTurboActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnTurboActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnTurboBonusZoneStateChanged
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   ZoneState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleCameraMode_V2::OnTurboBonusZoneStateChanged(EDelMarTurboZoneState ZoneState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnTurboBonusZoneStateChanged");

	Params::DelMarVehicleCameraMode_V2_OnTurboBonusZoneStateChanged Parms{};

	Parms.ZoneState = ZoneState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnTurboDeactivated
// (Final, Native, Protected)

void UDelMarVehicleCameraMode_V2::OnTurboDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnTurboDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnWorldBonusSpeedStackGained
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleCameraMode_V2::OnWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnWorldBonusSpeedStackGained");

	Params::DelMarVehicleCameraMode_V2_OnWorldBonusSpeedStackGained Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCameraMode_V2.OnWorldBonusSpeedStackLost
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleCameraMode_V2::OnWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCameraMode_V2", "OnWorldBonusSpeedStackLost");

	Params::DelMarVehicleCameraMode_V2_OnWorldBonusSpeedStackLost Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleInterface.AnyWheelsOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::AnyWheelsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "AnyWheelsOnGround");

	Params::DelMarVehicleInterface_AnyWheelsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.CanStrafeBeActivated
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::CanStrafeBeActivated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "CanStrafeBeActivated");

	Params::DelMarVehicleInterface_CanStrafeBeActivated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetAcceleration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetAcceleration");

	Params::DelMarVehicleInterface_GetAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetBaseForwardSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetBaseForwardSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetBaseForwardSpeed");

	Params::DelMarVehicleInterface_GetBaseForwardSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetBaseTargetSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetBaseTargetSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetBaseTargetSpeed");

	Params::DelMarVehicleInterface_GetBaseTargetSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetBonusSpeed");

	Params::DelMarVehicleInterface_GetBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetCosmeticComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarVehicleCosmeticComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarVehicleCosmeticComponent* IDelMarVehicleInterface::GetCosmeticComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetCosmeticComponent");

	Params::DelMarVehicleInterface_GetCosmeticComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetCurrentNumTurboCharges
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetCurrentNumTurboCharges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetCurrentNumTurboCharges");

	Params::DelMarVehicleInterface_GetCurrentNumTurboCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetCurrentTurboBonusZoneState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarTurboZoneState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarTurboZoneState IDelMarVehicleInterface::GetCurrentTurboBonusZoneState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetCurrentTurboBonusZoneState");

	Params::DelMarVehicleInterface_GetCurrentTurboBonusZoneState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDraftingCurrentBonusSpeedPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDraftingCurrentBonusSpeedPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDraftingCurrentBonusSpeedPercentage");

	Params::DelMarVehicleInterface_GetDraftingCurrentBonusSpeedPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDraftingMaxBonusSpeedPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDraftingMaxBonusSpeedPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDraftingMaxBonusSpeedPercentage");

	Params::DelMarVehicleInterface_GetDraftingMaxBonusSpeedPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDraftingState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelmarDraftingState                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelmarDraftingState IDelMarVehicleInterface::GetDraftingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDraftingState");

	Params::DelMarVehicleInterface_GetDraftingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDraftingTargetDegrees
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDraftingTargetDegrees() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDraftingTargetDegrees");

	Params::DelMarVehicleInterface_GetDraftingTargetDegrees Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDriftAngle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDriftAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDriftAngle");

	Params::DelMarVehicleInterface_GetDriftAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDriftBoostAppliedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDriftBoostAppliedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDriftBoostAppliedBonusSpeed");

	Params::DelMarVehicleInterface_GetDriftBoostAppliedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDriftDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDriftDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDriftDuration");

	Params::DelMarVehicleInterface_GetDriftDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetDriftSlipAngleRatio
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetDriftSlipAngleRatio() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetDriftSlipAngleRatio");

	Params::DelMarVehicleInterface_GetDriftSlipAngleRatio Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetForwardSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetForwardSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetForwardSpeed");

	Params::DelMarVehicleInterface_GetForwardSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetKickflipActivationCharges
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 IDelMarVehicleInterface::GetKickflipActivationCharges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetKickflipActivationCharges");

	Params::DelMarVehicleInterface_GetKickflipActivationCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetKickflipDistanceToSuctionSurface
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetKickflipDistanceToSuctionSurface() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetKickflipDistanceToSuctionSurface");

	Params::DelMarVehicleInterface_GetKickflipDistanceToSuctionSurface Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetKickflipDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetKickflipDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetKickflipDuration");

	Params::DelMarVehicleInterface_GetKickflipDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetLandingData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDelMarVehicleLandingData        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarVehicleLandingData IDelMarVehicleInterface::GetLandingData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetLandingData");

	Params::DelMarVehicleInterface_GetLandingData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetMaxNumTurboCharges
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetMaxNumTurboCharges() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetMaxNumTurboCharges");

	Params::DelMarVehicleInterface_GetMaxNumTurboCharges Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetNormalizedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetNormalizedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetNormalizedBonusSpeed");

	Params::DelMarVehicleInterface_GetNormalizedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetNormalizedForwardSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetNormalizedForwardSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetNormalizedForwardSpeed");

	Params::DelMarVehicleInterface_GetNormalizedForwardSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetOversteerAccumulationPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetOversteerAccumulationPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetOversteerAccumulationPercentage");

	Params::DelMarVehicleInterface_GetOversteerAccumulationPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetPercentageTurboActiveTimeRemaining
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetPercentageTurboActiveTimeRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetPercentageTurboActiveTimeRemaining");

	Params::DelMarVehicleInterface_GetPercentageTurboActiveTimeRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetPostProcessComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPostProcessComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPostProcessComponent* IDelMarVehicleInterface::GetPostProcessComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetPostProcessComponent");

	Params::DelMarVehicleInterface_GetPostProcessComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetPotentialDriftBoostPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetPotentialDriftBoostPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetPotentialDriftBoostPercentage");

	Params::DelMarVehicleInterface_GetPotentialDriftBoostPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetQueuedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetQueuedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetQueuedBonusSpeed");

	Params::DelMarVehicleInterface_GetQueuedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetReattachmentDirection
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IDelMarVehicleInterface::GetReattachmentDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetReattachmentDirection");

	Params::DelMarVehicleInterface_GetReattachmentDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetRemainingTurboActiveSeconds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetRemainingTurboActiveSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetRemainingTurboActiveSeconds");

	Params::DelMarVehicleInterface_GetRemainingTurboActiveSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetSideSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetSideSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetSideSpeed");

	Params::DelMarVehicleInterface_GetSideSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetSkeletalMeshComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* IDelMarVehicleInterface::GetSkeletalMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetSkeletalMeshComponent");

	Params::DelMarVehicleInterface_GetSkeletalMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetSpeedometerSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetSpeedometerSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetSpeedometerSpeed");

	Params::DelMarVehicleInterface_GetSpeedometerSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetStableSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetStableSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetStableSpeed");

	Params::DelMarVehicleInterface_GetStableSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetStartlineAppliedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetStartlineAppliedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetStartlineAppliedBonusSpeed");

	Params::DelMarVehicleInterface_GetStartlineAppliedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetStartlineMaxEarnedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetStartlineMaxEarnedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetStartlineMaxEarnedBonusSpeed");

	Params::DelMarVehicleInterface_GetStartlineMaxEarnedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetStartlinePercentageMaxBonusSpeedEarned
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetStartlinePercentageMaxBonusSpeedEarned() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetStartlinePercentageMaxBonusSpeedEarned");

	Params::DelMarVehicleInterface_GetStartlinePercentageMaxBonusSpeedEarned Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetSteering
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetSteering() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetSteering");

	Params::DelMarVehicleInterface_GetSteering Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetSteeringAngle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetSteeringAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetSteeringAngle");

	Params::DelMarVehicleInterface_GetSteeringAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetStrafeCooldownPercentage
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetStrafeCooldownPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetStrafeCooldownPercentage");

	Params::DelMarVehicleInterface_GetStrafeCooldownPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTargetDriftSide
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTargetDriftSide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTargetDriftSide");

	Params::DelMarVehicleInterface_GetTargetDriftSide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTargetSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTargetSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTargetSpeed");

	Params::DelMarVehicleInterface_GetTargetSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetThrottle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetThrottle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetThrottle");

	Params::DelMarVehicleInterface_GetThrottle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTotalTimeSkydiving
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTotalTimeSkydiving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTotalTimeSkydiving");

	Params::DelMarVehicleInterface_GetTotalTimeSkydiving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTrackPositionComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarTrackPositionComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTrackPositionComponent* IDelMarVehicleInterface::GetTrackPositionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTrackPositionComponent");

	Params::DelMarVehicleInterface_GetTrackPositionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTurboAdditionalActiveSeconds
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTurboAdditionalActiveSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTurboAdditionalActiveSeconds");

	Params::DelMarVehicleInterface_GetTurboAdditionalActiveSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTurboAppliedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTurboAppliedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTurboAppliedBonusSpeed");

	Params::DelMarVehicleInterface_GetTurboAppliedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetTurboBonusZoneBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetTurboBonusZoneBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetTurboBonusZoneBonusSpeed");

	Params::DelMarVehicleInterface_GetTurboBonusZoneBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetUnderthrustActiveDuration
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetUnderthrustActiveDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetUnderthrustActiveDuration");

	Params::DelMarVehicleInterface_GetUnderthrustActiveDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetUnderthrustPercentageTankRemaining
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetUnderthrustPercentageTankRemaining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetUnderthrustPercentageTankRemaining");

	Params::DelMarVehicleInterface_GetUnderthrustPercentageTankRemaining Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetVehicleForwardState
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarVehicleForwardState              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarVehicleForwardState IDelMarVehicleInterface::GetVehicleForwardState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetVehicleForwardState");

	Params::DelMarVehicleInterface_GetVehicleForwardState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IDelMarVehicleInterface::GetVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetVelocity");

	Params::DelMarVehicleInterface_GetVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.GetWorldAppliedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IDelMarVehicleInterface::GetWorldAppliedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "GetWorldAppliedBonusSpeed");

	Params::DelMarVehicleInterface_GetWorldAppliedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.HasValidDraftingTarget
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::HasValidDraftingTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "HasValidDraftingTarget");

	Params::DelMarVehicleInterface_HasValidDraftingTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.InDriftBoostRange
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::InDriftBoostRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "InDriftBoostRange");

	Params::DelMarVehicleInterface_InDriftBoostRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsAccelerating
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsAccelerating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsAccelerating");

	Params::DelMarVehicleInterface_IsAccelerating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsAirFreestyling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsAirFreestyling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsAirFreestyling");

	Params::DelMarVehicleInterface_IsAirFreestyling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsAllVehicleInputDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsAllVehicleInputDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsAllVehicleInputDisabled");

	Params::DelMarVehicleInterface_IsAllVehicleInputDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsBraking
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsBraking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsBraking");

	Params::DelMarVehicleInterface_IsBraking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsDriftControlled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsDriftControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsDriftControlled");

	Params::DelMarVehicleInterface_IsDriftControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsInvulnerabilityActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsInvulnerabilityActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsInvulnerabilityActive");

	Params::DelMarVehicleInterface_IsInvulnerabilityActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsKickflipSuctionActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsKickflipSuctionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsKickflipSuctionActive");

	Params::DelMarVehicleInterface_IsKickflipSuctionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsKickingWheels
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsKickingWheels() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsKickingWheels");

	Params::DelMarVehicleInterface_IsKickingWheels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsLosingAppliedBonusSpeed
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsLosingAppliedBonusSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsLosingAppliedBonusSpeed");

	Params::DelMarVehicleInterface_IsLosingAppliedBonusSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsReattaching
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsReattaching() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsReattaching");

	Params::DelMarVehicleInterface_IsReattaching Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsSkyDiving
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsSkyDiving() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsSkyDiving");

	Params::DelMarVehicleInterface_IsSkyDiving Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsStrafeActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsStrafeActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsStrafeActive");

	Params::DelMarVehicleInterface_IsStrafeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsStrafeDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsStrafeDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsStrafeDisabled");

	Params::DelMarVehicleInterface_IsStrafeDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.IsStrafeLeft
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::IsStrafeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "IsStrafeLeft");

	Params::DelMarVehicleInterface_IsStrafeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleInterface.WheelsOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IDelMarVehicleInterface::WheelsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("DelMarVehicleInterface", "WheelsOnGround");

	Params::DelMarVehicleInterface_WheelsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleManager.BP_GetAllVehicles
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class ADelMarVehicle*>*          OutVehicles                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::BP_GetAllVehicles(TArray<class ADelMarVehicle*>* OutVehicles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "BP_GetAllVehicles");

	Params::DelMarVehicleManager_BP_GetAllVehicles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVehicles != nullptr)
		*OutVehicles = std::move(Parms.OutVehicles);
}


// Function DelMarCore.DelMarVehicleManager.BP_GetVehiclesInRange
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   SourcePosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Range                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bDo2DCheck                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADelMarVehicle*>*          OutVehicles                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::BP_GetVehiclesInRange(const struct FVector& SourcePosition, const float Range, const bool bDo2DCheck, TArray<class ADelMarVehicle*>* OutVehicles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "BP_GetVehiclesInRange");

	Params::DelMarVehicleManager_BP_GetVehiclesInRange Parms{};

	Parms.SourcePosition = std::move(SourcePosition);
	Parms.Range = Range;
	Parms.bDo2DCheck = bDo2DCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutVehicles != nullptr)
		*OutVehicles = std::move(Parms.OutVehicles);
}


// Function DelMarCore.DelMarVehicleManager.HandlePawnEnteredVehicle
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TScriptInterface<class IFortVehicleInterface>&Vehicle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SeatIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::HandlePawnEnteredVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "HandlePawnEnteredVehicle");

	Params::DelMarVehicleManager_HandlePawnEnteredVehicle Parms{};

	Parms.Vehicle = Vehicle;
	Parms.Pawn = Pawn;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleManager.HandlePawnExitedVehicle
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TScriptInterface<class IFortVehicleInterface>&Vehicle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SeatIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::HandlePawnExitedVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "HandlePawnExitedVehicle");

	Params::DelMarVehicleManager_HandlePawnExitedVehicle Parms{};

	Parms.Vehicle = Vehicle;
	Parms.Pawn = Pawn;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleManager.HandlePawnPlayerStateSet
// (Final, Native, Public)
// Parameters:
// class AFortPlayerPawn*                  Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::HandlePawnPlayerStateSet(class AFortPlayerPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "HandlePawnPlayerStateSet");

	Params::DelMarVehicleManager_HandlePawnPlayerStateSet Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleManager.HandleViewTargetChanged
// (Final, Native, Public)
// Parameters:
// class AFortPlayerController*            InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleManager::HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleManager", "HandleViewTargetChanged");

	Params::DelMarVehicleManager_HandleViewTargetChanged Parms{};

	Parms.InController = InController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.AddTargetSpeedAdjustment
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const class FName&                      Source                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::AddTargetSpeedAdjustment(const class FName& Source, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "AddTargetSpeedAdjustment");

	Params::DelMarVehicle_AddTargetSpeedAdjustment Parms{};

	Parms.Source = Source;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.AddWorldBonusSpeedStack
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDelMarWorldBonusSpeedStack&BonusSpeedStack                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ADelMarVehicle::AddWorldBonusSpeedStack(const struct FDelMarWorldBonusSpeedStack& BonusSpeedStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "AddWorldBonusSpeedStack");

	Params::DelMarVehicle_AddWorldBonusSpeedStack Parms{};

	Parms.BonusSpeedStack = std::move(BonusSpeedStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ClearConfigOverrides
// (Final, Native, Public, BlueprintCallable)

void ADelMarVehicle::ClearConfigOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ClearConfigOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.DemolishVehicle
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FGameplayTag&              InCausedByTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::DemolishVehicle(const struct FGameplayTag& InCausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "DemolishVehicle");

	Params::DelMarVehicle_DemolishVehicle Parms{};

	Parms.InCausedByTag = std::move(InCausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleAerialThrottleBrakeChanged
// (Final, Native, Protected)

void ADelMarVehicle::HandleAerialThrottleBrakeChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleAerialThrottleBrakeChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleFinishedCharacterCustomization
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerPawn*                  PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::HandleFinishedCharacterCustomization(class AFortPlayerPawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleFinishedCharacterCustomization");

	Params::DelMarVehicle_HandleFinishedCharacterCustomization Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleNewPlayerState
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerPawn*                  Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::HandleNewPlayerState(class AFortPlayerPawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleNewPlayerState");

	Params::DelMarVehicle_HandleNewPlayerState Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleOnVehicleCosmeticsFinished
// (Final, Native, Protected)

void ADelMarVehicle::HandleOnVehicleCosmeticsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleOnVehicleCosmeticsFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandlePitchDeadzoneChanged
// (Final, Native, Protected)

void ADelMarVehicle::HandlePitchDeadzoneChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandlePitchDeadzoneChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleSteerDeadzoneChanged
// (Final, Native, Protected)

void ADelMarVehicle::HandleSteerDeadzoneChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleSteerDeadzoneChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleThrottleDeadzoneChanged
// (Final, Native, Protected)

void ADelMarVehicle::HandleThrottleDeadzoneChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleThrottleDeadzoneChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.HandleThrottleToggleChanged
// (Final, Native, Protected)

void ADelMarVehicle::HandleThrottleToggleChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "HandleThrottleToggleChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnApplyOverlapFilter
// (Native, Event, Protected, BlueprintEvent)

void ADelMarVehicle::OnApplyOverlapFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnApplyOverlapFilter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnRep_bPawnCollisionsEnabled
// (Final, Native, Protected)

void ADelMarVehicle::OnRep_bPawnCollisionsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_bPawnCollisionsEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnRep_bVehicleCollisionsEnabled
// (Final, Native, Protected)

void ADelMarVehicle::OnRep_bVehicleCollisionsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_bVehicleCollisionsEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnRep_SpawnInfo
// (Final, Native, Private)

void ADelMarVehicle::OnRep_SpawnInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_SpawnInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnRep_StartlineBoostData
// (Final, Native, Private)

void ADelMarVehicle::OnRep_StartlineBoostData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_StartlineBoostData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.OnRep_TurboCharges
// (Final, Native, Public)

void ADelMarVehicle::OnRep_TurboCharges()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_TurboCharges");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ResetRunPressed
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADelMarVehicle::ResetRunPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ResetRunPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ResetTrackPosition
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ADelMarTrackBase*                 Track                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrackSegment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::ResetTrackPosition(class ADelMarTrackBase* Track, int32 TrackSegment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ResetTrackPosition");

	Params::DelMarVehicle_ResetTrackPosition Parms{};

	Parms.Track = Track;
	Parms.TrackSegment = TrackSegment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerAddReplicatedGameplayTag
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerAddReplicatedGameplayTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerAddReplicatedGameplayTag");

	Params::DelMarVehicle_ServerAddReplicatedGameplayTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerAddReplicatedGameplayTags
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     InTags                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerAddReplicatedGameplayTags(const struct FGameplayTagContainer& InTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerAddReplicatedGameplayTags");

	Params::DelMarVehicle_ServerAddReplicatedGameplayTags Parms{};

	Parms.InTags = std::move(InTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerDemolishVehicle
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InCausedByTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerDemolishVehicle(const struct FGameplayTag& InCausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerDemolishVehicle");

	Params::DelMarVehicle_ServerDemolishVehicle Parms{};

	Parms.InCausedByTag = std::move(InCausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerNotifyTurboActivated
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADelMarVehicle::ServerNotifyTurboActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerNotifyTurboActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerOnClientTeleport
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ADelMarVehicle::ServerOnClientTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerOnClientTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerRemoveReplicatedGameplayTag
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerRemoveReplicatedGameplayTag(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerRemoveReplicatedGameplayTag");

	Params::DelMarVehicle_ServerRemoveReplicatedGameplayTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerRemoveReplicatedGameplayTags
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     InTags                                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerRemoveReplicatedGameplayTags(const struct FGameplayTagContainer& InTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerRemoveReplicatedGameplayTags");

	Params::DelMarVehicle_ServerRemoveReplicatedGameplayTags Parms{};

	Parms.InTags = std::move(InTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerSetLocalDriverHasReplicatedTheVehicle
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::ServerSetLocalDriverHasReplicatedTheVehicle(bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerSetLocalDriverHasReplicatedTheVehicle");

	Params::DelMarVehicle_ServerSetLocalDriverHasReplicatedTheVehicle Parms{};

	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerTeleportVehicleEntered
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ADelMarVehicle::ServerTeleportVehicleEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerTeleportVehicleEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.ServerTeleportVehicleExited
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ADelMarVehicle::ServerTeleportVehicleExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "ServerTeleportVehicleExited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.SetConfigOverrides
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDelMarVehicleConfigOverrides&InConfigOverrides                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ADelMarVehicle::SetConfigOverrides(const struct FDelMarVehicleConfigOverrides& InConfigOverrides)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "SetConfigOverrides");

	Params::DelMarVehicle_SetConfigOverrides Parms{};

	Parms.InConfigOverrides = std::move(InConfigOverrides);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.SetVehicleMesh
// (Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMesh*                    NewMesh                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPhysicsAsset*                    PhysicsAsset                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarVehicle::SetVehicleMesh(class USkeletalMesh* NewMesh, class UPhysicsAsset* PhysicsAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "SetVehicleMesh");

	Params::DelMarVehicle_SetVehicleMesh Parms{};

	Parms.NewMesh = NewMesh;
	Parms.PhysicsAsset = PhysicsAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.TeleportVehicleEntered
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADelMarVehicle::TeleportVehicleEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "TeleportVehicleEntered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.TeleportVehicleExited
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ADelMarVehicle::TeleportVehicleExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "TeleportVehicleExited");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.TryGetFortClientSettings
// (Final, Native, Protected)

void ADelMarVehicle::TryGetFortClientSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "TryGetFortClientSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.GetAudioComponentGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarAudioComponentGroup*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarAudioComponentGroup* ADelMarVehicle::GetAudioComponentGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "GetAudioComponentGroup");

	Params::DelMarVehicle_GetAudioComponentGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.GetCosmeticComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarVehicleCosmeticComponent*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarVehicleCosmeticComponent* ADelMarVehicle::GetCosmeticComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "GetCosmeticComponent");

	Params::DelMarVehicle_GetCosmeticComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.GetRaceManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarRaceManager*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarRaceManager* ADelMarVehicle::GetRaceManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "GetRaceManager");

	Params::DelMarVehicle_GetRaceManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.GetTrackPositionComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarTrackPositionComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTrackPositionComponent* ADelMarVehicle::GetTrackPositionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "GetTrackPositionComponent");

	Params::DelMarVehicle_GetTrackPositionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.IsInvulnerabilityActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarVehicle::IsInvulnerabilityActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "IsInvulnerabilityActive");

	Params::DelMarVehicle_IsInvulnerabilityActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.IsRespawnEffectSignificant
// (Final, Native, Private, BlueprintCallable, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarVehicle::IsRespawnEffectSignificant() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "IsRespawnEffectSignificant");

	Params::DelMarVehicle_IsRespawnEffectSignificant Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.IsWheelOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarVehicleWheelIndex                WheelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarVehicle::IsWheelOnGround(EDelMarVehicleWheelIndex WheelIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "IsWheelOnGround");

	Params::DelMarVehicle_IsWheelOnGround Parms{};

	Parms.WheelIndex = WheelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicle.OnRep_ConfigOverrides
// (Final, Native, Private, Const)

void ADelMarVehicle::OnRep_ConfigOverrides() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "OnRep_ConfigOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicle.VehicleHasTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarVehicle::VehicleHasTag(const struct FGameplayTag& InTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicle", "VehicleHasTag");

	Params::DelMarVehicle_VehicleHasTag Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleNetworkPhysicsComponent.OnPhysicsStateChanged
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              ChangedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComponentPhysicsStateChange            StateChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleNetworkPhysicsComponent::OnPhysicsStateChanged(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleNetworkPhysicsComponent", "OnPhysicsStateChanged");

	Params::DelMarVehicleNetworkPhysicsComponent_OnPhysicsStateChanged Parms{};

	Parms.ChangedComponent = ChangedComponent;
	Parms.StateChange = StateChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleNetworkPhysicsComponent.OnRep_ReplicatedState
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarVehicleReplicatedState&PrevReplicatedState                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarVehicleNetworkPhysicsComponent::OnRep_ReplicatedState(const struct FDelMarVehicleReplicatedState& PrevReplicatedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleNetworkPhysicsComponent", "OnRep_ReplicatedState");

	Params::DelMarVehicleNetworkPhysicsComponent_OnRep_ReplicatedState Parms{};

	Parms.PrevReplicatedState = std::move(PrevReplicatedState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleAnyWheelsOnGroundChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&Vehicle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWheelsOnGround                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleStateTagManagerComponent::HandleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& Vehicle, bool bWheelsOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleAnyWheelsOnGroundChanged");

	Params::DelMarVehicleStateTagManagerComponent_HandleAnyWheelsOnGroundChanged Parms{};

	Parms.Vehicle = Vehicle;
	Parms.bWheelsOnGround = bWheelsOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDraftActivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDraftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDraftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDraftDeactivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDraftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDraftDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDriftActivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDriftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDriftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDriftBoostActivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDriftBoostActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDriftBoostActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDriftBoostDeactivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDriftBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDriftBoostDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleDriftDeactivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleDriftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleDriftDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleTurboChargeUsed
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleTurboChargeUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleTurboChargeUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleTurboDeactivated
// (Final, Native, Protected)

void UDelMarVehicleStateTagManagerComponent::HandleTurboDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleTurboDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleWorldBonusSpeedStackGained
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleStateTagManagerComponent::HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleWorldBonusSpeedStackGained");

	Params::DelMarVehicleStateTagManagerComponent_HandleWorldBonusSpeedStackGained Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleStateTagManagerComponent.HandleWorldBonusSpeedStackLost
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleStateTagManagerComponent::HandleWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleStateTagManagerComponent", "HandleWorldBonusSpeedStackLost");

	Params::DelMarVehicleStateTagManagerComponent_HandleWorldBonusSpeedStackLost Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleAnyWheelsOnGroundChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&Vehicle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWheelsOnGround                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& Vehicle, bool bWheelsOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleAnyWheelsOnGroundChanged");

	Params::DelMarVehicleVerbComponent_HandleAnyWheelsOnGroundChanged Parms{};

	Parms.Vehicle = Vehicle;
	Parms.bWheelsOnGround = bWheelsOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleDraftActivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleDraftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleDraftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleDriftBoostActivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleDriftBoostActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleDriftBoostActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleDriftBoostDeactivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleDriftBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleDriftBoostDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleDriftDeactivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleDriftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleDriftDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleDriftDurationChanged
// (Final, Native, Protected)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleDriftDurationChanged(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleDriftDurationChanged");

	Params::DelMarVehicleVerbComponent_HandleDriftDurationChanged Parms{};

	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleJumpActivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleJumpActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleJumpActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleKickflipped
// (Final, Native, Protected)
// Parameters:
// bool                                    bLeft                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleKickflipped(bool bLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleKickflipped");

	Params::DelMarVehicleVerbComponent_HandleKickflipped Parms{};

	Parms.bLeft = bLeft;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandlePotentialDriftBoostChanged
// (Final, Native, Protected)
// Parameters:
// float                                   Percent                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandlePotentialDriftBoostChanged(float Percent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandlePotentialDriftBoostChanged");

	Params::DelMarVehicleVerbComponent_HandlePotentialDriftBoostChanged Parms{};

	Parms.Percent = Percent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleSpeedometerSpeedChanged
// (Final, Native, Protected)
// Parameters:
// float                                   UpdatedSpeedometerSpeed                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleSpeedometerSpeedChanged(float UpdatedSpeedometerSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleSpeedometerSpeedChanged");

	Params::DelMarVehicleVerbComponent_HandleSpeedometerSpeedChanged Parms{};

	Parms.UpdatedSpeedometerSpeed = UpdatedSpeedometerSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleStartlineBoostActivated
// (Final, Native, Protected)
// Parameters:
// float                                   BoostPercent                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleStartlineBoostActivated(float BoostPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleStartlineBoostActivated");

	Params::DelMarVehicleVerbComponent_HandleStartlineBoostActivated Parms{};

	Parms.BoostPercent = BoostPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleTurboBonusZoneChanged
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   BonusZoneState                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleTurboBonusZoneChanged(EDelMarTurboZoneState BonusZoneState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleTurboBonusZoneChanged");

	Params::DelMarVehicleVerbComponent_HandleTurboBonusZoneChanged Parms{};

	Parms.BonusZoneState = BonusZoneState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleTurboChargeUsed
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleTurboChargeUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleTurboChargeUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleUnderthrustDeactivated
// (Final, Native, Protected)

void UDelMarVehicleVerbComponent::HandleUnderthrustDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleUnderthrustDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleUnderthrustPercentChanged
// (Final, Native, Protected)
// Parameters:
// float                                   PercentageUnderthrustRemaining                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleUnderthrustPercentChanged(float PercentageUnderthrustRemaining)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleUnderthrustPercentChanged");

	Params::DelMarVehicleVerbComponent_HandleUnderthrustPercentChanged Parms{};

	Parms.PercentageUnderthrustRemaining = PercentageUnderthrustRemaining;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleVehicleLanded
// (Final, Native, Protected)
// Parameters:
// float                                   LandingForce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLandedKickflip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleVehicleLanded(float LandingForce, bool bLandedKickflip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleVehicleLanded");

	Params::DelMarVehicleVerbComponent_HandleVehicleLanded Parms{};

	Parms.LandingForce = LandingForce;
	Parms.bLandedKickflip = bLandedKickflip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleWorldBonusSpeedStackGained
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleWorldBonusSpeedStackGained");

	Params::DelMarVehicleVerbComponent_HandleWorldBonusSpeedStackGained Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleVerbComponent.HandleWorldBonusSpeedStackLost
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleVerbComponent::HandleWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleVerbComponent", "HandleWorldBonusSpeedStackLost");

	Params::DelMarVehicleVerbComponent_HandleWorldBonusSpeedStackLost Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAudioComponentGroup.GetMixModifiers
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarAudioMixModifierExtension* ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarAudioMixModifierExtension* UDelMarAudioComponentGroup::GetMixModifiers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioComponentGroup", "GetMixModifiers");

	Params::DelMarAudioComponentGroup_GetMixModifiers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAudioComponentGroup.GetSubmixSends
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarSubmixSendExtension*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarSubmixSendExtension* UDelMarAudioComponentGroup::GetSubmixSends() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioComponentGroup", "GetSubmixSends");

	Params::DelMarAudioComponentGroup_GetSubmixSends Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAudioController.HandleVehicleDemolished
// (Final, Native, Public)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarAudioController::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioController", "HandleVehicleDemolished");

	Params::DelMarAudioController_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAudioController.PlaySound
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USoundBase*                       Sound                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InFadeInTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTargetVolume                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableAttenuation                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EAudioFaderCurve                  InFadeCurve                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* ADelMarAudioController::PlaySound(class USoundBase* Sound, float InFadeInTime, float InTargetVolume, bool bDisableAttenuation, const EAudioFaderCurve InFadeCurve)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioController", "PlaySound");

	Params::DelMarAudioController_PlaySound Parms{};

	Parms.Sound = Sound;
	Parms.InFadeInTime = InFadeInTime;
	Parms.InTargetVolume = InTargetVolume;
	Parms.bDisableAttenuation = bDisableAttenuation;
	Parms.InFadeCurve = InFadeCurve;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAudioController.GetComponentGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarAudioComponentGroup*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarAudioComponentGroup* ADelMarAudioController::GetComponentGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioController", "GetComponentGroup");

	Params::DelMarAudioController_GetComponentGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAudioController.IsVirtualized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarAudioController::IsVirtualized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioController", "IsVirtualized");

	Params::DelMarAudioController_IsVirtualized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarAudioMixModifierExtension.AddMixGroup
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAudioMixModifierGroup&    InMixModifier                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarAudioMixModifierExtension::AddMixGroup(const struct FAudioMixModifierGroup& InMixModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioMixModifierExtension", "AddMixGroup");

	Params::DelMarAudioMixModifierExtension_AddMixGroup Parms{};

	Parms.InMixModifier = std::move(InMixModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAudioMixModifierExtension.RemoveMixGroup
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAudioMixModifierGroup&    InMixModifier                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarAudioMixModifierExtension::RemoveMixGroup(const struct FAudioMixModifierGroup& InMixModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioMixModifierExtension", "RemoveMixGroup");

	Params::DelMarAudioMixModifierExtension_RemoveMixGroup Parms{};

	Parms.InMixModifier = std::move(InMixModifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAudioMixModifierExtension.RemoveMixGroupByName
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// const class FName                       InName                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarAudioMixModifierExtension::RemoveMixGroupByName(const class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAudioMixModifierExtension", "RemoveMixGroupByName");

	Params::DelMarAudioMixModifierExtension_RemoveMixGroupByName Parms{};

	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSubmixSendExtension.RemoveSend
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSubmixBase*                 InSubmix                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSubmixSendExtension::RemoveSend(class USoundSubmixBase* InSubmix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSubmixSendExtension", "RemoveSend");

	Params::DelMarSubmixSendExtension_RemoveSend Parms{};

	Parms.InSubmix = InSubmix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarSubmixSendExtension.SetSend
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class USoundSubmixBase*                 InSubmix                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             InLevel                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bTrackCount                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSubmixSendExtension::SetSend(class USoundSubmixBase* InSubmix, const float InLevel, const bool bTrackCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSubmixSendExtension", "SetSend");

	Params::DelMarSubmixSendExtension_SetSend Parms{};

	Parms.InSubmix = InSubmix;
	Parms.InLevel = InLevel;
	Parms.bTrackCount = bTrackCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarNuxBlueprintFunctionLibrary.GetCurrentLapNumber
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADelMarVehicle*             Vehicle                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarNuxBlueprintFunctionLibrary::GetCurrentLapNumber(const class ADelMarVehicle* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarNuxBlueprintFunctionLibrary", "GetCurrentLapNumber");

	Params::DelMarNuxBlueprintFunctionLibrary_GetCurrentLapNumber Parms{};

	Parms.Vehicle = Vehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarNuxBlueprintFunctionLibrary.GetCurrentRankedInfoForVehicle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class ADelMarVehicle*             Vehicle                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDelMarRankedInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDelMarRankedInfo UDelMarNuxBlueprintFunctionLibrary::GetCurrentRankedInfoForVehicle(const class ADelMarVehicle* Vehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarNuxBlueprintFunctionLibrary", "GetCurrentRankedInfoForVehicle");

	Params::DelMarNuxBlueprintFunctionLibrary_GetCurrentRankedInfoForVehicle Parms{};

	Parms.Vehicle = Vehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.BP_ActivateRift
// (Event, Public, BlueprintEvent)

void ADelMarCheckpoint::BP_ActivateRift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_ActivateRift");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCheckpoint.BP_DeactivateRift
// (Event, Public, BlueprintEvent)

void ADelMarCheckpoint::BP_DeactivateRift()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_DeactivateRift");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCheckpoint.BP_FirstPlaceChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bValidPrevFirstPlace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::BP_FirstPlaceChanged(bool bValidPrevFirstPlace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_FirstPlaceChanged");

	Params::DelMarCheckpoint_BP_FirstPlaceChanged Parms{};

	Parms.bValidPrevFirstPlace = bValidPrevFirstPlace;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCheckpoint.BP_LapFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   CompletedLap                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentLap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalLaps                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::BP_LapFinished(int32 CompletedLap, int32 CurrentLap, int32 TotalLaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_LapFinished");

	Params::DelMarCheckpoint_BP_LapFinished Parms{};

	Parms.CompletedLap = CompletedLap;
	Parms.CurrentLap = CurrentLap;
	Parms.TotalLaps = TotalLaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCheckpoint.BP_RaceFinished
// (Event, Public, BlueprintEvent)

void ADelMarCheckpoint::BP_RaceFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_RaceFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCheckpoint.BP_RaceReset
// (Event, Public, BlueprintEvent)

void ADelMarCheckpoint::BP_RaceReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "BP_RaceReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCheckpoint.ClientSetCheckpointActive
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   CurrentLap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalLaps                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::ClientSetCheckpointActive(int32 CurrentLap, int32 TotalLaps)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "ClientSetCheckpointActive");

	Params::DelMarCheckpoint_ClientSetCheckpointActive Parms{};

	Parms.CurrentLap = CurrentLap;
	Parms.TotalLaps = TotalLaps;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCheckpoint.ClientSetCheckpointInactive
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ADelMarCheckpoint::ClientSetCheckpointInactive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "ClientSetCheckpointInactive");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCheckpoint.HandlePawnEnteredVehicle
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IFortVehicleInterface>&Vehicle                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPawn*                        Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SeatIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::HandlePawnEnteredVehicle(const TScriptInterface<class IFortVehicleInterface>& Vehicle, class AFortPawn* Pawn, int32 SeatIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "HandlePawnEnteredVehicle");

	Params::DelMarCheckpoint_HandlePawnEnteredVehicle Parms{};

	Parms.Vehicle = Vehicle;
	Parms.Pawn = Pawn;
	Parms.SeatIndex = SeatIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheckpoint.OnTriggered
// (Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarVehicle*                   InDelMarVehicle                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::OnTriggered(class ADelMarVehicle* InDelMarVehicle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "OnTriggered");

	Params::DelMarCheckpoint_OnTriggered Parms{};

	Parms.InDelMarVehicle = InDelMarVehicle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheckpoint.UpdateCheckpointMesh
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDelMarCheckpointMeshType               MeshType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCheckpoint::UpdateCheckpointMesh(EDelMarCheckpointMeshType MeshType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "UpdateCheckpointMesh");

	Params::DelMarCheckpoint_UpdateCheckpointMesh Parms{};

	Parms.MeshType = MeshType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCheckpoint.GetCheckpointMeshType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarCheckpointMeshType               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarCheckpointMeshType ADelMarCheckpoint::GetCheckpointMeshType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetCheckpointMeshType");

	Params::DelMarCheckpoint_GetCheckpointMeshType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.GetFurthestAheadTrackDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCheckpointTrackDistance   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FCheckpointTrackDistance ADelMarCheckpoint::GetFurthestAheadTrackDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetFurthestAheadTrackDistance");

	Params::DelMarCheckpoint_GetFurthestAheadTrackDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.GetFurthestBehindTrackDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCheckpointTrackDistance   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FCheckpointTrackDistance ADelMarCheckpoint::GetFurthestBehindTrackDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetFurthestBehindTrackDistance");

	Params::DelMarCheckpoint_GetFurthestBehindTrackDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.GetNearestTrackData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FCheckpointTrackDistance   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FCheckpointTrackDistance ADelMarCheckpoint::GetNearestTrackData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetNearestTrackData");

	Params::DelMarCheckpoint_GetNearestTrackData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.GetSpawnTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ADelMarCheckpoint::GetSpawnTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetSpawnTransform");

	Params::DelMarCheckpoint_GetSpawnTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.GetTrackDistanceDataForTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADelMarTrackBase*           InTrack                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bEnsureAssociated                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCheckpointTrackDistance   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FCheckpointTrackDistance ADelMarCheckpoint::GetTrackDistanceDataForTrack(const class ADelMarTrackBase* InTrack, const bool bEnsureAssociated) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "GetTrackDistanceDataForTrack");

	Params::DelMarCheckpoint_GetTrackDistanceDataForTrack Parms{};

	Parms.InTrack = InTrack;
	Parms.bEnsureAssociated = bEnsureAssociated;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCheckpoint.IsAssociatedWithTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ADelMarTrackBase*           InTrack                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarCheckpoint::IsAssociatedWithTrack(const class ADelMarTrackBase* InTrack) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpoint", "IsAssociatedWithTrack");

	Params::DelMarCheckpoint_IsAssociatedWithTrack Parms{};

	Parms.InTrack = InTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.AreAllLeaderboardFiltersEnabled
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarBlueprintLibrary::AreAllLeaderboardFiltersEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "AreAllLeaderboardFiltersEnabled");

	Params::DelMarBlueprintLibrary_AreAllLeaderboardFiltersEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.BP_KillAndRespawnVehicle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AController*                Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarBlueprintLibrary::BP_KillAndRespawnVehicle(const class AController* Controller, const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "BP_KillAndRespawnVehicle");

	Params::DelMarBlueprintLibrary_BP_KillAndRespawnVehicle Parms{};

	Parms.Controller = Controller;
	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.DelMarFormatTime
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const double                            TimeSeconds                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIncludeMilliseconds                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDelMarBlueprintLibrary::DelMarFormatTime(const double TimeSeconds, const bool bIncludeMilliseconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "DelMarFormatTime");

	Params::DelMarBlueprintLibrary_DelMarFormatTime Parms{};

	Parms.TimeSeconds = TimeSeconds;
	Parms.bIncludeMilliseconds = bIncludeMilliseconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetClientWorldTimeSeconds
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarBlueprintLibrary::GetClientWorldTimeSeconds(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetClientWorldTimeSeconds");

	Params::DelMarBlueprintLibrary_GetClientWorldTimeSeconds Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetDelMarPlayspace
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarPlayspace*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarPlayspace* UDelMarBlueprintLibrary::GetDelMarPlayspace(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetDelMarPlayspace");

	Params::DelMarBlueprintLibrary_GetDelMarPlayspace Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetDelMarVehicle
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarVehicle*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarVehicle* UDelMarBlueprintLibrary::GetDelMarVehicle(const class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetDelMarVehicle");

	Params::DelMarBlueprintLibrary_GetDelMarVehicle Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetNetModel
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarNetModel                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarNetModel UDelMarBlueprintLibrary::GetNetModel(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetNetModel");

	Params::DelMarBlueprintLibrary_GetNetModel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetPrimaryPlayerController
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPlayerController*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFortPlayerController* UDelMarBlueprintLibrary::GetPrimaryPlayerController(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetPrimaryPlayerController");

	Params::DelMarBlueprintLibrary_GetPrimaryPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetPrimaryPlayerState
// (Final, RequiredAPI, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortPlayerState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFortPlayerState* UDelMarBlueprintLibrary::GetPrimaryPlayerState(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetPrimaryPlayerState");

	Params::DelMarBlueprintLibrary_GetPrimaryPlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.GetTimerDeltaFromServerTime
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const double                            TimestampSeconds                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const EDelMarTimerDirection             Direction                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bCapAtZero                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsPositive                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarBlueprintLibrary::GetTimerDeltaFromServerTime(const double TimestampSeconds, const EDelMarTimerDirection Direction, const bool bCapAtZero, bool* bIsPositive, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "GetTimerDeltaFromServerTime");

	Params::DelMarBlueprintLibrary_GetTimerDeltaFromServerTime Parms{};

	Parms.TimestampSeconds = TimestampSeconds;
	Parms.Direction = Direction;
	Parms.bCapAtZero = bCapAtZero;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsPositive != nullptr)
		*bIsPositive = Parms.bIsPositive;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.IsDelMarExperience
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    bEnableCaching                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarBlueprintLibrary::IsDelMarExperience(bool bEnableCaching)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "IsDelMarExperience");

	Params::DelMarBlueprintLibrary_IsDelMarExperience Parms{};

	Parms.bEnableCaching = bEnableCaching;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.IsDelMarGFSActive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarBlueprintLibrary::IsDelMarGFSActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "IsDelMarGFSActive");

	Params::DelMarBlueprintLibrary_IsDelMarGFSActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.IsDelMarPlaylist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ContextObject                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarBlueprintLibrary::IsDelMarPlaylist(class UObject* ContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "IsDelMarPlaylist");

	Params::DelMarBlueprintLibrary_IsDelMarPlaylist Parms{};

	Parms.ContextObject = ContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarBlueprintLibrary.SetDelMarControlsText
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDelMarEvent_SetControlsText&Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarBlueprintLibrary::SetDelMarControlsText(const class APlayerController* PlayerController, const struct FDelMarEvent_SetControlsText& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "SetDelMarControlsText");

	Params::DelMarBlueprintLibrary_SetDelMarControlsText Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarBlueprintLibrary.SetDelMarTutorialHint
// (Final, RequiredAPI, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class APlayerController*          PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDelMarEvent_SetTutorialHint&Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarBlueprintLibrary::SetDelMarTutorialHint(const class APlayerController* PlayerController, const struct FDelMarEvent_SetTutorialHint& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarBlueprintLibrary", "SetDelMarTutorialHint");

	Params::DelMarBlueprintLibrary_SetDelMarTutorialHint Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarCancelMissedCheckpointDemoCountdown
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarCancelMissedCheckpointDemoCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarCancelMissedCheckpointDemoCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarCancelReturnToTrackDemoCountdown
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarCancelReturnToTrackDemoCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarCancelReturnToTrackDemoCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarClearActiveAutoInput
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarClearActiveAutoInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarClearActiveAutoInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarClearQueuedAutoInput
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarClearQueuedAutoInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarClearQueuedAutoInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarDemolishSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarDemolishSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarDemolishSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarDemolishSelfWithTag
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const class FString&                    DemolishTagString                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarDemolishSelfWithTag(const class FString& DemolishTagString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarDemolishSelfWithTag");

	Params::DelMarCheatManager_DelMarDemolishSelfWithTag Parms{};

	Parms.DemolishTagString = std::move(DemolishTagString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarEndSpectate
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarEndSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarEndSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarExitVehicle
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarExitVehicle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarExitVehicle");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarFetchFocusedLeaderboard
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarFetchFocusedLeaderboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarFetchFocusedLeaderboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarFetchFriendsLeaderboard
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarFetchFriendsLeaderboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarFetchFriendsLeaderboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarFetchGlobalLeaderboard
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarFetchGlobalLeaderboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarFetchGlobalLeaderboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarFinishRace
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarFinishRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarFinishRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarFinishRaceSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarFinishRaceSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarFinishRaceSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarForceEveryoneToReadyUp
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarForceEveryoneToReadyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarForceEveryoneToReadyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarForceLoadLevel
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    LevelName                                              (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarForceLoadLevel(const class FString& LevelName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarForceLoadLevel");

	Params::DelMarCheatManager_DelMarForceLoadLevel Parms{};

	Parms.LevelName = std::move(LevelName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarForceLoadUEFNIsland
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    IslandCode                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarForceLoadUEFNIsland(const class FString& IslandCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarForceLoadUEFNIsland");

	Params::DelMarCheatManager_DelMarForceLoadUEFNIsland Parms{};

	Parms.IslandCode = std::move(IslandCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostClearPlaybackFile
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarGhostClearPlaybackFile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostClearPlaybackFile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostForcePlayAllTriggers
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarGhostForcePlayAllTriggers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostForcePlayAllTriggers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostSetRecordOffPhysics
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGhostSetRecordOffPhysics(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostSetRecordOffPhysics");

	Params::DelMarCheatManager_DelMarGhostSetRecordOffPhysics Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostSetReplayEnabled
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGhostSetReplayEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostSetReplayEnabled");

	Params::DelMarCheatManager_DelMarGhostSetReplayEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostStartPlayerPlayback
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarGhostStartPlayerPlayback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostStartPlayerPlayback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostStartPlayerRecording
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    SaveFileName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSaveToFile                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGhostStartPlayerRecording(const class FString& SaveFileName, bool bSaveToFile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostStartPlayerRecording");

	Params::DelMarCheatManager_DelMarGhostStartPlayerRecording Parms{};

	Parms.SaveFileName = std::move(SaveFileName);
	Parms.bSaveToFile = bSaveToFile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGhostStopPlayerRecording
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarGhostStopPlayerRecording()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGhostStopPlayerRecording");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGiveSelfSomeCompetitiveMMRStats
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const int32                             MyPosition                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             TotalNumberOfPlayers                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             NumberOfTimesToSendMMRUpdate                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGiveSelfSomeCompetitiveMMRStats(const int32 MyPosition, const int32 TotalNumberOfPlayers, const int32 NumberOfTimesToSendMMRUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGiveSelfSomeCompetitiveMMRStats");

	Params::DelMarCheatManager_DelMarGiveSelfSomeCompetitiveMMRStats Parms{};

	Parms.MyPosition = MyPosition;
	Parms.TotalNumberOfPlayers = TotalNumberOfPlayers;
	Parms.NumberOfTimesToSendMMRUpdate = NumberOfTimesToSendMMRUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGrantQuestsInDir
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    Dir                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGrantQuestsInDir(const class FString& Dir)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGrantQuestsInDir");

	Params::DelMarCheatManager_DelMarGrantQuestsInDir Parms{};

	Parms.Dir = std::move(Dir);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarGrantTurboCharges
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const float                             Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bGrantToEveryone                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarGrantTurboCharges(const float Amount, const bool bGrantToEveryone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarGrantTurboCharges");

	Params::DelMarCheatManager_DelMarGrantTurboCharges Parms{};

	Parms.Amount = Amount;
	Parms.bGrantToEveryone = bGrantToEveryone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarInitiateMissedCheckpointDemoCountdown
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   SecondsUntilDemo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarInitiateMissedCheckpointDemoCountdown(float SecondsUntilDemo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarInitiateMissedCheckpointDemoCountdown");

	Params::DelMarCheatManager_DelMarInitiateMissedCheckpointDemoCountdown Parms{};

	Parms.SecondsUntilDemo = SecondsUntilDemo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarInitiateReturnToTrackDemoCountdown
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   SecondsUntilDemo                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarInitiateReturnToTrackDemoCountdown(float SecondsUntilDemo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarInitiateReturnToTrackDemoCountdown");

	Params::DelMarCheatManager_DelMarInitiateReturnToTrackDemoCountdown Parms{};

	Parms.SecondsUntilDemo = SecondsUntilDemo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarNextTutorialSection
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarNextTutorialSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarNextTutorialSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarPauseAllBots
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarPauseAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarPauseAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarPrevTutorialSection
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarPrevTutorialSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarPrevTutorialSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarPrintLogsToDiagnoseSpinout
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarPrintLogsToDiagnoseSpinout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarPrintLogsToDiagnoseSpinout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarPrintQuestProgress
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarPrintQuestProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarPrintQuestProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarQueueAutoInputDriveThenTurn
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   Repeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Throttle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StraightDuration                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Steer                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurnDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarQueueAutoInputDriveThenTurn(int32 Repeat, float Throttle, float StraightDuration, float Steer, float TurnDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarQueueAutoInputDriveThenTurn");

	Params::DelMarCheatManager_DelMarQueueAutoInputDriveThenTurn Parms{};

	Parms.Repeat = Repeat;
	Parms.Throttle = Throttle;
	Parms.StraightDuration = StraightDuration;
	Parms.Steer = Steer;
	Parms.TurnDuration = TurnDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarQueueAutoInputJump
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   Repeat                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarQueueAutoInputJump(int32 Repeat, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarQueueAutoInputJump");

	Params::DelMarCheatManager_DelMarQueueAutoInputJump Parms{};

	Parms.Repeat = Repeat;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarQueueAutoInputThrottle
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Throttle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarQueueAutoInputThrottle(float Throttle, float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarQueueAutoInputThrottle");

	Params::DelMarCheatManager_DelMarQueueAutoInputThrottle Parms{};

	Parms.Throttle = Throttle;
	Parms.duration = duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRemoveAllBots
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarRemoveAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRemoveAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRemoveBotByName
// (Final, Exec, Native, Protected, HasOutParams)
// Parameters:
// class FString*                          BotName                                                (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarRemoveBotByName(class FString* BotName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRemoveBotByName");

	Params::DelMarCheatManager_DelMarRemoveBotByName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (BotName != nullptr)
		*BotName = std::move(Parms.BotName);
}


// Function DelMarCore.DelMarCheatManager.DelMarRemoveNumberOfBots
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   NumberOfBotsToRemove                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarRemoveNumberOfBots(int32 NumberOfBotsToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRemoveNumberOfBots");

	Params::DelMarCheatManager_DelMarRemoveNumberOfBots Parms{};

	Parms.NumberOfBotsToRemove = NumberOfBotsToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRenamePlayers
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarRenamePlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRenamePlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarResetPreRaceViewTarget
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarResetPreRaceViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarResetPreRaceViewTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarResetRace
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarResetRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarResetRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarResetTutorialSplines
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarResetTutorialSplines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarResetTutorialSplines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRespawnAtLastCheckpoint
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarRespawnAtLastCheckpoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRespawnAtLastCheckpoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRespawnAtLastCheckpoint_ParallelPath
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarRespawnAtLastCheckpoint_ParallelPath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRespawnAtLastCheckpoint_ParallelPath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarRespawnPointLocked
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bLocked                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarRespawnPointLocked(bool bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarRespawnPointLocked");

	Params::DelMarCheatManager_DelMarRespawnPointLocked Parms{};

	Parms.bLocked = bLocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarResumeAllBots
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarResumeAllBots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarResumeAllBots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarReturnToLobby
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarReturnToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarReturnToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetAirFreestyleEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetAirFreestyleEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetAirFreestyleEnabled");

	Params::DelMarCheatManager_DelMarSetAirFreestyleEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetCollisionDemosEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetCollisionDemosEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetCollisionDemosEnabled");

	Params::DelMarCheatManager_DelMarSetCollisionDemosEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetDemoModeEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetDemoModeEnabled(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetDemoModeEnabled");

	Params::DelMarCheatManager_DelMarSetDemoModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetDraftingEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetDraftingEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetDraftingEnabled");

	Params::DelMarCheatManager_DelMarSetDraftingEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetGlobalInputEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const class FString&                    InputTag                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bEnableInput                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetGlobalInputEnabled(const class FString& InputTag, const bool bEnableInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetGlobalInputEnabled");

	Params::DelMarCheatManager_DelMarSetGlobalInputEnabled Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bEnableInput = bEnableInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetInfiniteUnderthrustEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetInfiniteUnderthrustEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetInfiniteUnderthrustEnabled");

	Params::DelMarCheatManager_DelMarSetInfiniteUnderthrustEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetInputMappingContextEnabled
// (Final, Exec, Native, Protected)
// Parameters:
// const class FString&                    InputTag                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bEnableInput                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetInputMappingContextEnabled(const class FString& InputTag, const bool bEnableInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetInputMappingContextEnabled");

	Params::DelMarCheatManager_DelMarSetInputMappingContextEnabled Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bEnableInput = bEnableInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetInvertSteerMethod
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// EDelMarInvertSteerMethod                InInvertSteerMethod                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetInvertSteerMethod(EDelMarInvertSteerMethod InInvertSteerMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetInvertSteerMethod");

	Params::DelMarCheatManager_DelMarSetInvertSteerMethod Parms{};

	Parms.InInvertSteerMethod = InInvertSteerMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetLap
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// int32                                   LapNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetLap(int32 LapNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetLap");

	Params::DelMarCheatManager_DelMarSetLap Parms{};

	Parms.LapNum = LapNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetLapTotal
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// int32                                   NewTotal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetLapTotal(int32 NewTotal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetLapTotal");

	Params::DelMarCheatManager_DelMarSetLapTotal Parms{};

	Parms.NewTotal = NewTotal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetLoadingScreenVisibility
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bShouldBeVisible                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetLoadingScreenVisibility(bool bShouldBeVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetLoadingScreenVisibility");

	Params::DelMarCheatManager_DelMarSetLoadingScreenVisibility Parms{};

	Parms.bShouldBeVisible = bShouldBeVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetReplicatedTagEnabledOnSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const class FString&                    InputTag                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetReplicatedTagEnabledOnSelf(const class FString& InputTag, const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetReplicatedTagEnabledOnSelf");

	Params::DelMarCheatManager_DelMarSetReplicatedTagEnabledOnSelf Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRespawnCollisionProtectionEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRespawnCollisionProtectionEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRespawnCollisionProtectionEnabled");

	Params::DelMarCheatManager_DelMarSetRespawnCollisionProtectionEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRespawnCollisionProtectionSeconds
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRespawnCollisionProtectionSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRespawnCollisionProtectionSeconds");

	Params::DelMarCheatManager_DelMarSetRespawnCollisionProtectionSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRespawnInvulnerabilityEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRespawnInvulnerabilityEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRespawnInvulnerabilityEnabled");

	Params::DelMarCheatManager_DelMarSetRespawnInvulnerabilityEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRespawnInvulnerabilitySeconds
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRespawnInvulnerabilitySeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRespawnInvulnerabilitySeconds");

	Params::DelMarCheatManager_DelMarSetRespawnInvulnerabilitySeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRespawnTracesEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRespawnTracesEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRespawnTracesEnabled");

	Params::DelMarCheatManager_DelMarSetRespawnTracesEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingEnabled");

	Params::DelMarCheatManager_DelMarSetRubberbandingEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMaxBonusSpeedScalar
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMaxBonusSpeedScalar                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMaxBonusSpeedScalar(float InMaxBonusSpeedScalar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMaxBonusSpeedScalar");

	Params::DelMarCheatManager_DelMarSetRubberbandingMaxBonusSpeedScalar Parms{};

	Parms.InMaxBonusSpeedScalar = InMaxBonusSpeedScalar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMaxDistanceFromPack
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMaxDistanceFromPack                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMaxDistanceFromPack(float InMaxDistanceFromPack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMaxDistanceFromPack");

	Params::DelMarCheatManager_DelMarSetRubberbandingMaxDistanceFromPack Parms{};

	Parms.InMaxDistanceFromPack = InMaxDistanceFromPack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMaxPackDistance
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMaxPackDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMaxPackDistance(float InMaxPackDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMaxPackDistance");

	Params::DelMarCheatManager_DelMarSetRubberbandingMaxPackDistance Parms{};

	Parms.InMaxPackDistance = InMaxPackDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMaxPackDistanceGainedPerSecond
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMaxPackDistanceGainedPerSecond                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMaxPackDistanceGainedPerSecond(float InMaxPackDistanceGainedPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMaxPackDistanceGainedPerSecond");

	Params::DelMarCheatManager_DelMarSetRubberbandingMaxPackDistanceGainedPerSecond Parms{};

	Parms.InMaxPackDistanceGainedPerSecond = InMaxPackDistanceGainedPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMaxPackDistanceLostPerSecond
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMaxPackDistanceLostPerSecond                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMaxPackDistanceLostPerSecond(float InMaxPackDistanceLostPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMaxPackDistanceLostPerSecond");

	Params::DelMarCheatManager_DelMarSetRubberbandingMaxPackDistanceLostPerSecond Parms{};

	Parms.InMaxPackDistanceLostPerSecond = InMaxPackDistanceLostPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMinDistanceFromPack
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMinDistanceFromPack                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMinDistanceFromPack(float InMinDistanceFromPack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMinDistanceFromPack");

	Params::DelMarCheatManager_DelMarSetRubberbandingMinDistanceFromPack Parms{};

	Parms.InMinDistanceFromPack = InMinDistanceFromPack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMinPackDistance
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   InMinPackDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMinPackDistance(float InMinPackDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMinPackDistance");

	Params::DelMarCheatManager_DelMarSetRubberbandingMinPackDistance Parms{};

	Parms.InMinPackDistance = InMinPackDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingMMR
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// int32                                   InMMR                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingMMR(int32 InMMR)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingMMR");

	Params::DelMarCheatManager_DelMarSetRubberbandingMMR Parms{};

	Parms.InMMR = InMMR;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetRubberbandingNumPlayersForPackDistance
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// int32                                   InNumPlayersForPackDistance                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetRubberbandingNumPlayersForPackDistance(int32 InNumPlayersForPackDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetRubberbandingNumPlayersForPackDistance");

	Params::DelMarCheatManager_DelMarSetRubberbandingNumPlayersForPackDistance Parms{};

	Parms.InNumPlayersForPackDistance = InNumPlayersForPackDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetSpawnMode
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// EDelMarRaceSpawnMode                    SpawnMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetSpawnMode(EDelMarRaceSpawnMode SpawnMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetSpawnMode");

	Params::DelMarCheatManager_DelMarSetSpawnMode Parms{};

	Parms.SpawnMode = SpawnMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetStartlineBoostEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetStartlineBoostEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetStartlineBoostEnabled");

	Params::DelMarCheatManager_DelMarSetStartlineBoostEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetStartlineBoostPotentialOverride
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// float                                   PotentialOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetStartlineBoostPotentialOverride(float PotentialOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetStartlineBoostPotentialOverride");

	Params::DelMarCheatManager_DelMarSetStartlineBoostPotentialOverride Parms{};

	Parms.PotentialOverride = PotentialOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetStrafeEnabled
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetStrafeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetStrafeEnabled");

	Params::DelMarCheatManager_DelMarSetStrafeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetTurboCharges
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const float                             Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bGrantToEveryone                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetTurboCharges(const float Amount, const bool bGrantToEveryone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetTurboCharges");

	Params::DelMarCheatManager_DelMarSetTurboCharges Parms{};

	Parms.Amount = Amount;
	Parms.bGrantToEveryone = bGrantToEveryone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetTutorialSection
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetTutorialSection(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetTutorialSection");

	Params::DelMarCheatManager_DelMarSetTutorialSection Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetVehicleCollisionsOverrideForSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// EDelMarVehicleCollisionOverrideSetting  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetVehicleCollisionsOverrideForSelf(EDelMarVehicleCollisionOverrideSetting NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetVehicleCollisionsOverrideForSelf");

	Params::DelMarCheatManager_DelMarSetVehicleCollisionsOverrideForSelf Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetVehicleCollisionsOverrideGlobal
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// EDelMarVehicleCollisionOverrideSetting  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetVehicleCollisionsOverrideGlobal(EDelMarVehicleCollisionOverrideSetting NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetVehicleCollisionsOverrideGlobal");

	Params::DelMarCheatManager_DelMarSetVehicleCollisionsOverrideGlobal Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSetVerticalKickflipInverted
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// bool                                    InbVerticalKickflipInverted                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSetVerticalKickflipInverted(bool InbVerticalKickflipInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSetVerticalKickflipInverted");

	Params::DelMarCheatManager_DelMarSetVerticalKickflipInverted Parms{};

	Parms.InbVerticalKickflipInverted = InbVerticalKickflipInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSkipWaitingForPlayers
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarSkipWaitingForPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSkipWaitingForPlayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSpawnBots
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   NumberOfBotsToSpawn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSpawnBots(int32 NumberOfBotsToSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSpawnBots");

	Params::DelMarCheatManager_DelMarSpawnBots Parms{};

	Parms.NumberOfBotsToSpawn = NumberOfBotsToSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSpawnBotsAtSkillLevel
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   NumberOfBotsToSpawn                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SkillLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarSpawnBotsAtSkillLevel(int32 NumberOfBotsToSpawn, int32 SkillLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSpawnBotsAtSkillLevel");

	Params::DelMarCheatManager_DelMarSpawnBotsAtSkillLevel Parms{};

	Parms.NumberOfBotsToSpawn = NumberOfBotsToSpawn;
	Parms.SkillLevel = SkillLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSpawnVehicleForSelf
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarSpawnVehicleForSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSpawnVehicleForSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarSpectate
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarSpectate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarSpectate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarStartFollowTrack
// (Final, Exec, Native, Protected)
// Parameters:
// float                                   Throttle                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarStartFollowTrack(float Throttle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarStartFollowTrack");

	Params::DelMarCheatManager_DelMarStartFollowTrack Parms{};

	Parms.Throttle = Throttle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarStartQueuedAutoInput
// (Final, Exec, Native, Protected)

void UDelMarCheatManager::DelMarStartQueuedAutoInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarStartQueuedAutoInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarStartRace
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)

void UDelMarCheatManager::DelMarStartRace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarStartRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarTeleportToNextCheckpoint_ParallelPath
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const int32                             ParallelPathIndex                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarTeleportToNextCheckpoint_ParallelPath(const int32 ParallelPathIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarTeleportToNextCheckpoint_ParallelPath");

	Params::DelMarCheatManager_DelMarTeleportToNextCheckpoint_ParallelPath Parms{};

	Parms.ParallelPathIndex = ParallelPathIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarTeleportToPreviousCheckpoint_ParallelPath
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected)
// Parameters:
// const int32                             ParallelPathIndex                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarTeleportToPreviousCheckpoint_ParallelPath(const int32 ParallelPathIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarTeleportToPreviousCheckpoint_ParallelPath");

	Params::DelMarCheatManager_DelMarTeleportToPreviousCheckpoint_ParallelPath Parms{};

	Parms.ParallelPathIndex = ParallelPathIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarUsePredictiveInterpolation
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEveryOther                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarUsePredictiveInterpolation(bool bEnabled, bool bEveryOther)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarUsePredictiveInterpolation");

	Params::DelMarCheatManager_DelMarUsePredictiveInterpolation Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bEveryOther = bEveryOther;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.BugIt
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected, Const)
// Parameters:
// const class FString&                    BugName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::BugIt(const class FString& BugName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "BugIt");

	Params::DelMarCheatManager_BugIt Parms{};

	Parms.BugName = std::move(BugName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.BugItGo
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected, Const)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::BugItGo(float X, float Y, float Z, float pitch, float Yaw, float Roll) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "BugItGo");

	Params::DelMarCheatManager_BugItGo Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.pitch = pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarCreateTrackScrubberForProfiling
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected, Const)

void UDelMarCheatManager::DelMarCreateTrackScrubberForProfiling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarCreateTrackScrubberForProfiling");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarDestroyTrackScrubbers
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected, Const)

void UDelMarCheatManager::DelMarDestroyTrackScrubbers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarDestroyTrackScrubbers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheatManager.DelMarStartTrackScrubberWithViewTarget
// (Final, BlueprintAuthorityOnly, Exec, Native, Protected, Const)
// Parameters:
// bool                                    bRunCsvProfilerDuringScrub                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheatManager::DelMarStartTrackScrubberWithViewTarget(bool bRunCsvProfilerDuringScrub) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheatManager", "DelMarStartTrackScrubberWithViewTarget");

	Params::DelMarCheatManager_DelMarStartTrackScrubberWithViewTarget Parms{};

	Parms.bRunCsvProfilerDuringScrub = bRunCsvProfilerDuringScrub;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarStateSequencerFXComponent.HandleCurrentStateChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              NewState                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStateSequencerFXComponent::HandleCurrentStateChanged(const struct FGameplayTag& NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateSequencerFXComponent", "HandleCurrentStateChanged");

	Params::DelMarStateSequencerFXComponent_HandleCurrentStateChanged Parms{};

	Parms.NewState = std::move(NewState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarStateSequencerFXComponent.HandleEnabledChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStateSequencerFXComponent::HandleEnabledChanged(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStateSequencerFXComponent", "HandleEnabledChanged");

	Params::DelMarStateSequencerFXComponent_HandleEnabledChanged Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.OnRep_bIsEnabled
// (Final, Native, Protected)

void ADelMarTimeDelayedStateSequencer::OnRep_bIsEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "OnRep_bIsEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.OnRep_CurrentStateIndex
// (Final, Native, Protected)

void ADelMarTimeDelayedStateSequencer::OnRep_CurrentStateIndex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "OnRep_CurrentStateIndex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.SetEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bEnabled                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTimeDelayedStateSequencer::SetEnabled(const bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "SetEnabled");

	Params::DelMarTimeDelayedStateSequencer_SetEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.GetCurrentStateTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADelMarTimeDelayedStateSequencer::GetCurrentStateTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "GetCurrentStateTag");

	Params::DelMarTimeDelayedStateSequencer_GetCurrentStateTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.GetStateCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTimeDelayedStateSequencer::GetStateCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "GetStateCount");

	Params::DelMarTimeDelayedStateSequencer_GetStateCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarTimeDelayedStateSequencer.GetStateTagAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             Index_0                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ADelMarTimeDelayedStateSequencer::GetStateTagAtIndex(const int32 Index_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTimeDelayedStateSequencer", "GetStateTagAtIndex");

	Params::DelMarTimeDelayedStateSequencer_GetStateTagAtIndex Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarGhostVehicle.HandleVehicleCosmeticsFinished
// (Final, Native, Protected)

void ADelMarGhostVehicle::HandleVehicleCosmeticsFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGhostVehicle", "HandleVehicleCosmeticsFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarGlobalInputDisabler.SetGlobalInputsEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InputTags                                              (Parm, NativeAccessSpecifierPublic)
// const bool                              bEnable                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarGlobalInputDisabler::SetGlobalInputsEnabled(const struct FGameplayTagContainer& InputTags, const bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGlobalInputDisabler", "SetGlobalInputsEnabled");

	Params::DelMarGlobalInputDisabler_SetGlobalInputsEnabled Parms{};

	Parms.InputTags = std::move(InputTags);
	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCosmeticActor.ApplyCosmetic
// (Native, Public)

void ADelMarCosmeticActor::ApplyCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "ApplyCosmetic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnAnyWheelsOnGroundChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnAnyWheelsOnGroundChanged");

	Params::DelMarCosmeticActor_BP_OnAnyWheelsOnGroundChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnBonusSpeedActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnBonusSpeedActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnBonusSpeedActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnBonusSpeedChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   BonusSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnBonusSpeedChanged(float BonusSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnBonusSpeedChanged");

	Params::DelMarCosmeticActor_BP_OnBonusSpeedChanged Parms{};

	Parms.BonusSpeed = BonusSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnBonusSpeedDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnBonusSpeedDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnBonusSpeedDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnCosmeticApplied
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnCosmeticApplied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnCosmeticApplied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDelMarAppliedTeleportRotation
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDelMarAppliedTeleportRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDelMarAppliedTeleportRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDelMarTeleportEntered
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDelMarTeleportEntered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDelMarTeleportEntered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDelMarTeleportExited
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDelMarTeleportExited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDelMarTeleportExited");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDelMarVehicleSpawned
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bFirstVehicleForPlayer                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPrevVehicleDemolished                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnDelMarVehicleSpawned(bool bFirstVehicleForPlayer, bool bPrevVehicleDemolished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDelMarVehicleSpawned");

	Params::DelMarCosmeticActor_BP_OnDelMarVehicleSpawned Parms{};

	Parms.bFirstVehicleForPlayer = bFirstVehicleForPlayer;
	Parms.bPrevVehicleDemolished = bPrevVehicleDemolished;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDraftStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDelmarDraftingState                    CurrentState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnDraftStateChanged(EDelmarDraftingState CurrentState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDraftStateChanged");

	Params::DelMarCosmeticActor_BP_OnDraftStateChanged Parms{};

	Parms.CurrentState = CurrentState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDriftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftBoostActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDriftBoostActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftBoostActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftBoostDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDriftBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftBoostDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftControlChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bIsDriftingControlled                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnDriftControlChanged(bool bIsDriftingControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftControlChanged");

	Params::DelMarCosmeticActor_BP_OnDriftControlChanged Parms{};

	Parms.bIsDriftingControlled = bIsDriftingControlled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDriftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftDurationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnDriftDurationChanged(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftDurationChanged");

	Params::DelMarCosmeticActor_BP_OnDriftDurationChanged Parms{};

	Parms.duration = duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftKickActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DriftDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarVehicleDriftState                DriftState                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnDriftKickActivated(float DriftDirection, EDelMarVehicleDriftState DriftState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftKickActivated");

	Params::DelMarCosmeticActor_BP_OnDriftKickActivated Parms{};

	Parms.DriftDirection = DriftDirection;
	Parms.DriftState = DriftState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnDriftKickDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnDriftKickDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnDriftKickDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnInvulnerabilityActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnInvulnerabilityActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnInvulnerabilityActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnInvulnerabilityDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnInvulnerabilityDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnInvulnerabilityDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnJumpActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnJumpActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnJumpActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnJumpDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnJumpDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnJumpDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bLeftSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnKickflipActivated(bool bLeftSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipActivated");

	Params::DelMarCosmeticActor_BP_OnKickflipActivated Parms{};

	Parms.bLeftSide = bLeftSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipActivationChargesChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// int32                                   ActivationCharges                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnKickflipActivationChargesChanged(int32 ActivationCharges)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipActivationChargesChanged");

	Params::DelMarCosmeticActor_BP_OnKickflipActivationChargesChanged Parms{};

	Parms.ActivationCharges = ActivationCharges;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnKickflipDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipDistanceToSuctionSurfaceChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Distance                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnKickflipDistanceToSuctionSurfaceChanged(float Distance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipDistanceToSuctionSurfaceChanged");

	Params::DelMarCosmeticActor_BP_OnKickflipDistanceToSuctionSurfaceChanged Parms{};

	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipDurationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnKickflipDurationChanged(float duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipDurationChanged");

	Params::DelMarCosmeticActor_BP_OnKickflipDurationChanged Parms{};

	Parms.duration = duration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipSuctionActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnKickflipSuctionActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipSuctionActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnKickflipSuctionDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnKickflipSuctionDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnKickflipSuctionDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnReachedMaxDraftBonusSpeed
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnReachedMaxDraftBonusSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnReachedMaxDraftBonusSpeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnReattachmentActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnReattachmentActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnReattachmentActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnReattachmentDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnReattachmentDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnReattachmentDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStartlineBoostActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   PercentageMaxBonusSpeedEarned                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnStartlineBoostActivated(float PercentageMaxBonusSpeedEarned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStartlineBoostActivated");

	Params::DelMarCosmeticActor_BP_OnStartlineBoostActivated Parms{};

	Parms.PercentageMaxBonusSpeedEarned = PercentageMaxBonusSpeedEarned;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStartlineBoostDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnStartlineBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStartlineBoostDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStartlineBoostFailed
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnStartlineBoostFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStartlineBoostFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStrafeActivated
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bLeftSide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnStrafeActivated(bool bLeftSide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStrafeActivated");

	Params::DelMarCosmeticActor_BP_OnStrafeActivated Parms{};

	Parms.bLeftSide = bLeftSide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStrafeCooldownChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   CooldownPercentage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnStrafeCooldownChanged(float CooldownPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStrafeCooldownChanged");

	Params::DelMarCosmeticActor_BP_OnStrafeCooldownChanged Parms{};

	Parms.CooldownPercentage = CooldownPercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStrafeDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnStrafeDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStrafeDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStrafeDisabledChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bDisabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnStrafeDisabledChanged(bool bDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStrafeDisabledChanged");

	Params::DelMarCosmeticActor_BP_OnStrafeDisabledChanged Parms{};

	Parms.bDisabled = bDisabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnStrafeUsabilityChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bCanActivate                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnStrafeUsabilityChanged(bool bCanActivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnStrafeUsabilityChanged");

	Params::DelMarCosmeticActor_BP_OnStrafeUsabilityChanged Parms{};

	Parms.bCanActivate = bCanActivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnTurboActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnTurboActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnTurboActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnTurboBonusStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDelMarTurboZoneState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnTurboBonusStateChanged(EDelMarTurboZoneState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnTurboBonusStateChanged");

	Params::DelMarCosmeticActor_BP_OnTurboBonusStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnTurboDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnTurboDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnTurboDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnUnderthrustActivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnUnderthrustActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnUnderthrustActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnUnderthrustDeactivated
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnUnderthrustDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnUnderthrustDeactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleDemolished
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleDemolished");

	Params::DelMarCosmeticActor_BP_OnVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleForwardStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// EDelMarVehicleForwardState              NewForwardState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnVehicleForwardStateChanged(EDelMarVehicleForwardState NewForwardState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleForwardStateChanged");

	Params::DelMarCosmeticActor_BP_OnVehicleForwardStateChanged Parms{};

	Parms.NewForwardState = NewForwardState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleLanded
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   LandingForced                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLandedKickflip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnVehicleLanded(float LandingForced, bool bLandedKickflip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleLanded");

	Params::DelMarCosmeticActor_BP_OnVehicleLanded Parms{};

	Parms.LandingForced = LandingForced;
	Parms.bLandedKickflip = bLandedKickflip;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleStartedSkydiving
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnVehicleStartedSkydiving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleStartedSkydiving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleStoppedSkydiving
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnVehicleStoppedSkydiving()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleStoppedSkydiving");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnVehicleWheelsLeftGround
// (Event, Protected, BlueprintEvent)

void ADelMarCosmeticActor::BP_OnVehicleWheelsLeftGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnVehicleWheelsLeftGround");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnWheelsOnGroundChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnWheelsOnGroundChanged");

	Params::DelMarCosmeticActor_BP_OnWheelsOnGroundChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bValue = bValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnWorldBonusSpeedStackGained
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnWorldBonusSpeedStackGained(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnWorldBonusSpeedStackGained");

	Params::DelMarCosmeticActor_BP_OnWorldBonusSpeedStackGained Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.BP_OnWorldBonusSpeedStackLost
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Source                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCosmeticActor::BP_OnWorldBonusSpeedStackLost(const struct FGameplayTag& Source, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "BP_OnWorldBonusSpeedStackLost");

	Params::DelMarCosmeticActor_BP_OnWorldBonusSpeedStackLost Parms{};

	Parms.Source = std::move(Source);
	Parms.Stacks = Stacks;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarCore.DelMarCosmeticActor.GetBodyMeshComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ADelMarCosmeticActor::GetBodyMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "GetBodyMeshComponent");

	Params::DelMarCosmeticActor_GetBodyMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarCosmeticActor.IsLocallyViewed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarCosmeticActor::IsLocallyViewed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCosmeticActor", "IsLocallyViewed");

	Params::DelMarCosmeticActor_IsLocallyViewed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarLeaderboardManager.OnRep_LeaderboardConfig
// (Final, Native, Private)

void UDelMarLeaderboardManager::OnRep_LeaderboardConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLeaderboardManager", "OnRep_LeaderboardConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarMatchmakingComponent.ClientStartMatchmaking
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FOnlineLinkId&             LinkId                                                 (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarMatchmakingComponent::ClientStartMatchmaking(const struct FOnlineLinkId& LinkId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarMatchmakingComponent", "ClientStartMatchmaking");

	Params::DelMarMatchmakingComponent_ClientStartMatchmaking Parms{};

	Parms.LinkId = std::move(LinkId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarAsyncPhysicsTickMutator.TryToApplySolverOverrides
// (Final, Native, Protected)

void ADelMarAsyncPhysicsTickMutator::TryToApplySolverOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAsyncPhysicsTickMutator", "TryToApplySolverOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraInputControllerComponent.HandleCameraSwivelDeadzoneChanged
// (Final, Native, Protected)

void UDelMarCameraInputControllerComponent::HandleCameraSwivelDeadzoneChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraInputControllerComponent", "HandleCameraSwivelDeadzoneChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraInputControllerComponent.HandleInputSettingsChanged
// (Final, Native, Protected)

void UDelMarCameraInputControllerComponent::HandleInputSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraInputControllerComponent", "HandleInputSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarContextualHintComponent.HandleVehicleDemolished
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarContextualHintComponent::HandleVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarContextualHintComponent", "HandleVehicleDemolished");

	Params::DelMarContextualHintComponent_HandleVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarContextualHintComponent.HandleVehicleHazardHit
// (Final, Native, Private)

void UDelMarContextualHintComponent::HandleVehicleHazardHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarContextualHintComponent", "HandleVehicleHazardHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarLocalCheckpointVisibilityControllerComponent.HandleCheckpointPassed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_CheckpointPassed_ParallelPath&CheckpointEvent                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarLocalCheckpointVisibilityControllerComponent::HandleCheckpointPassed(const struct FDelMarEvent_CheckpointPassed_ParallelPath& CheckpointEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLocalCheckpointVisibilityControllerComponent", "HandleCheckpointPassed");

	Params::DelMarLocalCheckpointVisibilityControllerComponent_HandleCheckpointPassed Parms{};

	Parms.CheckpointEvent = std::move(CheckpointEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarLocalCheckpointVisibilityControllerComponent.HandleLapComplete
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_LapComplete&  LapEvent                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarLocalCheckpointVisibilityControllerComponent::HandleLapComplete(const struct FDelMarEvent_LapComplete& LapEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLocalCheckpointVisibilityControllerComponent", "HandleLapComplete");

	Params::DelMarLocalCheckpointVisibilityControllerComponent_HandleLapComplete Parms{};

	Parms.LapEvent = std::move(LapEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarLocalCheckpointVisibilityControllerComponent.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarLocalCheckpointVisibilityControllerComponent::HandleViewTargetChanged(class AFortPlayerController* PlayerController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLocalCheckpointVisibilityControllerComponent", "HandleViewTargetChanged");

	Params::DelMarLocalCheckpointVisibilityControllerComponent_HandleViewTargetChanged Parms{};

	Parms.PlayerController = PlayerController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarNetworkInputComponent.ServerSendInputs
// (Final, Net, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// const struct FDelMarNetworkInputPacket& InputPacket                                            (ConstParm, Parm, NativeAccessSpecifierPublic)

void UDelMarNetworkInputComponent::ServerSendInputs(const struct FDelMarNetworkInputPacket& InputPacket)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarNetworkInputComponent", "ServerSendInputs");

	Params::DelMarNetworkInputComponent_ServerSendInputs Parms{};

	Parms.InputPacket = std::move(InputPacket);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleAerialPitchActivationSettingChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleAerialPitchActivationSettingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleAerialPitchActivationSettingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleIconOnlyNameplatesSettingChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleIconOnlyNameplatesSettingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleIconOnlyNameplatesSettingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleInvertSteerSettingChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleInvertSteerSettingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleInvertSteerSettingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleLocalFortInputSettingsChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleLocalFortInputSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleLocalFortInputSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleTouchControlsSettingsChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleTouchControlsSettingsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleTouchControlsSettingsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.HandleVerticalKickflipInvertedSettingChanged
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::HandleVerticalKickflipInvertedSettingChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "HandleVerticalKickflipInvertedSettingChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.ServerSetInvertSteerMethod
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EDelMarInvertSteerMethod                InInvertSteerMethod                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerPreferencesComponent::ServerSetInvertSteerMethod(EDelMarInvertSteerMethod InInvertSteerMethod)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "ServerSetInvertSteerMethod");

	Params::DelMarPlayerPreferencesComponent_ServerSetInvertSteerMethod Parms{};

	Parms.InInvertSteerMethod = InInvertSteerMethod;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.ServerUpdateAerialPitchActivation
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const bool                              bInAerialPitchActivationEnabled                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerPreferencesComponent::ServerUpdateAerialPitchActivation(const bool bInAerialPitchActivationEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "ServerUpdateAerialPitchActivation");

	Params::DelMarPlayerPreferencesComponent_ServerUpdateAerialPitchActivation Parms{};

	Parms.bInAerialPitchActivationEnabled = bInAerialPitchActivationEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.ServerUpdatePitchInverted
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const bool                              bInPitchInverted                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerPreferencesComponent::ServerUpdatePitchInverted(const bool bInPitchInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "ServerUpdatePitchInverted");

	Params::DelMarPlayerPreferencesComponent_ServerUpdatePitchInverted Parms{};

	Parms.bInPitchInverted = bInPitchInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.ServerUpdateVerticalKickflipInverted
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const bool                              bInVerticalKickflipInverted                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerPreferencesComponent::ServerUpdateVerticalKickflipInverted(const bool bInVerticalKickflipInverted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "ServerUpdateVerticalKickflipInverted");

	Params::DelMarPlayerPreferencesComponent_ServerUpdateVerticalKickflipInverted Parms{};

	Parms.bInVerticalKickflipInverted = bInVerticalKickflipInverted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.TryGetFortClientSettings
// (Final, Native, Protected)

void UDelMarPlayerPreferencesComponent::TryGetFortClientSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "TryGetFortClientSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.GetTouchControlsLayout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UDelMarPlayerPreferencesComponent::GetTouchControlsLayout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "GetTouchControlsLayout");

	Params::DelMarPlayerPreferencesComponent_GetTouchControlsLayout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.GetUseIconOnlyPlayerNameplates
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarPlayerPreferencesComponent::GetUseIconOnlyPlayerNameplates() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "GetUseIconOnlyPlayerNameplates");

	Params::DelMarPlayerPreferencesComponent_GetUseIconOnlyPlayerNameplates Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerPreferencesComponent.GetUseToggleOnExpandableHudWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarPlayerPreferencesComponent::GetUseToggleOnExpandableHudWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerPreferencesComponent", "GetUseToggleOnExpandableHudWidget");

	Params::DelMarPlayerPreferencesComponent_GetUseToggleOnExpandableHudWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPlayerRespawnComponent.HandleVehicleAppliedTeleportLocation
// (Final, Native, Protected)

void UDelMarPlayerRespawnComponent::HandleVehicleAppliedTeleportLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRespawnComponent", "HandleVehicleAppliedTeleportLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerTurboManagerComponent.HandleTurboChargeUsed
// (Final, Native, Protected)

void UDelMarPlayerTurboManagerComponent::HandleTurboChargeUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerTurboManagerComponent", "HandleTurboChargeUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerTurboManagerComponent.ModifyTurboCharges
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerTurboManagerComponent::ModifyTurboCharges(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerTurboManagerComponent", "ModifyTurboCharges");

	Params::DelMarPlayerTurboManagerComponent_ModifyTurboCharges Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerTurboManagerComponent.ModifyTurboCharges_Delayed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerTurboManagerComponent::ModifyTurboCharges_Delayed(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerTurboManagerComponent", "ModifyTurboCharges_Delayed");

	Params::DelMarPlayerTurboManagerComponent_ModifyTurboCharges_Delayed Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayerTurboManagerComponent.SetTurboCharges
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerTurboManagerComponent::SetTurboCharges(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerTurboManagerComponent", "SetTurboCharges");

	Params::DelMarPlayerTurboManagerComponent_SetTurboCharges Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.HandleLoadoutsChangedOnServer
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCosmeticLoadout&          CosmeticLoadout                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::HandleLoadoutsChangedOnServer(const struct FCosmeticLoadout& CosmeticLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "HandleLoadoutsChangedOnServer");

	Params::DelMarRequestComponent_HandleLoadoutsChangedOnServer Parms{};

	Parms.CosmeticLoadout = std::move(CosmeticLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.PostRaceNextRaceSelected
// (Final, Native, Public, BlueprintCallable)

void UDelMarRequestComponent::PostRaceNextRaceSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "PostRaceNextRaceSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.PostRaceReturnToLobbySelected
// (Final, Native, Public, BlueprintCallable)

void UDelMarRequestComponent::PostRaceReturnToLobbySelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "PostRaceReturnToLobbySelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerPostRaceNextRaceSelected
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerPostRaceNextRaceSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerPostRaceNextRaceSelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerPostRaceReturnToLobbySelected
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerPostRaceReturnToLobbySelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerPostRaceReturnToLobbySelected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerReadyUp
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bInReadyUp                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::ServerReadyUp(bool bInReadyUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerReadyUp");

	Params::DelMarRequestComponent_ServerReadyUp Parms{};

	Parms.bInReadyUp = bInReadyUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestBecomeSpectator
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestBecomeSpectator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestBecomeSpectator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestFinalInitialization
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestFinalInitialization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestFinalInitialization");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestIdleKickExtension
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestIdleKickExtension()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestIdleKickExtension");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestMap
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InMapChoice                                            (Parm, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::ServerRequestMap(const struct FGameplayTagContainer& InMapChoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestMap");

	Params::DelMarRequestComponent_ServerRequestMap Parms{};

	Parms.InMapChoice = std::move(InMapChoice);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestMapFromGameplay
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InMapChoice                                            (Parm, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::ServerRequestMapFromGameplay(const struct FGameplayTagContainer& InMapChoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestMapFromGameplay");

	Params::DelMarRequestComponent_ServerRequestMapFromGameplay Parms{};

	Parms.InMapChoice = std::move(InMapChoice);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestRacerCountdown
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestRacerCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestRacerCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestResetRun
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestResetRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestResetRun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestSpectatorBecomePlayer
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestSpectatorBecomePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestSpectatorBecomePlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerRequestVehicleSpawn
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarRequestComponent::ServerRequestVehicleSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerRequestVehicleSpawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerSetJoinNextRace
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bInReadyToJoinRace                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::ServerSetJoinNextRace(bool bInReadyToJoinRace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerSetJoinNextRace");

	Params::DelMarRequestComponent_ServerSetJoinNextRace Parms{};

	Parms.bInReadyToJoinRace = bInReadyToJoinRace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.ServerSetPostRaceVote
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// EDelMarPostRaceVote                     NewVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRequestComponent::ServerSetPostRaceVote(EDelMarPostRaceVote NewVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "ServerSetPostRaceVote");

	Params::DelMarRequestComponent_ServerSetPostRaceVote Parms{};

	Parms.NewVote = NewVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.OnRep_bIsReadyToJoinRace
// (Final, Native, Protected, Const)

void UDelMarRequestComponent::OnRep_bIsReadyToJoinRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "OnRep_bIsReadyToJoinRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.OnRep_bIsReadyToStartRace
// (Final, Native, Protected, Const)

void UDelMarRequestComponent::OnRep_bIsReadyToStartRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "OnRep_bIsReadyToStartRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestComponent.OnRep_PostRaceVote
// (Final, Native, Protected, Const)

void UDelMarRequestComponent::OnRep_PostRaceVote() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestComponent", "OnRep_PostRaceVote");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRunRecordPlayerComponent.PrintRecords
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FDelMarRunRecord&          RunRecord                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRunRecordPlayerComponent::PrintRecords(const struct FDelMarRunRecord& RunRecord, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarRunRecordPlayerComponent", "PrintRecords");

	Params::DelMarRunRecordPlayerComponent_PrintRecords Parms{};

	Parms.RunRecord = std::move(RunRecord);
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRunRecordPlayerComponent.NetMulticast_LapRecorded
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_LapRecorded&  InLapRecordedEvent                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRunRecordPlayerComponent::NetMulticast_LapRecorded(const struct FDelMarEvent_LapRecorded& InLapRecordedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRunRecordPlayerComponent", "NetMulticast_LapRecorded");

	Params::DelMarRunRecordPlayerComponent_NetMulticast_LapRecorded Parms{};

	Parms.InLapRecordedEvent = std::move(InLapRecordedEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRunRecordPlayerComponent.NetMulticast_RunRecorded
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_RunRecorded&  InRunRecordedEvent                                     (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRunRecordPlayerComponent::NetMulticast_RunRecorded(const struct FDelMarEvent_RunRecorded& InRunRecordedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRunRecordPlayerComponent", "NetMulticast_RunRecorded");

	Params::DelMarRunRecordPlayerComponent_NetMulticast_RunRecorded Parms{};

	Parms.InRunRecordedEvent = std::move(InRunRecordedEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRunRecordPlayerComponent.NetMulticast_SectionRecorded
// (Net, NetReliable, Native, Event, NetMulticast, Protected)
// Parameters:
// const struct FDelMarEvent_SectionRecorded&InSectionRecordedEvent                                 (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRunRecordPlayerComponent::NetMulticast_SectionRecorded(const struct FDelMarEvent_SectionRecorded& InSectionRecordedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRunRecordPlayerComponent", "NetMulticast_SectionRecorded");

	Params::DelMarRunRecordPlayerComponent_NetMulticast_SectionRecorded Parms{};

	Parms.InSectionRecordedEvent = std::move(InSectionRecordedEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Replay
// (Final, Native, Public, BlueprintCallable)

void UDelMarTutorialRequestComponent::Replay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Replay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Server_RequestNextSection
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarTutorialRequestComponent::Server_RequestNextSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Server_RequestNextSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Server_RequestPrevSection
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UDelMarTutorialRequestComponent::Server_RequestPrevSection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Server_RequestPrevSection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Server_RequestSection
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTutorialRequestComponent::Server_RequestSection(int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Server_RequestSection");

	Params::DelMarTutorialRequestComponent_Server_RequestSection Parms{};

	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Server_RequestStartRace
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const bool                              bSkipCountdown                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTutorialRequestComponent::Server_RequestStartRace(const bool bSkipCountdown)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Server_RequestStartRace");

	Params::DelMarTutorialRequestComponent_Server_RequestStartRace Parms{};

	Parms.bSkipCountdown = bSkipCountdown;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.GoRace
// (Final, Native, Public, BlueprintCallable, Const)

void UDelMarTutorialRequestComponent::GoRace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "GoRace");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.KeepTraining
// (Final, Native, Public, BlueprintCallable, Const)

void UDelMarTutorialRequestComponent::KeepTraining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "KeepTraining");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.Server_KeepTraining
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, Const)

void UDelMarTutorialRequestComponent::Server_KeepTraining() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "Server_KeepTraining");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarTutorialRequestComponent.TutorialComplete
// (Final, Native, Public, BlueprintCallable, Const)

void UDelMarTutorialRequestComponent::TutorialComplete() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTutorialRequestComponent", "TutorialComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarLevelManagerComponent.RequestLevelLoad
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     DesiredMap                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarLevelManagerComponent::RequestLevelLoad(const struct FGameplayTagContainer& DesiredMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLevelManagerComponent", "RequestLevelLoad");

	Params::DelMarLevelManagerComponent_RequestLevelLoad Parms{};

	Parms.DesiredMap = std::move(DesiredMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarLevelManagerComponent.ServerRequestLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     DesiredMap                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarLevelManagerComponent::ServerRequestLevel(const struct FGameplayTagContainer& DesiredMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLevelManagerComponent", "ServerRequestLevel");

	Params::DelMarLevelManagerComponent_ServerRequestLevel Parms{};

	Parms.DesiredMap = std::move(DesiredMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.OnRep_ActiveRaceManagerUpdated
// (Final, Native, Protected)

void ADelMarPlayspace::OnRep_ActiveRaceManagerUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "OnRep_ActiveRaceManagerUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.OnRep_MRSLinkId
// (Final, Native, Public)

void ADelMarPlayspace::OnRep_MRSLinkId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "OnRep_MRSLinkId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.RequestNextMapFromMapSet
// (Net, NetReliable, Native, Event, Public, NetServer)

void ADelMarPlayspace::RequestNextMapFromMapSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "RequestNextMapFromMapSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.ServerRequestLoadingLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     DesiredMap                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ADelMarPlayspace::ServerRequestLoadingLevel(const struct FGameplayTagContainer& DesiredMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "ServerRequestLoadingLevel");

	Params::DelMarPlayspace_ServerRequestLoadingLevel Parms{};

	Parms.DesiredMap = std::move(DesiredMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.ServerRequestLoadingLevelWithLinkCode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FOnlineLinkId&             DesiredMap                                             (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarPlayspace::ServerRequestLoadingLevelWithLinkCode(const struct FOnlineLinkId& DesiredMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "ServerRequestLoadingLevelWithLinkCode");

	Params::DelMarPlayspace_ServerRequestLoadingLevelWithLinkCode Parms{};

	Parms.DesiredMap = std::move(DesiredMap);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.ServerReturnToSetup
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTagContainer&     OptionalMapToForceLoad                                 (ConstParm, Parm, NativeAccessSpecifierPublic)

void ADelMarPlayspace::ServerReturnToSetup(const struct FGameplayTagContainer& OptionalMapToForceLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "ServerReturnToSetup");

	Params::DelMarPlayspace_ServerReturnToSetup Parms{};

	Parms.OptionalMapToForceLoad = std::move(OptionalMapToForceLoad);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.ServerReturnToSetupWithLinkCode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FOnlineLinkId&             OptionalMapToForceLoad                                 (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarPlayspace::ServerReturnToSetupWithLinkCode(const struct FOnlineLinkId& OptionalMapToForceLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "ServerReturnToSetupWithLinkCode");

	Params::DelMarPlayspace_ServerReturnToSetupWithLinkCode Parms{};

	Parms.OptionalMapToForceLoad = std::move(OptionalMapToForceLoad);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.SetLoadingScreenVisibiliy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShouldShowLoadingScreen                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarPlayspace::SetLoadingScreenVisibiliy(bool bInShouldShowLoadingScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "SetLoadingScreenVisibiliy");

	Params::DelMarPlayspace_SetLoadingScreenVisibiliy Parms{};

	Parms.bInShouldShowLoadingScreen = bInShouldShowLoadingScreen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarPlayspace.ShouldShowLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarPlayspace::ShouldShowLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayspace", "ShouldShowLoadingScreen");

	Params::DelMarPlayspace_ShouldShowLoadingScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPreRaceControllerComponent.ServerSetViewTarget
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPreRaceControllerComponent::ServerSetViewTarget(class AFortPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPreRaceControllerComponent", "ServerSetViewTarget");

	Params::DelMarPreRaceControllerComponent_ServerSetViewTarget Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheckpointManagerComponent.HandleRaceFinished
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FDelMarEvent_RaceFinished& Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarCheckpointManagerComponent::HandleRaceFinished(const struct FDelMarEvent_RaceFinished& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpointManagerComponent", "HandleRaceFinished");

	Params::DelMarCheckpointManagerComponent_HandleRaceFinished Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCheckpointManagerComponent.HandleResetRace
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FDelMarEvent_ResetRace&    Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarCheckpointManagerComponent::HandleResetRace(const struct FDelMarEvent_ResetRace& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpointManagerComponent", "HandleResetRace");

	Params::DelMarCheckpointManagerComponent_HandleResetRace Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarDeathRaceManager.GetPointsAwardForPlacement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             InPlacement                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarDeathRaceManager::GetPointsAwardForPlacement(const int32 InPlacement) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDeathRaceManager", "GetPointsAwardForPlacement");

	Params::DelMarDeathRaceManager_GetPointsAwardForPlacement Parms{};

	Parms.InPlacement = InPlacement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarDeathRaceManager.GetScoreThresholdToEndMatch
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarDeathRaceManager::GetScoreThresholdToEndMatch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDeathRaceManager", "GetScoreThresholdToEndMatch");

	Params::DelMarDeathRaceManager_GetScoreThresholdToEndMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarPositionalTrackerComponent.OnRep_FinalRacePositions
// (Final, Native, Protected)

void UDelMarPositionalTrackerComponent::OnRep_FinalRacePositions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPositionalTrackerComponent", "OnRep_FinalRacePositions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceConfigComponent.BroadcastVehicleAbilityConfigUpdated
// (Final, Native, Public, BlueprintCallable)

void UDelMarRaceConfigComponent::BroadcastVehicleAbilityConfigUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceConfigComponent", "BroadcastVehicleAbilityConfigUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRaceConfigComponent.OnRep_VehicleAbilityConfig
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarVehicleAbilityConfig&OldConfig                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarRaceConfigComponent::OnRep_VehicleAbilityConfig(const struct FDelMarVehicleAbilityConfig& OldConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceConfigComponent", "OnRep_VehicleAbilityConfig");

	Params::DelMarRaceConfigComponent_OnRep_VehicleAbilityConfig Parms{};

	Parms.OldConfig = std::move(OldConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRequestTrackerComponent.OnRep_PlayerReadyStates
// (Final, Native, Protected)

void UDelMarRequestTrackerComponent::OnRep_PlayerReadyStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRequestTrackerComponent", "OnRep_PlayerReadyStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarRespawnManagerComponent.RequestRespawnPawnAndVehicle
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarVehicle*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarVehicle* UDelMarRespawnManagerComponent::RequestRespawnPawnAndVehicle(class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRespawnManagerComponent", "RequestRespawnPawnAndVehicle");

	Params::DelMarRespawnManagerComponent_RequestRespawnPawnAndVehicle Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRespawnManagerComponent.RequestRespawnVehicleForPawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerPawn*                  InPlayerPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarVehicle*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarVehicle* UDelMarRespawnManagerComponent::RequestRespawnVehicleForPawn(class AFortPlayerPawn* InPlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRespawnManagerComponent", "RequestRespawnVehicleForPawn");

	Params::DelMarRespawnManagerComponent_RequestRespawnVehicleForPawn Parms{};

	Parms.InPlayerPawn = InPlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarRubberbandingManagerComponent.OnRep_RubberbandingConfig
// (Final, Native, Protected)

void UDelMarRubberbandingManagerComponent::OnRep_RubberbandingConfig()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRubberbandingManagerComponent", "OnRep_RubberbandingConfig");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarState_Gameplay_Postrace.OnRep_EliminationList
// (Final, Native, Private)

void UDelMarState_Gameplay_Postrace::OnRep_EliminationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarState_Gameplay_Postrace", "OnRep_EliminationList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarState_Gameplay_Postrace.OnRep_PostRaceEndServerTime
// (Final, Native, Protected)

void UDelMarState_Gameplay_Postrace::OnRep_PostRaceEndServerTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarState_Gameplay_Postrace", "OnRep_PostRaceEndServerTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarState_Gameplay_Prerace.OnRep_PreRaceCountdownFinishServerTime
// (Final, Native, Private)

void UDelMarState_Gameplay_Prerace::OnRep_PreRaceCountdownFinishServerTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarState_Gameplay_Prerace", "OnRep_PreRaceCountdownFinishServerTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarState_Gameplay_WaitingForPlayers.OnRep_LoadedPlayerStates
// (Final, Native, Protected)

void UDelMarState_Gameplay_WaitingForPlayers::OnRep_LoadedPlayerStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarState_Gameplay_WaitingForPlayers", "OnRep_LoadedPlayerStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnCameraShakeIntensitySettingsChanged
// (Final, Native, Private)
// Parameters:
// class UFortClientSettingsRecord*        Settings                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCameraShakeComponent::OnCameraShakeIntensitySettingsChanged(class UFortClientSettingsRecord* Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnCameraShakeIntensitySettingsChanged");

	Params::DelMarCameraShakeComponent_OnCameraShakeIntensitySettingsChanged Parms{};

	Parms.Settings = Settings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnHazardHit
// (Final, Native, Protected)

void UDelMarCameraShakeComponent::OnHazardHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnHazardHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnJumpActivated
// (Final, Native, Protected)

void UDelMarCameraShakeComponent::OnJumpActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnJumpActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnVehicleHitVehicle
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCameraShakeComponent::OnVehicleHitVehicle(float Magnitude, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnVehicleHitVehicle");

	Params::DelMarCameraShakeComponent_OnVehicleHitVehicle Parms{};

	Parms.Magnitude = Magnitude;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnVehicleHitWall
// (Final, Native, Protected, HasDefaults)
// Parameters:
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ForwardRotationDegrees                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCameraShakeComponent::OnVehicleHitWall(float Magnitude, const struct FVector& WorldLocation, float ForwardRotationDegrees)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnVehicleHitWall");

	Params::DelMarCameraShakeComponent_OnVehicleHitWall Parms{};

	Parms.Magnitude = Magnitude;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.ForwardRotationDegrees = ForwardRotationDegrees;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarCameraShakeComponent.OnVehicleLanded
// (Final, Native, Protected)
// Parameters:
// float                                   LandingForce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLandedKickflip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCameraShakeComponent::OnVehicleLanded(float LandingForce, bool bLandedKickflip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCameraShakeComponent", "OnVehicleLanded");

	Params::DelMarCameraShakeComponent_OnVehicleLanded Parms{};

	Parms.LandingForce = LandingForce;
	Parms.bLandedKickflip = bLandedKickflip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleCosmeticComponent.GetCosmeticActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ADelMarCosmeticActor> CosmeticClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLookForChildClasses                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ADelMarCosmeticActor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarCosmeticActor* UDelMarVehicleCosmeticComponent::GetCosmeticActor(TSubclassOf<class ADelMarCosmeticActor> CosmeticClass, bool bLookForChildClasses) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCosmeticComponent", "GetCosmeticActor");

	Params::DelMarVehicleCosmeticComponent_GetCosmeticActor Parms{};

	Parms.CosmeticClass = CosmeticClass;
	Parms.bLookForChildClasses = bLookForChildClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleCosmeticComponent.GetCosmeticActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class ADelMarCosmeticActor> CosmeticClass                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLookForChildClasses                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ADelMarCosmeticActor*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADelMarCosmeticActor*> UDelMarVehicleCosmeticComponent::GetCosmeticActors(TSubclassOf<class ADelMarCosmeticActor> CosmeticClass, bool bLookForChildClasses) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleCosmeticComponent", "GetCosmeticActors");

	Params::DelMarVehicleCosmeticComponent_GetCosmeticActors Parms{};

	Parms.CosmeticClass = CosmeticClass;
	Parms.bLookForChildClasses = bLookForChildClasses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.HandleLoadingScreenVisibilityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bVisibility                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleForceFeedbackComponent::HandleLoadingScreenVisibilityChanged(bool bVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "HandleLoadingScreenVisibilityChanged");

	Params::DelMarVehicleForceFeedbackComponent_HandleLoadingScreenVisibilityChanged Parms{};

	Parms.bVisibility = bVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnDriftActivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnDriftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnDriftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnDriftBoostActivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnDriftBoostActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnDriftBoostActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnDriftBoostDeactivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnDriftBoostDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnDriftBoostDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnDriftControlChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bIsDriftControlled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleForceFeedbackComponent::OnDriftControlChanged(bool bIsDriftControlled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnDriftControlChanged");

	Params::DelMarVehicleForceFeedbackComponent_OnDriftControlChanged Parms{};

	Parms.bIsDriftControlled = bIsDriftControlled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnDriftDeactivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnDriftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnDriftDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnHazardHit
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnHazardHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnHazardHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnJumpActivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnJumpActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnJumpActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnTurboActivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnTurboActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnTurboActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnTurboDeactivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnTurboDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnTurboDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnUnderthrustActivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnUnderthrustActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnUnderthrustActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnUnderthrustDeactivated
// (Final, Native, Protected)

void UDelMarVehicleForceFeedbackComponent::OnUnderthrustDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnUnderthrustDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleForceFeedbackComponent.OnVehicleLanded
// (Final, Native, Protected)
// Parameters:
// float                                   LandingForce                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLandedKickflip                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleForceFeedbackComponent::OnVehicleLanded(float LandingForce, bool bLandedKickflip)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleForceFeedbackComponent", "OnVehicleLanded");

	Params::DelMarVehicleForceFeedbackComponent_OnVehicleLanded Parms{};

	Parms.LandingForce = LandingForce;
	Parms.bLandedKickflip = bLandedKickflip;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleMovementSet.OnRep_AccelMultiplier
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FFortGameplayAttributeData&OldSpeedMultiplier                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarVehicleMovementSet::OnRep_AccelMultiplier(const struct FFortGameplayAttributeData& OldSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleMovementSet", "OnRep_AccelMultiplier");

	Params::DelMarVehicleMovementSet_OnRep_AccelMultiplier Parms{};

	Parms.OldSpeedMultiplier = std::move(OldSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleMovementSet.OnRep_BonusSpeed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FFortGameplayAttributeData&OldBonusSpeed                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarVehicleMovementSet::OnRep_BonusSpeed(const struct FFortGameplayAttributeData& OldBonusSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleMovementSet", "OnRep_BonusSpeed");

	Params::DelMarVehicleMovementSet_OnRep_BonusSpeed Parms{};

	Parms.OldBonusSpeed = std::move(OldBonusSpeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleMovementSet.OnRep_VehicleThrottleDisabled
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FFortGameplayAttributeData&OldInputDisabled                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarVehicleMovementSet::OnRep_VehicleThrottleDisabled(const struct FFortGameplayAttributeData& OldInputDisabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleMovementSet", "OnRep_VehicleThrottleDisabled");

	Params::DelMarVehicleMovementSet_OnRep_VehicleThrottleDisabled Parms{};

	Parms.OldInputDisabled = std::move(OldInputDisabled);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleTurboManagerComponent.HandleTurboChargeUsed
// (Final, Native, Protected)

void UDelMarVehicleTurboManagerComponent::HandleTurboChargeUsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleTurboManagerComponent", "HandleTurboChargeUsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleTurboManagerComponent.ModifyTurboCharges
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleTurboManagerComponent::ModifyTurboCharges(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleTurboManagerComponent", "ModifyTurboCharges");

	Params::DelMarVehicleTurboManagerComponent_ModifyTurboCharges Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleTurboManagerComponent.ModifyTurboCharges_Delayed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleTurboManagerComponent::ModifyTurboCharges_Delayed(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleTurboManagerComponent", "ModifyTurboCharges_Delayed");

	Params::DelMarVehicleTurboManagerComponent_ModifyTurboCharges_Delayed Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleTurboManagerComponent.OnConfigOverridesSet
// (Final, Native, Protected)

void UDelMarVehicleTurboManagerComponent::OnConfigOverridesSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleTurboManagerComponent", "OnConfigOverridesSet");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarCore.DelMarVehicleTurboManagerComponent.SetTurboCharges
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TurboChargeAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleTurboManagerComponent::SetTurboCharges(float TurboChargeAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleTurboManagerComponent", "SetTurboCharges");

	Params::DelMarVehicleTurboManagerComponent_SetTurboCharges Parms{};

	Parms.TurboChargeAmount = TurboChargeAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

