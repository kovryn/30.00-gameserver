#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ItemizedPropSpawnerParentRuntime

#include "Basic.hpp"

#include "ItemizedPropSpawnerParentRuntime_classes.hpp"
#include "ItemizedPropSpawnerParentRuntime_parameters.hpp"


namespace SDK
{

// Function ItemizedPropSpawnerParentRuntime.FortGameplayAbility_RangedPropSpawner.HandleAbilityRejectedOnClient
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortWeapon*                      SourceWeapon                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortGameplayAbility_RangedPropSpawner::HandleAbilityRejectedOnClient(class AFortWeapon* SourceWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortGameplayAbility_RangedPropSpawner", "HandleAbilityRejectedOnClient");

	Params::FortGameplayAbility_RangedPropSpawner_HandleAbilityRejectedOnClient Parms{};

	Parms.SourceWeapon = SourceWeapon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.AttachActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AEmeraldGlassIceWallChunk*>&ChunksInMyWall                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            SupportingActors                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           DirectBase                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::AttachActors(const TArray<class AEmeraldGlassIceWallChunk*>& ChunksInMyWall, const TArray<class AActor*>& SupportingActors, class AActor* DirectBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "AttachActors");

	Params::EmeraldGlassIceWallChunk_AttachActors Parms{};

	Parms.ChunksInMyWall = std::move(ChunksInMyWall);
	Parms.SupportingActors = std::move(SupportingActors);
	Parms.DirectBase = DirectBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.FindSupportingActors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class AActor*>&                  InOutSupportingActors                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const bool                              bAllowIceWallsAsSupportingActors                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AEmeraldGlassIceWallChunk*>&ChunksInMyWall                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::FindSupportingActors(TArray<class AActor*>& InOutSupportingActors, const bool bAllowIceWallsAsSupportingActors, const TArray<class AEmeraldGlassIceWallChunk*>& ChunksInMyWall)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "FindSupportingActors");

	Params::EmeraldGlassIceWallChunk_FindSupportingActors Parms{};

	Parms.InOutSupportingActors = std::move(InOutSupportingActors);
	Parms.bAllowIceWallsAsSupportingActors = bAllowIceWallsAsSupportingActors;
	Parms.ChunksInMyWall = std::move(ChunksInMyWall);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutSupportingActors = std::move(Parms.InOutSupportingActors);
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.GetComponentsForOverlapCheck
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UPrimitiveComponent*>*     OutComponents                                          (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::GetComponentsForOverlapCheck(TArray<class UPrimitiveComponent*>* OutComponents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "GetComponentsForOverlapCheck");

	Params::EmeraldGlassIceWallChunk_GetComponentsForOverlapCheck Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutComponents != nullptr)
		*OutComponents = std::move(Parms.OutComponents);
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.NativeCheckOverlappedActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSereneYardOverlappedActorCheckData&CheckData                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCapsuleComponent*>&       InOutComponentsSetToIgnoreCollision                    (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool&                                   bInOutShouldPlayImpulseCue                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutDestroyOverlappedActor                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutShouldWaitATick                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutDestroyProp                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEmeraldGlassIceWallChunk::NativeCheckOverlappedActor(const struct FSereneYardOverlappedActorCheckData& CheckData, class AActor* OverlappedActor, TArray<class UCapsuleComponent*>& InOutComponentsSetToIgnoreCollision, bool& bInOutShouldPlayImpulseCue, bool* bOutDestroyOverlappedActor, bool* bOutShouldWaitATick, bool* bOutDestroyProp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "NativeCheckOverlappedActor");

	Params::EmeraldGlassIceWallChunk_NativeCheckOverlappedActor Parms{};

	Parms.CheckData = std::move(CheckData);
	Parms.OverlappedActor = OverlappedActor;
	Parms.InOutComponentsSetToIgnoreCollision = std::move(InOutComponentsSetToIgnoreCollision);
	Parms.bInOutShouldPlayImpulseCue = bInOutShouldPlayImpulseCue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutComponentsSetToIgnoreCollision = std::move(Parms.InOutComponentsSetToIgnoreCollision);
	bInOutShouldPlayImpulseCue = Parms.bInOutShouldPlayImpulseCue;

	if (bOutDestroyOverlappedActor != nullptr)
		*bOutDestroyOverlappedActor = Parms.bOutDestroyOverlappedActor;

	if (bOutShouldWaitATick != nullptr)
		*bOutShouldWaitATick = Parms.bOutShouldWaitATick;

	if (bOutDestroyProp != nullptr)
		*bOutDestroyProp = Parms.bOutDestroyProp;
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.NativeShouldActorBlockSpawn
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bShouldLaunch                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              BlockTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmeraldGlassIceWallChunk::NativeShouldActorBlockSpawn(class AActor* Actor, const bool bShouldLaunch, const struct FGameplayTag& BlockTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "NativeShouldActorBlockSpawn");

	Params::EmeraldGlassIceWallChunk_NativeShouldActorBlockSpawn Parms{};

	Parms.Actor = Actor;
	Parms.bShouldLaunch = bShouldLaunch;
	Parms.BlockTag = std::move(BlockTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.NativeShouldDestroyOverlappedActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     TagsToDestroyOverlappedActor                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmeraldGlassIceWallChunk::NativeShouldDestroyOverlappedActor(class AActor* Actor, const struct FGameplayTagContainer& TagsToDestroyOverlappedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "NativeShouldDestroyOverlappedActor");

	Params::EmeraldGlassIceWallChunk_NativeShouldDestroyOverlappedActor Parms{};

	Parms.Actor = Actor;
	Parms.TagsToDestroyOverlappedActor = std::move(TagsToDestroyOverlappedActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.EmeraldGlassIceWallChunk.IsIceWallAllowedToOverlapActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEmeraldGlassIceWallChunk::IsIceWallAllowedToOverlapActor(const class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EmeraldGlassIceWallChunk", "IsIceWallAllowedToOverlapActor");

	Params::EmeraldGlassIceWallChunk_IsIceWallAllowedToOverlapActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.FortControllerComponent_SereneYard.AddTrackedInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ABuildingGameplayActor*           TrackedInstance                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortControllerComponent_SereneYard::AddTrackedInstance(class ABuildingGameplayActor* TrackedInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "AddTrackedInstance");

	Params::FortControllerComponent_SereneYard_AddTrackedInstance Parms{};

	Parms.TrackedInstance = TrackedInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function ItemizedPropSpawnerParentRuntime.FortControllerComponent_SereneYard.RemoveOldestTrackedInstance
// (Final, Native, Public, BlueprintCallable)

void UFortControllerComponent_SereneYard::RemoveOldestTrackedInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "RemoveOldestTrackedInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function ItemizedPropSpawnerParentRuntime.FortControllerComponent_SereneYard.GetOldestTrackedInstance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ABuildingGameplayActor*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ABuildingGameplayActor* UFortControllerComponent_SereneYard::GetOldestTrackedInstance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "GetOldestTrackedInstance");

	Params::FortControllerComponent_SereneYard_GetOldestTrackedInstance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.FortControllerComponent_SereneYard.GetTrackedInstanceCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFortControllerComponent_SereneYard::GetTrackedInstanceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortControllerComponent_SereneYard", "GetTrackedInstanceCount");

	Params::FortControllerComponent_SereneYard_GetTrackedInstanceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.SereneYardFunctionLibraryNative.BuildPropDataForWeaponData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FNativeItemizedPropSpawner_PropSpawnData>&PropSpawnDataArray                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FTransform>*              PropRelativeTransforms                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TMap<ESereneYardChunkLocation, int32>*  ChunkLocationToPropIndexMap                            (Parm, OutParm, NativeAccessSpecifierPublic)

void USereneYardFunctionLibraryNative::BuildPropDataForWeaponData(const TArray<struct FNativeItemizedPropSpawner_PropSpawnData>& PropSpawnDataArray, TArray<struct FTransform>* PropRelativeTransforms, TMap<ESereneYardChunkLocation, int32>* ChunkLocationToPropIndexMap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "BuildPropDataForWeaponData");

	Params::SereneYardFunctionLibraryNative_BuildPropDataForWeaponData Parms{};

	Parms.PropSpawnDataArray = std::move(PropSpawnDataArray);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PropRelativeTransforms != nullptr)
		*PropRelativeTransforms = std::move(Parms.PropRelativeTransforms);

	if (ChunkLocationToPropIndexMap != nullptr)
		*ChunkLocationToPropIndexMap = std::move(Parms.ChunkLocationToPropIndexMap);
}


// Function ItemizedPropSpawnerParentRuntime.SereneYardFunctionLibraryNative.NativeCheckSpawnValidity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector&                         InOutTargetLocation                                    (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             CameraYaw                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bCheckForAllChunks                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           OutValidity                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<double>*                         OutOffsets                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  OutActorsBeingUsedAsBase                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// ESereneYardTargetingFailedReason*       OutFailureReason                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeCheckSpawnValidity(const struct FSereneYardWeaponData& WeaponData, struct FVector& InOutTargetLocation, const float CameraYaw, const bool bCheckForAllChunks, TArray<bool>* OutValidity, TArray<double>* OutOffsets, TArray<class AActor*>* OutActorsBeingUsedAsBase, ESereneYardTargetingFailedReason* OutFailureReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeCheckSpawnValidity");

	Params::SereneYardFunctionLibraryNative_NativeCheckSpawnValidity Parms{};

	Parms.WeaponData = std::move(WeaponData);
	Parms.InOutTargetLocation = std::move(InOutTargetLocation);
	Parms.CameraYaw = CameraYaw;
	Parms.bCheckForAllChunks = bCheckForAllChunks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	InOutTargetLocation = std::move(Parms.InOutTargetLocation);

	if (OutValidity != nullptr)
		*OutValidity = std::move(Parms.OutValidity);

	if (OutOffsets != nullptr)
		*OutOffsets = std::move(Parms.OutOffsets);

	if (OutActorsBeingUsedAsBase != nullptr)
		*OutActorsBeingUsedAsBase = std::move(Parms.OutActorsBeingUsedAsBase);

	if (OutFailureReason != nullptr)
		*OutFailureReason = Parms.OutFailureReason;

	return Parms.ReturnValue;
}


// Function ItemizedPropSpawnerParentRuntime.SereneYardFunctionLibraryNative.NativeUpdateTarget
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FSereneYardWeaponData&     WeaponData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         outTargetLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESereneYardTargetingFailedReason*       OutFailureReason                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<bool>*                           OutValidity                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USereneYardFunctionLibraryNative::NativeUpdateTarget(const struct FSereneYardWeaponData& WeaponData, struct FVector* outTargetLocation, ESereneYardTargetingFailedReason* OutFailureReason, TArray<bool>* OutValidity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SereneYardFunctionLibraryNative", "NativeUpdateTarget");

	Params::SereneYardFunctionLibraryNative_NativeUpdateTarget Parms{};

	Parms.WeaponData = std::move(WeaponData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (outTargetLocation != nullptr)
		*outTargetLocation = std::move(Parms.outTargetLocation);

	if (OutFailureReason != nullptr)
		*OutFailureReason = Parms.OutFailureReason;

	if (OutValidity != nullptr)
		*OutValidity = std::move(Parms.OutValidity);

	return Parms.ReturnValue;
}

}

