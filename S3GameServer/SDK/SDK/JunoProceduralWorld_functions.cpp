#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JunoProceduralWorld

#include "Basic.hpp"

#include "JunoProceduralWorld_classes.hpp"
#include "JunoProceduralWorld_parameters.hpp"


namespace SDK
{

// Function JunoProceduralWorld.JunoBridgePOISelectorComponent.BeginBridgeSelection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoBridgePOISelectorParams&Param_Params_0                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoBridgePOISelectorComponent::BeginBridgeSelection(const struct FJunoBridgePOISelectorParams& Param_Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoBridgePOISelectorComponent", "BeginBridgeSelection");

	Params::JunoBridgePOISelectorComponent_BeginBridgeSelection Parms{};

	Parms.Param_Params_0 = std::move(Param_Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoBridgePOISelectorComponent.DoSelection
// (Final, Native, Protected)

void UJunoBridgePOISelectorComponent::DoSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoBridgePOISelectorComponent", "DoSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveGeneratorDataMergerInterface.MergeCaveData
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FJunoCaveGeneratorData*          CaveData                                               (Parm, OutParm, NativeAccessSpecifierPublic)

void IJunoCaveGeneratorDataMergerInterface::MergeCaveData(struct FJunoCaveGeneratorData* CaveData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("JunoCaveGeneratorDataMergerInterface", "MergeCaveData");

	Params::JunoCaveGeneratorDataMergerInterface_MergeCaveData Parms{};

	AsUObject()->ProcessEvent(Func, &Parms);

	if (CaveData != nullptr)
		*CaveData = std::move(Parms.CaveData);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCaveData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FJunoCaveGeneratorData&    ResourceData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         POIDataRegistry_0                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TSubclassOf<class AJunoTeleporter>&SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoGeneratedCaveShellData>*Shells                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIData>*            POIs                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveGeneratorPlayspaceComponent::GenerateCaveData(const struct FJunoCaveGeneratorData& ResourceData, const struct FDataRegistryType& POIDataRegistry_0, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, TArray<struct FJunoGeneratedCaveShellData>* Shells, TArray<struct FJunoPOIData>* POIs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GenerateCaveData");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCaveData Parms{};

	Parms.ResourceData = std::move(ResourceData);
	Parms.POIDataRegistry_0 = std::move(POIDataRegistry_0);
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Shells != nullptr)
		*Shells = std::move(Parms.Shells);

	if (POIs != nullptr)
		*POIs = std::move(Parms.POIs);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCaveDataWithSlotTags
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FJunoCaveGeneratorData&    ResourceData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         POIDataRegistry_0                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     SlotTags                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TSubclassOf<class AJunoTeleporter>&SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoGeneratedCaveShellData>*Shells                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIData>*            POIs                                                   (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveGeneratorPlayspaceComponent::GenerateCaveDataWithSlotTags(const struct FJunoCaveGeneratorData& ResourceData, const struct FDataRegistryType& POIDataRegistry_0, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FGameplayTagContainer& SlotTags, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, TArray<struct FJunoGeneratedCaveShellData>* Shells, TArray<struct FJunoPOIData>* POIs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GenerateCaveDataWithSlotTags");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCaveDataWithSlotTags Parms{};

	Parms.ResourceData = std::move(ResourceData);
	Parms.POIDataRegistry_0 = std::move(POIDataRegistry_0);
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.SlotTags = std::move(SlotTags);
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Shells != nullptr)
		*Shells = std::move(Parms.Shells);

	if (POIs != nullptr)
		*POIs = std::move(Parms.POIs);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetMergedCaveDataRegistryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataRegistryType&         CaveGeneratorDataRegistry                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveGeneratorData*          ResourceData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetMergedCaveDataRegistryDataResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GetMergedCaveDataRegistryData(const struct FDataRegistryType& CaveGeneratorDataRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GetMergedCaveDataRegistryData");

	Params::JunoCaveGeneratorPlayspaceComponent_GetMergedCaveDataRegistryData Parms{};

	Parms.CaveGeneratorDataRegistry = std::move(CaveGeneratorDataRegistry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResourceData != nullptr)
		*ResourceData = std::move(Parms.ResourceData);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetMergedMultiCaveDataRegistryData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataRegistryType&         ShellRegistry                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         ThemeRegistry                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         TypeRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         RuleRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveGeneratorData*          ResourceData                                           (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetMergedCaveDataRegistryDataResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GetMergedMultiCaveDataRegistryData(const struct FDataRegistryType& ShellRegistry, const struct FDataRegistryType& ThemeRegistry, const struct FDataRegistryType& TypeRegistry, const struct FDataRegistryType& RuleRegistry, struct FJunoCaveGeneratorData* ResourceData, EJunoGetMergedCaveDataRegistryDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GetMergedMultiCaveDataRegistryData");

	Params::JunoCaveGeneratorPlayspaceComponent_GetMergedMultiCaveDataRegistryData Parms{};

	Parms.ShellRegistry = std::move(ShellRegistry);
	Parms.ThemeRegistry = std::move(ThemeRegistry);
	Parms.TypeRegistry = std::move(TypeRegistry);
	Parms.RuleRegistry = std::move(RuleRegistry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ResourceData != nullptr)
		*ResourceData = std::move(Parms.ResourceData);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GetRootCaveGeneratorComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJunoCaveGeneratorPlayspaceComponent*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJunoCaveGeneratorPlayspaceComponent* UJunoCaveGeneratorPlayspaceComponent::GetRootCaveGeneratorComponent(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GetRootCaveGeneratorComponent");

	Params::JunoCaveGeneratorPlayspaceComponent_GetRootCaveGeneratorComponent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.IsNativeCaveGeneratorEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveGeneratorPlayspaceComponent::IsNativeCaveGeneratorEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "IsNativeCaveGeneratorEnabled");

	Params::JunoCaveGeneratorPlayspaceComponent_IsNativeCaveGeneratorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorRules
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FJunoCaveGeneratorRule>&Rules                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorRule>*  SortedRules                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorRules(const TArray<struct FJunoCaveGeneratorRule>& Rules, TArray<struct FJunoCaveGeneratorRule>* SortedRules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "SortCaveGeneratorRules");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorRules Parms{};

	Parms.Rules = std::move(Rules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SortedRules != nullptr)
		*SortedRules = std::move(Parms.SortedRules);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorShells
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FJunoCaveGeneratorShellData>&Shells                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorShellData>*SortedShells                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorShells(const TArray<struct FJunoCaveGeneratorShellData>& Shells, TArray<struct FJunoCaveGeneratorShellData>* SortedShells)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "SortCaveGeneratorShells");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorShells Parms{};

	Parms.Shells = std::move(Shells);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SortedShells != nullptr)
		*SortedShells = std::move(Parms.SortedShells);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorThemes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FJunoCaveGeneratorThemeEntry>&Themes                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorThemeEntry>*SortedThemes                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorThemes(const TArray<struct FJunoCaveGeneratorThemeEntry>& Themes, TArray<struct FJunoCaveGeneratorThemeEntry>* SortedThemes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "SortCaveGeneratorThemes");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorThemes Parms{};

	Parms.Themes = std::move(Themes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SortedThemes != nullptr)
		*SortedThemes = std::move(Parms.SortedThemes);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SortCaveGeneratorTypes
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<struct FJunoCaveGeneratorTypeData>&Types                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveGeneratorTypeData>*SortedTypes                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SortCaveGeneratorTypes(const TArray<struct FJunoCaveGeneratorTypeData>& Types, TArray<struct FJunoCaveGeneratorTypeData>* SortedTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveGeneratorPlayspaceComponent", "SortCaveGeneratorTypes");

	Params::JunoCaveGeneratorPlayspaceComponent_SortCaveGeneratorTypes Parms{};

	Parms.Types = std::move(Types);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SortedTypes != nullptr)
		*SortedTypes = std::move(Parms.SortedTypes);
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCave
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TSubclassOf<class AJunoTeleporter>&SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LayerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GenerateCave(class AActor* WorldActor, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GenerateCave");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCave Parms{};

	Parms.WorldActor = WorldActor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.GenerateCaveWithSlotTags
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     SlotTags                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const TSubclassOf<class AJunoTeleporter>&SurfaceTeleporterClass                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LayerName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::GenerateCaveWithSlotTags(class AActor* WorldActor, const struct FRandomStream& RandomStream, const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, const struct FGameplayTagContainer& SlotTags, const struct FBox& Bounds, const TSubclassOf<class AJunoTeleporter>& SurfaceTeleporterClass, class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveGeneratorPlayspaceComponent", "GenerateCaveWithSlotTags");

	Params::JunoCaveGeneratorPlayspaceComponent_GenerateCaveWithSlotTags Parms{};

	Parms.WorldActor = WorldActor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.SlotTags = std::move(SlotTags);
	Parms.Bounds = std::move(Bounds);
	Parms.SurfaceTeleporterClass = SurfaceTeleporterClass;
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveGeneratorPlayspaceComponent.SetMergedData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoCaveGeneratorData&    Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoCaveGeneratorPlayspaceComponent::SetMergedData(const struct FJunoCaveGeneratorData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveGeneratorPlayspaceComponent", "SetMergedData");

	Params::JunoCaveGeneratorPlayspaceComponent_SetMergedData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProvider.AppendFiltersTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProvider::AppendFiltersTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLivingWorldStaticPointProvider", "AppendFiltersTags");

	Params::JunoLivingWorldStaticPointProvider_AppendFiltersTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveLivingWorldStaticPointProvider.GetCaveShellInstanceData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FJunoCaveShellInstanceData*      Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult*    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveLivingWorldStaticPointProvider::GetCaveShellInstanceData(struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveLivingWorldStaticPointProvider", "GetCaveShellInstanceData");

	Params::JunoCaveLivingWorldStaticPointProvider_GetCaveShellInstanceData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Load
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Load()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "Load");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.SetBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extent                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoStreamingGameplayVolume::SetBounds(const struct FVector& Offset, const struct FVector& Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "SetBounds");

	Params::JunoStreamingGameplayVolume_SetBounds Parms{};

	Parms.Offset = std::move(Offset);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Unload
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Unload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "Unload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CalculateCaveShellDistance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoCave&                 Cave                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName                       ShellID_A                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ShellID_B                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  Distance                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoCalculateCaveDistanceResult*       Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CalculateCaveShellDistance(const struct FJunoCave& Cave, const class FName ShellID_A, const class FName ShellID_B, int32* Distance, EJunoCalculateCaveDistanceResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "CalculateCaveShellDistance");

	Params::JunoCaveBlueprintLibrary_CalculateCaveShellDistance Parms{};

	Parms.Cave = std::move(Cave);
	Parms.ShellID_A = ShellID_A;
	Parms.ShellID_B = ShellID_B;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Distance != nullptr)
		*Distance = Parms.Distance;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateCaveInstanceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FJunoGeneratedCaveShellData>&CaveShellData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCreateCaveResult*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       LayerName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CreateCaveInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result, const class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "CreateCaveInstanceData");

	Params::JunoCaveBlueprintLibrary_CreateCaveInstanceData Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellData = std::move(CaveShellData);
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateCaveInstanceDataForSurfaceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      SurfaceData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FJunoGeneratedCaveShellData>&CaveShellData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCreateCaveResult*                  Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       LayerName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::CreateCaveInstanceDataForSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, const TArray<struct FJunoGeneratedCaveShellData>& CaveShellData, EJunoCreateCaveResult* Result, const class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "CreateCaveInstanceDataForSurfaceData");

	Params::JunoCaveBlueprintLibrary_CreateCaveInstanceDataForSurfaceData Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.SurfaceData = std::move(SurfaceData);
	Parms.CaveShellData = std::move(CaveShellData);
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.CreateExitsUsedMaskFromArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TArray<int32>&                    ExitsUsed                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJunoCaveBlueprintLibrary::CreateExitsUsedMaskFromArray(const TArray<int32>& ExitsUsed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "CreateExitsUsedMaskFromArray");

	Params::JunoCaveBlueprintLibrary_CreateExitsUsedMaskFromArray Parms{};

	Parms.ExitsUsed = std::move(ExitsUsed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.ExitsUsedMaskToArray
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ExitsUsedMask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UJunoCaveBlueprintLibrary::ExitsUsedMaskToArray(int32 ExitsUsedMask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "ExitsUsedMaskToArray");

	Params::JunoCaveBlueprintLibrary_ExitsUsedMaskToArray Parms{};

	Parms.ExitsUsedMask = ExitsUsedMask;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetBestCaveShellFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FJunoCave*                       Cave                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FGuid*                           CaveGuid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            ShellID                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetBestCaveResult*                 Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetBestCaveShellFromArea(const class UObject* WorldContextObject, const struct FBox& Area, struct FJunoCave* Cave, struct FGuid* CaveGuid, class FName* ShellID, EJunoGetBestCaveResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetBestCaveShellFromArea");

	Params::JunoCaveBlueprintLibrary_GetBestCaveShellFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Cave != nullptr)
		*Cave = std::move(Parms.Cave);

	if (CaveGuid != nullptr)
		*CaveGuid = std::move(Parms.CaveGuid);

	if (ShellID != nullptr)
		*ShellID = Parms.ShellID;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveDataCollectionsFromRegistry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataRegistryType&         DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UJunoCaveDataCollectionBase>>*Array                                                  (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// EJunoGetCaveDataCollectionsFromRegistryResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveDataCollectionsFromRegistry(const struct FDataRegistryType& DataRegistry, TArray<TSoftObjectPtr<class UJunoCaveDataCollectionBase>>* Array, EJunoGetCaveDataCollectionsFromRegistryResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveDataCollectionsFromRegistry");

	Params::JunoCaveBlueprintLibrary_GetCaveDataCollectionsFromRegistry Parms{};

	Parms.DataRegistry = std::move(DataRegistry);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Array != nullptr)
		*Array = std::move(Parms.Array);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellGateActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     ActorInShell                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>*                  GateActors                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveShellGateActors(const class AActor* ActorInShell, TArray<class AActor*>* GateActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveShellGateActors");

	Params::JunoCaveBlueprintLibrary_GetCaveShellGateActors Parms{};

	Parms.ActorInShell = ActorInShell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (GateActors != nullptr)
		*GateActors = std::move(Parms.GateActors);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     CaveShellChildActor                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoCaveShellInstanceData UJunoCaveBlueprintLibrary::GetCaveShellInstanceData(const class AActor* CaveShellChildActor, class FName ShellID, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveShellInstanceData");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceData Parms{};

	Parms.CaveShellChildActor = CaveShellChildActor;
	Parms.ShellID = ShellID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceDataFromActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveShellChildActor                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData*      Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult*    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveShellInstanceDataFromActor(const class AActor* CaveShellChildActor, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveShellInstanceDataFromActor");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceDataFromActor Parms{};

	Parms.CaveShellChildActor = CaveShellChildActor;
	Parms.ShellID = ShellID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellInstanceDataFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveShellInstanceData*      Data                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoGetCaveShellInstanceDataResult*    Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveShellInstanceDataFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID, struct FJunoCaveShellInstanceData* Data, EJunoGetCaveShellInstanceDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveShellInstanceDataFromArea");

	Params::JunoCaveBlueprintLibrary_GetCaveShellInstanceDataFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);
	Parms.ShellID = ShellID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Data != nullptr)
		*Data = std::move(Parms.Data);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveShellVolumeFromArea
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Area                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class FName                             ShellID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AJunoCaveShellGameplayVolume*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoCaveShellGameplayVolume* UJunoCaveBlueprintLibrary::GetCaveShellVolumeFromArea(const class UObject* WorldContextObject, const struct FBox& Area, class FName ShellID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveShellVolumeFromArea");

	Params::JunoCaveBlueprintLibrary_GetCaveShellVolumeFromArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Area = std::move(Area);
	Parms.ShellID = ShellID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.GetCaveSurfaceDataForEntrance
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     EntranceGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoCaveSurfaceData*            CaveSurfaceData                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// int32*                                  CaveIndex                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetCaveSurfaceDataForEntranceResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWorldTeleporterTransforms                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       LayerName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::GetCaveSurfaceDataForEntrance(const class AActor* Actor, const struct FGuid& EntranceGuid, struct FJunoCaveSurfaceData* CaveSurfaceData, int32* CaveIndex, EJunoGetCaveSurfaceDataForEntranceResult* Result, bool bWorldTeleporterTransforms, const class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "GetCaveSurfaceDataForEntrance");

	Params::JunoCaveBlueprintLibrary_GetCaveSurfaceDataForEntrance Parms{};

	Parms.Actor = Actor;
	Parms.EntranceGuid = std::move(EntranceGuid);
	Parms.bWorldTeleporterTransforms = bWorldTeleporterTransforms;
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CaveSurfaceData != nullptr)
		*CaveSurfaceData = std::move(Parms.CaveSurfaceData);

	if (CaveIndex != nullptr)
		*CaveIndex = Parms.CaveIndex;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.IsBitSet
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   BitMask                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Bit                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveBlueprintLibrary::IsBitSet(int32 BitMask, int32 Bit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "IsBitSet");

	Params::JunoCaveBlueprintLibrary_IsBitSet Parms{};

	Parms.BitMask = BitMask;
	Parms.Bit = Bit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.NeedsCaveShellInstanceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoCaveBlueprintLibrary::NeedsCaveShellInstanceData(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "NeedsCaveShellInstanceData");

	Params::JunoCaveBlueprintLibrary_NeedsCaveShellInstanceData Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveDataStateFromActor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult*               Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveTeleporterLink>* Teleporters                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveDataStateFromActor(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "QueryCaveDataStateFromActor");

	Params::JunoCaveBlueprintLibrary_QueryCaveDataStateFromActor Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);

	if (Teleporters != nullptr)
		*Teleporters = std::move(Parms.Teleporters);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveDataStateFromSurfaceData
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoCaveSurfaceData&      SurfaceData                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult*               Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoCaveTeleporterLink>* Teleporters                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveDataStateFromSurfaceData(const class AActor* POISlotActor, const struct FJunoCaveSurfaceData& SurfaceData, EJunoQueryCaveDataResult* Result, struct FBox* WorldTileBounds, TArray<struct FJunoCaveTeleporterLink>* Teleporters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "QueryCaveDataStateFromSurfaceData");

	Params::JunoCaveBlueprintLibrary_QueryCaveDataStateFromSurfaceData Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.SurfaceData = std::move(SurfaceData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);

	if (Teleporters != nullptr)
		*Teleporters = std::move(Parms.Teleporters);
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveShellInstanceDataState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveDataResult                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EJunoQueryCaveDataResult UJunoCaveBlueprintLibrary::QueryCaveShellInstanceDataState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "QueryCaveShellInstanceDataState");

	Params::JunoCaveBlueprintLibrary_QueryCaveShellInstanceDataState Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.QueryCaveSurfaceDataState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoQueryCaveSurfaceDataStateResult*   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       LayerName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::QueryCaveSurfaceDataState(const class AActor* Actor, EJunoQueryCaveSurfaceDataStateResult* Result, const class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "QueryCaveSurfaceDataState");

	Params::JunoCaveBlueprintLibrary_QueryCaveSurfaceDataState Parms{};

	Parms.Actor = Actor;
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.SetCaveShellGateActors
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     ActorInShell                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ShellID                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            GateActors                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::SetCaveShellGateActors(const class AActor* ActorInShell, const class FName& ShellID, const TArray<class AActor*>& GateActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "SetCaveShellGateActors");

	Params::JunoCaveBlueprintLibrary_SetCaveShellGateActors Parms{};

	Parms.ActorInShell = ActorInShell;
	Parms.ShellID = ShellID;
	Parms.GateActors = std::move(GateActors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveBlueprintLibrary.SetCaveSurfaceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FJunoCaveSurfaceData>&CaveSurfaceData                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName                       LayerName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveBlueprintLibrary::SetCaveSurfaceData(const class AActor* Actor, const TArray<struct FJunoCaveSurfaceData>& CaveSurfaceData, const class FName LayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoCaveBlueprintLibrary", "SetCaveSurfaceData");

	Params::JunoCaveBlueprintLibrary_SetCaveSurfaceData Parms{};

	Parms.Actor = Actor;
	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.LayerName = LayerName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.NotifyActorBeginOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::NotifyActorBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolumePlayspaceComponent", "NotifyActorBeginOverlap");

	Params::JunoCaveVolumePlayspaceComponent_NotifyActorBeginOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.NotifyActorEndOverlap
// (Final, Native, Private)
// Parameters:
// class AActor*                           OverlappedActor                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::NotifyActorEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolumePlayspaceComponent", "NotifyActorEndOverlap");

	Params::JunoCaveVolumePlayspaceComponent_NotifyActorEndOverlap Parms{};

	Parms.OverlappedActor = OverlappedActor;
	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.OnPlayerEnteringCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolumePlayspaceComponent", "OnPlayerEnteringCaveVolume");

	Params::JunoCaveVolumePlayspaceComponent_OnPlayerEnteringCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolumePlayspaceComponent.OnPlayerLeavingCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCaveVolumePlayspaceComponent::OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolumePlayspaceComponent", "OnPlayerLeavingCaveVolume");

	Params::JunoCaveVolumePlayspaceComponent_OnPlayerLeavingCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoDumpMapTileImages
// (Final, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoDumpMapTileImages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoDumpMapTileImages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoActor
// (Final, Exec, Native, Private)
// Parameters:
// const class FString&                    ActorClassName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoActor(const class FString& ActorClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoGoActor");

	Params::JunoCheatManager_ProceduralWorld_JunoGoActor Parms{};

	Parms.ActorClassName = std::move(ActorClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoBiome
// (Final, Exec, Native, Private)
// Parameters:
// class FName                             Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoBiome(class FName Biome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoGoBiome");

	Params::JunoCheatManager_ProceduralWorld_JunoGoBiome Parms{};

	Parms.Biome = Biome;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoEvent
// (Final, Exec, Native, Private)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoEvent(class FName EventName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoGoEvent");

	Params::JunoCheatManager_ProceduralWorld_JunoGoEvent Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoNearActor
// (Final, Exec, Native, Private)
// Parameters:
// const class FString&                    ActorClassName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoNearActor(const class FString& ActorClassName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoGoNearActor");

	Params::JunoCheatManager_ProceduralWorld_JunoGoNearActor Parms{};

	Parms.ActorClassName = std::move(ActorClassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoGoPOI
// (Final, Exec, Native, Private)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoGoPOI(class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoGoPOI");

	Params::JunoCheatManager_ProceduralWorld_JunoGoPOI Parms{};

	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoLogStreamingVolumesDebugInfo
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoLogStreamingVolumesDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoLogStreamingVolumesDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoMarkWorldTilePersistenceDirty
// (Final, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoMarkWorldTilePersistenceDirty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoMarkWorldTilePersistenceDirty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoPOIVolumeDump
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoPOIVolumeDump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoPOIVolumeDump");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoPOIVolumeDumpAll
// (Final, BlueprintAuthorityOnly, Exec, Native, Private)

void UJunoCheatManager_ProceduralWorld::JunoPOIVolumeDumpAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoPOIVolumeDumpAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCheatManager_ProceduralWorld.JunoSaveProfileGoBiomeGridScenario
// (Final, Exec, Native, Private)
// Parameters:
// const class FString&                    DestFilePath                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoCheatManager_ProceduralWorld::JunoSaveProfileGoBiomeGridScenario(const class FString& DestFilePath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCheatManager_ProceduralWorld", "JunoSaveProfileGoBiomeGridScenario");

	Params::JunoCheatManager_ProceduralWorld_JunoSaveProfileGoBiomeGridScenario Parms{};

	Parms.DestFilePath = std::move(DestFilePath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoGenerateTileInterface.GenerateTile
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FJunoGenerateTileParams&   Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void IJunoGenerateTileInterface::GenerateTile(const struct FJunoGenerateTileParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("JunoGenerateTileInterface", "GenerateTile");

	Params::JunoGenerateTileInterface_GenerateTile Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoGenerateTileCommandlet.FinishedGenerating
// (Final, Native, Public, BlueprintCallable)

void UJunoGenerateTileCommandlet::FinishedGenerating()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoGenerateTileCommandlet", "FinishedGenerating");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoInstancedActorData.GetJunoManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AJunoInstancedActorManager*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoInstancedActorManager* UJunoInstancedActorData::GetJunoManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoInstancedActorData", "GetJunoManager");

	Params::JunoInstancedActorData_GetJunoManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.ApplyCurrentPhaseOverrides
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UJunoLifecycleComponent::ApplyCurrentPhaseOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "ApplyCurrentPhaseOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.OnRep_CurrentPhaseIndex
// (Final, Native, Protected)
// Parameters:
// uint8                                   PreviousLifecyclePhaseIndex                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoLifecycleComponent::OnRep_CurrentPhaseIndex(uint8 PreviousLifecyclePhaseIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "OnRep_CurrentPhaseIndex");

	Params::JunoLifecycleComponent_OnRep_CurrentPhaseIndex Parms{};

	Parms.PreviousLifecyclePhaseIndex = PreviousLifecyclePhaseIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.SetCurrentPhaseByIndex
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewCurrentPhaseIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeElapsedInNewPhase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::SetCurrentPhaseByIndex(uint8 NewCurrentPhaseIndex, float TimeElapsedInNewPhase, bool bUpdateMass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "SetCurrentPhaseByIndex");

	Params::JunoLifecycleComponent_SetCurrentPhaseByIndex Parms{};

	Parms.NewCurrentPhaseIndex = NewCurrentPhaseIndex;
	Parms.TimeElapsedInNewPhase = TimeElapsedInNewPhase;
	Parms.bUpdateMass = bUpdateMass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.BP_GetCurrentPhase
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FJunoLifecyclePhase*             OutCurrentPhase                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::BP_GetCurrentPhase(struct FJunoLifecyclePhase* OutCurrentPhase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "BP_GetCurrentPhase");

	Params::JunoLifecycleComponent_BP_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCurrentPhase != nullptr)
		*OutCurrentPhase = std::move(Parms.OutCurrentPhase);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseIndex
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UJunoLifecycleComponent::GetCurrentPhaseIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "GetCurrentPhaseIndex");

	Params::JunoLifecycleComponent_GetCurrentPhaseIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseTimeElapsed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJunoLifecycleComponent::GetCurrentPhaseTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "GetCurrentPhaseTimeElapsed");

	Params::JunoLifecycleComponent_GetCurrentPhaseTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.HasCompletedLifecycle
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::HasCompletedLifecycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "HasCompletedLifecycle");

	Params::JunoLifecycleComponent_HasCompletedLifecycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoMinimapGenerator.CreatePackageAndSaveTexture2D
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UTextureRenderTarget2D*           RenderTarget                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PackageName                                            (ConstParm, Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPackage*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPackage* AJunoMinimapGenerator::CreatePackageAndSaveTexture2D(class UTextureRenderTarget2D* RenderTarget, const class FString& PackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoMinimapGenerator", "CreatePackageAndSaveTexture2D");

	Params::JunoMinimapGenerator_CreatePackageAndSaveTexture2D Parms{};

	Parms.RenderTarget = RenderTarget;
	Parms.PackageName = std::move(PackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.CalcCompressedObjectCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AJunoPCGVolume::CalcCompressedObjectCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPCGVolume", "CalcCompressedObjectCount");

	Params::JunoPCGVolume_CalcCompressedObjectCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.CalculateCompressedDataSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AJunoPCGVolume::CalculateCompressedDataSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPCGVolume", "CalculateCompressedDataSize");

	Params::JunoPCGVolume_CalculateCompressedDataSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.IsGeneratorBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoPCGVolume::IsGeneratorBusy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPCGVolume", "IsGeneratorBusy");

	Params::JunoPCGVolume_IsGeneratorBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPCGVolume.IsSpawnerBusy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoPCGVolume::IsSpawnerBusy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPCGVolume", "IsSpawnerBusy");

	Params::JunoPCGVolume_IsSpawnerBusy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.BeginPreselection
// (Final, Native, Public, BlueprintCallable)

void UJunoPOIPreselectorComponent::BeginPreselection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOIPreselectorComponent", "BeginPreselection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.OnWorldTileContentsAvailable
// (Final, Native, Protected)

void UJunoPOIPreselectorComponent::OnWorldTileContentsAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOIPreselectorComponent", "OnWorldTileContentsAvailable");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.OnWorldTilePersistenceAvailable
// (Final, Native, Protected)
// Parameters:
// class AJunoPersistentPlayspace*         PersistentPlayspace                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bSuccess                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIPreselectorComponent::OnWorldTilePersistenceAvailable(class AJunoPersistentPlayspace* PersistentPlayspace, const bool bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOIPreselectorComponent", "OnWorldTilePersistenceAvailable");

	Params::JunoPOIPreselectorComponent_OnWorldTilePersistenceAvailable Parms{};

	Parms.PersistentPlayspace = PersistentPlayspace;
	Parms.bSuccess = bSuccess;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOIPreselectorComponent.OnWorldTileReady
// (Final, Native, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   WorldOwnerStartLocation                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SessionStartLocation                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIPreselectorComponent::OnWorldTileReady(const struct FVector& WorldOwnerStartLocation, const struct FVector& SessionStartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOIPreselectorComponent", "OnWorldTileReady");

	Params::JunoPOIPreselectorComponent_OnWorldTileReady Parms{};

	Parms.WorldOwnerStartLocation = std::move(WorldOwnerStartLocation);
	Parms.SessionStartLocation = std::move(SessionStartLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoCaveGeneratorInterface.GenerateCave
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FJunoCaveSurfaceData&      CaveSurfaceData                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CaveIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IJunoCaveGeneratorInterface::GenerateCave(const struct FJunoCaveSurfaceData& CaveSurfaceData, EJunoBiome Biome, int32 CaveIndex, const struct FBox& Bounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("JunoCaveGeneratorInterface", "GenerateCave");

	Params::JunoCaveGeneratorInterface_GenerateCave Parms{};

	Parms.CaveSurfaceData = std::move(CaveSurfaceData);
	Parms.Biome = Biome;
	Parms.CaveIndex = CaveIndex;
	Parms.Bounds = std::move(Bounds);

	AsUObject()->ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.CaveGridResolution
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UJunoPOISelectorComponent::CaveGridResolution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOISelectorComponent", "CaveGridResolution");

	Params::JunoPOISelectorComponent_CaveGridResolution Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.IsNativePOISelectorEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoPOISelectorComponent::IsNativePOISelectorEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOISelectorComponent", "IsNativePOISelectorEnabled");

	Params::JunoPOISelectorComponent_IsNativePOISelectorEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.IsPOIPreselectorActorReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoPOISelectorComponent::IsPOIPreselectorActorReady(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOISelectorComponent", "IsPOIPreselectorActorReady");

	Params::JunoPOISelectorComponent_IsPOIPreselectorActorReady Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.BeginPOISelection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoPOISelectorParams&    Param_Params_0                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoPOISelectorComponent::BeginPOISelection(const struct FJunoPOISelectorParams& Param_Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOISelectorComponent", "BeginPOISelection");

	Params::JunoPOISelectorComponent_BeginPOISelection Parms{};

	Parms.Param_Params_0 = std::move(Param_Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.DoSelection
// (Final, Native, Protected)

void UJunoPOISelectorComponent::DoSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOISelectorComponent", "DoSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOISelectorComponent.TriggerCaveGeneration
// (Final, Native, Public, BlueprintCallable)

void UJunoPOISelectorComponent::TriggerCaveGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoPOISelectorComponent", "TriggerCaveGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.ApplyLandscapeTileSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       LandscapeTile                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LODBlendRange                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCompressedHeightmapStorage                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDisableRuntimeGrassMapGeneration                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::ApplyLandscapeTileSettings(class ALandscape* LandscapeTile, float LODBlendRange, bool bUseCompressedHeightmapStorage, bool bDisableRuntimeGrassMapGeneration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "ApplyLandscapeTileSettings");

	Params::JunoProceduralWorldBlueprintLibrary_ApplyLandscapeTileSettings Parms{};

	Parms.LandscapeTile = LandscapeTile;
	Parms.LODBlendRange = LODBlendRange;
	Parms.bUseCompressedHeightmapStorage = bUseCompressedHeightmapStorage;
	Parms.bDisableRuntimeGrassMapGeneration = bDisableRuntimeGrassMapGeneration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.ApplyMaterialToLandscape
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscapeProxy*                  Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULandscapeMaterialInstanceConstant*MaterialBase                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::ApplyMaterialToLandscape(class ALandscapeProxy* Landscape, class ULandscapeMaterialInstanceConstant* MaterialBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "ApplyMaterialToLandscape");

	Params::JunoProceduralWorldBlueprintLibrary_ApplyMaterialToLandscape Parms{};

	Parms.Landscape = Landscape;
	Parms.MaterialBase = MaterialBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CalcPOISizeExtent
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EJunoPOISize                            Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UJunoProceduralWorldBlueprintLibrary::CalcPOISizeExtent(EJunoPOISize Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "CalcPOISizeExtent");

	Params::JunoProceduralWorldBlueprintLibrary_CalcPOISizeExtent Parms{};

	Parms.Size = Size;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CompareTagSets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TSet<class FName>&                Source                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TSet<class FName>&                Target                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoCompareTagSetsResult*              Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::CompareTagSets(const TSet<class FName>& Source, const TSet<class FName>& Target, EJunoCompareTagSetsResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "CompareTagSets");

	Params::JunoProceduralWorldBlueprintLibrary_CompareTagSets Parms{};

	Parms.Source = std::move(Source);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CreateJunoRandomTableKeysIterator
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              Keys                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FJunoRandomTableKeysIterator     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoRandomTableKeysIterator UJunoProceduralWorldBlueprintLibrary::CreateJunoRandomTableKeysIterator(const struct FRandomStream& RandomStream, const TArray<class FName>& Keys)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "CreateJunoRandomTableKeysIterator");

	Params::JunoProceduralWorldBlueprintLibrary_CreateJunoRandomTableKeysIterator Parms{};

	Parms.RandomStream = std::move(RandomStream);
	Parms.Keys = std::move(Keys);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.CreateJunoWPLevelFromActors
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    LevelPackageName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>*           CreatedLevel                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseWorldPartition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GridName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LoadingRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   WorldPartitionGridCellSize                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 WorldPartitionGridCellOrigin                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UHLODLayer*                       DefaultHLODLayer                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldPartitionServerStreamingMode      ServerStreamingMode                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWorldPartitionServerStreamingOutMode   ServerStreamingOutMode                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::CreateJunoWPLevelFromActors(const class FString& LevelPackageName, const TArray<class AActor*>& Actors, TSoftObjectPtr<class UWorld>* CreatedLevel, bool bUseWorldPartition, class FName GridName, float LoadingRange, int32 WorldPartitionGridCellSize, const struct FVector2D& WorldPartitionGridCellOrigin, class UHLODLayer* DefaultHLODLayer, EWorldPartitionServerStreamingMode ServerStreamingMode, EWorldPartitionServerStreamingOutMode ServerStreamingOutMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "CreateJunoWPLevelFromActors");

	Params::JunoProceduralWorldBlueprintLibrary_CreateJunoWPLevelFromActors Parms{};

	Parms.LevelPackageName = std::move(LevelPackageName);
	Parms.Actors = std::move(Actors);
	Parms.bUseWorldPartition = bUseWorldPartition;
	Parms.GridName = GridName;
	Parms.LoadingRange = LoadingRange;
	Parms.WorldPartitionGridCellSize = WorldPartitionGridCellSize;
	Parms.WorldPartitionGridCellOrigin = std::move(WorldPartitionGridCellOrigin);
	Parms.DefaultHLODLayer = DefaultHLODLayer;
	Parms.ServerStreamingMode = ServerStreamingMode;
	Parms.ServerStreamingOutMode = ServerStreamingOutMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CreatedLevel != nullptr)
		*CreatedLevel = Parms.CreatedLevel;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.DeterministicShuffleKeys
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRandomStream&             RandomSource                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class FName>&              Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UJunoProceduralWorldBlueprintLibrary::DeterministicShuffleKeys(const struct FRandomStream& RandomSource, const TArray<class FName>& Array)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "DeterministicShuffleKeys");

	Params::JunoProceduralWorldBlueprintLibrary_DeterministicShuffleKeys Parms{};

	Parms.RandomSource = std::move(RandomSource);
	Parms.Array = std::move(Array);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.DisableLandscapeEditLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::DisableLandscapeEditLayers(class ALandscape* Landscape)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "DisableLandscapeEditLayers");

	Params::JunoProceduralWorldBlueprintLibrary_DisableLandscapeEditLayers Parms{};

	Parms.Landscape = Landscape;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.EnableLandscapeNaniteSkirts
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SkirtDepth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::EnableLandscapeNaniteSkirts(class ALandscape* Landscape, bool bEnable, float SkirtDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "EnableLandscapeNaniteSkirts");

	Params::JunoProceduralWorldBlueprintLibrary_EnableLandscapeNaniteSkirts Parms{};

	Parms.Landscape = Landscape;
	Parms.bEnable = bEnable;
	Parms.SkirtDepth = SkirtDepth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindAllResourcesInFolder
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    Folder                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           AssetClass                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FSoftObjectPath>*         OutPaths                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindAllResourcesInFolder(const class FString& Folder, class UClass* AssetClass, TArray<struct FSoftObjectPath>* OutPaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "FindAllResourcesInFolder");

	Params::JunoProceduralWorldBlueprintLibrary_FindAllResourcesInFolder Parms{};

	Parms.Folder = std::move(Folder);
	Parms.AssetClass = AssetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPaths != nullptr)
		*OutPaths = std::move(Parms.OutPaths);
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindNextMatchingPOIResource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoRandomTableKeysIterator&Iterator                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoPOISize                            SlotPOISize                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class FName>&              SlotTags                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTilePOI*            FoundPOI                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoFindNextMatchingPOIResourceResult* Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveFromIterator                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindNextMatchingPOIResource(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize SlotPOISize, const TArray<class FName>& SlotTags, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result, bool bRemoveFromIterator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "FindNextMatchingPOIResource");

	Params::JunoProceduralWorldBlueprintLibrary_FindNextMatchingPOIResource Parms{};

	Parms.Iterator = std::move(Iterator);
	Parms.DataTable = DataTable;
	Parms.SlotPOISize = SlotPOISize;
	Parms.SlotTags = std::move(SlotTags);
	Parms.bRemoveFromIterator = bRemoveFromIterator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoundPOI != nullptr)
		*FoundPOI = std::move(Parms.FoundPOI);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.FindNextMatchingPOIResourceEx
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoRandomTableKeysIterator&Iterator                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UDataTable*                 DataTable                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoPOISize                            Size                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTilePOI*            FoundPOI                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// EJunoFindNextMatchingPOIResourceResult* Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::FindNextMatchingPOIResourceEx(const struct FJunoRandomTableKeysIterator& Iterator, const class UDataTable* DataTable, EJunoPOISize Size, EJunoBiome Biome, struct FPCGJunoWorldTilePOI* FoundPOI, EJunoFindNextMatchingPOIResourceResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "FindNextMatchingPOIResourceEx");

	Params::JunoProceduralWorldBlueprintLibrary_FindNextMatchingPOIResourceEx Parms{};

	Parms.Iterator = std::move(Iterator);
	Parms.DataTable = DataTable;
	Parms.Size = Size;
	Parms.Biome = Biome;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (FoundPOI != nullptr)
		*FoundPOI = std::move(Parms.FoundPOI);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.GetJunoWorldRegistry
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJunoWorldRegistryManager*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJunoWorldRegistryManager* UJunoProceduralWorldBlueprintLibrary::GetJunoWorldRegistry(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "GetJunoWorldRegistry");

	Params::JunoProceduralWorldBlueprintLibrary_GetJunoWorldRegistry Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.JunoCreateLevel
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoCreateLevelParams&    Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UWorld>*           CreatedLevel                                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoCreateLevelResult*                 Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::JunoCreateLevel(const struct FJunoCreateLevelParams& Params_0, TSoftObjectPtr<class UWorld>* CreatedLevel, EJunoCreateLevelResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "JunoCreateLevel");

	Params::JunoProceduralWorldBlueprintLibrary_JunoCreateLevel Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CreatedLevel != nullptr)
		*CreatedLevel = Parms.CreatedLevel;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.RunParallelCommandlets
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FText&                      DialogueTitle                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<class FString>&            Commands                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   MaxProcesses                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::RunParallelCommandlets(const class FText& DialogueTitle, const TArray<class FString>& Commands, int32 MaxProcesses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "RunParallelCommandlets");

	Params::JunoProceduralWorldBlueprintLibrary_RunParallelCommandlets Parms{};

	Parms.DialogueTitle = std::move(DialogueTitle);
	Parms.Commands = std::move(Commands);
	Parms.MaxProcesses = MaxProcesses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SaveCurrentLevelAs
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    NewPackageName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoProceduralWorldBlueprintLibrary::SaveCurrentLevelAs(const class FString& NewPackageName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "SaveCurrentLevelAs");

	Params::JunoProceduralWorldBlueprintLibrary_SaveCurrentLevelAs Parms{};

	Parms.NewPackageName = std::move(NewPackageName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SetBoxBrushSize
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Volume                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Size                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::SetBoxBrushSize(class AActor* Volume, const struct FVector& Size)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "SetBoxBrushSize");

	Params::JunoProceduralWorldBlueprintLibrary_SetBoxBrushSize Parms{};

	Parms.Volume = Volume;
	Parms.Size = std::move(Size);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SetGridCellSize
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             GridName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CellSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   LoadingRange                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Origin                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::SetGridCellSize(class AActor* WorldContextObject, class FName GridName, float CellSize, float LoadingRange, const struct FVector2D& Origin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "SetGridCellSize");

	Params::JunoProceduralWorldBlueprintLibrary_SetGridCellSize Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GridName = GridName;
	Parms.CellSize = CellSize;
	Parms.LoadingRange = LoadingRange;
	Parms.Origin = std::move(Origin);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.SetNanitePositionPrecision
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ALandscape*                       Landscape                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NanitePrecision                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoProceduralWorldBlueprintLibrary::SetNanitePositionPrecision(class ALandscape* Landscape, int32 NanitePrecision)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "SetNanitePositionPrecision");

	Params::JunoProceduralWorldBlueprintLibrary_SetNanitePositionPrecision Parms{};

	Parms.Landscape = Landscape;
	Parms.NanitePrecision = NanitePrecision;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoProceduralWorldBlueprintLibrary.UnionActorBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            Actors                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox UJunoProceduralWorldBlueprintLibrary::UnionActorBounds(const TArray<class AActor*>& Actors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoProceduralWorldBlueprintLibrary", "UnionActorBounds");

	Params::JunoProceduralWorldBlueprintLibrary_UnionActorBounds Parms{};

	Parms.Actors = std::move(Actors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupAllJunoLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::FixupAllJunoLandscapeWeightmapLayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "FixupAllJunoLandscapeWeightmapLayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupWorldLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::FixupWorldLandscapeWeightmapLayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "FixupWorldLandscapeWeightmapLayers");

	Params::JunoTerrainGenerationSystem_FixupWorldLandscapeWeightmapLayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.ForceSaveForMissingLayers
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::ForceSaveForMissingLayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "ForceSaveForMissingLayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.ValidateSavedTiles
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::ValidateSavedTiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "ValidateSavedTiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GenerateServerPrecachedData
// (Final, Native, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::GenerateServerPrecachedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "GenerateServerPrecachedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnProxyDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnProxyDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnProxyDestroyed");

	Params::JunoTerrainGenerationSystem_OnProxyDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetInterpolatedOceanInformation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutLocationIsOcean                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoTerrainWaterInformation>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FJunoTerrainWaterInformation> UJunoTerrainGenerationSystem::GetInterpolatedOceanInformation(const struct FVector& Location, bool* OutLocationIsOcean) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "GetInterpolatedOceanInformation");

	Params::JunoTerrainGenerationSystem_GetInterpolatedOceanInformation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationIsOcean != nullptr)
		*OutLocationIsOcean = Parms.OutLocationIsOcean;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetInterpolatedWaterInformation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutLocationIsWater                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoTerrainWaterInformation>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FJunoTerrainWaterInformation> UJunoTerrainGenerationSystem::GetInterpolatedWaterInformation(const struct FVector& Location, bool* OutLocationIsWater) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "GetInterpolatedWaterInformation");

	Params::JunoTerrainGenerationSystem_GetInterpolatedWaterInformation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationIsWater != nullptr)
		*OutLocationIsWater = Parms.OutLocationIsWater;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetWaterInformationAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoTerrainWaterInformation     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FJunoTerrainWaterInformation UJunoTerrainGenerationSystem::GetWaterInformationAtLocation(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "GetWaterInformationAtLocation");

	Params::JunoTerrainGenerationSystem_GetWaterInformationAtLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.GetWaterInformationInDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoTerrainWaterInformation     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FJunoTerrainWaterInformation UJunoTerrainGenerationSystem::GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "GetWaterInformationInDirection");

	Params::JunoTerrainGenerationSystem_GetWaterInformationInDirection Parms{};

	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoTileSubsystem.HandlePossessedPawnChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::HandlePossessedPawnChanged(class APawn* OldPawn, class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTileSubsystem", "HandlePossessedPawnChanged");

	Params::JunoTileSubsystem_HandlePossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTileSubsystem.OnSpawnPositionSet
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FJunoPlayerSpawnLocationInfo&Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoTileSubsystem::OnSpawnPositionSet(const struct FJunoPlayerSpawnLocationInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTileSubsystem", "OnSpawnPositionSet");

	Params::JunoTileSubsystem_OnSpawnPositionSet Parms{};

	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTransitionCaveEntranceTeleporterComponent.OnWorldTilePreselectionFinished
// (Final, Native, Public)
// Parameters:
// class AJunoWorldTile*                   WorldTile                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTransitionCaveEntranceTeleporterComponent::OnWorldTilePreselectionFinished(class AJunoWorldTile* WorldTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTransitionCaveEntranceTeleporterComponent", "OnWorldTilePreselectionFinished");

	Params::JunoTransitionCaveEntranceTeleporterComponent_OnWorldTilePreselectionFinished Parms{};

	Parms.WorldTile = WorldTile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTransitionCaveExitTeleporterComponent.OnWorldTilePreselectionFinished
// (Final, Native, Public)
// Parameters:
// class AJunoWorldTile*                   WorldTile                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTransitionCaveExitTeleporterComponent::OnWorldTilePreselectionFinished(class AJunoWorldTile* WorldTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTransitionCaveExitTeleporterComponent", "OnWorldTilePreselectionFinished");

	Params::JunoTransitionCaveExitTeleporterComponent_OnWorldTilePreselectionFinished Parms{};

	Parms.WorldTile = WorldTile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.ForceWaterUpdate
// (Final, Native, Public, BlueprintCallable)

void UJunoWaterSplineInjector::ForceWaterUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWaterSplineInjector", "ForceWaterUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.InjectSplineGuideIntoWaterBody
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoWaterSplineInjectorParams&Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWaterSplineInjector::InjectSplineGuideIntoWaterBody(const struct FJunoWaterSplineInjectorParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWaterSplineInjector", "InjectSplineGuideIntoWaterBody");

	Params::JunoWaterSplineInjector_InjectSplineGuideIntoWaterBody Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldLocalEnvironmentComponent.OnRep_ServerBiome
// (Final, Native, Private)

void UJunoWorldLocalEnvironmentComponent::OnRep_ServerBiome()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldLocalEnvironmentComponent", "OnRep_ServerBiome");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTile.ArePositionsInSameWorldTile
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationA                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationB                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::ArePositionsInSameWorldTile(class UObject* WorldContextObject, const struct FVector& LocationA, const struct FVector& LocationB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoWorldTile", "ArePositionsInSameWorldTile");

	Params::JunoWorldTile_ArePositionsInSameWorldTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LocationA = std::move(LocationA);
	Parms.LocationB = std::move(LocationB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTile.GetJunoWorldTileBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ActorInWorldTile                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            TileBounds                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EJunoGetWorldTileBoundsResult*          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::GetJunoWorldTileBounds(class AActor* ActorInWorldTile, struct FBox* TileBounds, EJunoGetWorldTileBoundsResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoWorldTile", "GetJunoWorldTileBounds");

	Params::JunoWorldTile_GetJunoWorldTileBounds Parms{};

	Parms.ActorInWorldTile = ActorInWorldTile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TileBounds != nullptr)
		*TileBounds = std::move(Parms.TileBounds);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoWorldTile.GetJunoWorldTileTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           ActorInWorldTile                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      Transform                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoGetWorldTileTransformResult*       Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::GetJunoWorldTileTransform(class AActor* ActorInWorldTile, struct FTransform* Transform, EJunoGetWorldTileTransformResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoWorldTile", "GetJunoWorldTileTransform");

	Params::JunoWorldTile_GetJunoWorldTileTransform Parms{};

	Parms.ActorInWorldTile = ActorInWorldTile;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Transform != nullptr)
		*Transform = std::move(Parms.Transform);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoWorldTile.AddTileInformationTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     InTags                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoWorldTile::AddTileInformationTags(const struct FGameplayTagContainer& InTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "AddTileInformationTags");

	Params::JunoWorldTile_AddTileInformationTags Parms{};

	Parms.InTags = std::move(InTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTile.ClientOnAllLevelsLoaded
// (Final, Native, Private)

void AJunoWorldTile::ClientOnAllLevelsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "ClientOnAllLevelsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTile.OnUnloadBegin
// (Final, Native, Private)
// Parameters:
// class ULevel*                           Level                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoWorldTile::OnUnloadBegin(class ULevel* Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "OnUnloadBegin");

	Params::JunoWorldTile_OnUnloadBegin Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTile.AreWorldTileContentsReady
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::AreWorldTileContentsReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "AreWorldTileContentsReady");

	Params::JunoWorldTile_AreWorldTileContentsReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTile.GetEvent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AJunoWorldTile::GetEvent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "GetEvent");

	Params::JunoWorldTile_GetEvent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTile.IsEventTile
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             EventName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::IsEventTile(class FName EventName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "IsEventTile");

	Params::JunoWorldTile_IsEventTile Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTile.IsTestLevelWorldTile
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoWorldTile::IsTestLevelWorldTile() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTile", "IsTestLevelWorldTile");

	Params::JunoWorldTile_IsTestLevelWorldTile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileControllerComponent.ClientCheckWorldTileState
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const TArray<struct FJunoDebugWorldTileState>&WorldTileState                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWorldTileControllerComponent::ClientCheckWorldTileState(const TArray<struct FJunoDebugWorldTileState>& WorldTileState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileControllerComponent", "ClientCheckWorldTileState");

	Params::JunoWorldTileControllerComponent_ClientCheckWorldTileState Parms{};

	Parms.WorldTileState = std::move(WorldTileState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTileControllerComponent.ServerCheckWorldTileState
// (Net, NetReliable, Native, Event, Public, NetServer)

void UJunoWorldTileControllerComponent::ServerCheckWorldTileState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileControllerComponent", "ServerCheckWorldTileState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseDebugTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseDebugTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "ChooseDebugTile");

	Params::JunoWorldTileSelectionBase_ChooseDebugTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseOutOfBoundsTile
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseOutOfBoundsTile(const class UObject* WorldContextObject, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "ChooseOutOfBoundsTile");

	Params::JunoWorldTileSelectionBase_ChooseOutOfBoundsTile Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseStartTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         StartTileLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::ChooseStartTile(const class UObject* WorldContextObject, struct FVector* StartTileLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "ChooseStartTile");

	Params::JunoWorldTileSelectionBase_ChooseStartTile Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StartTileLocation != nullptr)
		*StartTileLocation = std::move(Parms.StartTileLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ChooseTile
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::ChooseTile(const class UObject* WorldContextObject, const struct FVector& Position, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "ChooseTile");

	Params::JunoWorldTileSelectionBase_ChooseTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.GetDebugLevelLocation
// (RequiredAPI, Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UJunoWorldTileSelectionBase::GetDebugLevelLocation(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "GetDebugLevelLocation");

	Params::JunoWorldTileSelectionBase_GetDebugLevelLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.Setup
// (RequiredAPI, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::Setup(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "Setup");

	Params::JunoWorldTileSelectionBase_Setup Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.SetupForEvents
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PlayerPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>*                    OutEvents                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionBase::SetupForEvents(const class UObject* WorldContextObject, const struct FVector& PlayerPosition, TArray<class FName>* OutEvents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "SetupForEvents");

	Params::JunoWorldTileSelectionBase_SetupForEvents Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerPosition = std::move(PlayerPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutEvents != nullptr)
		*OutEvents = std::move(Parms.OutEvents);
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.UpdateTile
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPCGJunoWorldTile&         CurrentTile                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutUpdatedTile                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::UpdateTile(const class UObject* WorldContextObject, const struct FPCGJunoWorldTile& CurrentTile, struct FPCGJunoWorldTile* OutUpdatedTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "UpdateTile");

	Params::JunoWorldTileSelectionBase_UpdateTile Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CurrentTile = std::move(CurrentTile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUpdatedTile != nullptr)
		*OutUpdatedTile = std::move(Parms.OutUpdatedTile);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.UpdateTileForEvent
// (RequiredAPI, Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      EventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      CellName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FIntVector&                CellCoords                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox2D&                    CellBounds                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutSelectedTile                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::UpdateTileForEvent(const class UObject* WorldContextObject, const class FName& EventName, const class FName& CellName, const struct FIntVector& CellCoords, const struct FBox2D& CellBounds, struct FPCGJunoWorldTile* OutSelectedTile)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "UpdateTileForEvent");

	Params::JunoWorldTileSelectionBase_UpdateTileForEvent Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;
	Parms.CellName = CellName;
	Parms.CellCoords = std::move(CellCoords);
	Parms.CellBounds = std::move(CellBounds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSelectedTile != nullptr)
		*OutSelectedTile = std::move(Parms.OutSelectedTile);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.UseReservedArea
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      AreaName                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<class FName, struct FBox2D>& AreaTiles                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FPCGJunoWorldTile>*       OutNewTiles                                            (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::UseReservedArea(const class UObject* WorldContextObject, const class FName& AreaName, const TMap<class FName, struct FBox2D>& AreaTiles, TArray<struct FPCGJunoWorldTile>* OutNewTiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "UseReservedArea");

	Params::JunoWorldTileSelectionBase_UseReservedArea Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AreaName = AreaName;
	Parms.AreaTiles = std::move(AreaTiles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutNewTiles != nullptr)
		*OutNewTiles = std::move(Parms.OutNewTiles);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.GetEventTileDefinition
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class FName&                      EventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWorldEventTileDefinition*   OutTileEventDefinition                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::GetEventTileDefinition(const class FName& EventName, struct FJunoWorldEventTileDefinition* OutTileEventDefinition) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "GetEventTileDefinition");

	Params::JunoWorldTileSelectionBase_GetEventTileDefinition Parms{};

	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTileEventDefinition != nullptr)
		*OutTileEventDefinition = std::move(Parms.OutTileEventDefinition);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionBase.ModifyTileInformation
// (RequiredAPI, Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPCGJunoWorldTile&         CurrentTile                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FPCGJunoWorldTile*               OutTile                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldTileSelectionBase::ModifyTileInformation(const class UObject* WorldContextObject, const struct FPCGJunoWorldTile& CurrentTile, struct FPCGJunoWorldTile* OutTile) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionBase", "ModifyTileInformation");

	Params::JunoWorldTileSelectionBase_ModifyTileInformation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CurrentTile = std::move(CurrentTile);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTile != nullptr)
		*OutTile = std::move(Parms.OutTile);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldTileSelectionAgatha.GenerateCornersForUI
// (Final, RequiredAPI, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EJunoBiome>*                     Corners                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoWorldTileSelectionAgatha::GenerateCornersForUI(const class UObject* WorldContextObject, TArray<EJunoBiome>* Corners)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldTileSelectionAgatha", "GenerateCornersForUI");

	Params::JunoWorldTileSelectionAgatha_GenerateCornersForUI Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Corners != nullptr)
		*Corners = std::move(Parms.Corners);
}


// Function JunoProceduralWorld.JunoWorldWeatherLocationComponent.HandleEnvironmentChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoBiomeInfoQueryResult& PreviousEnvironmentResult                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FJunoBiomeInfoQueryResult& NewEnvironmentResult                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWorldWeatherLocationComponent::HandleEnvironmentChanged(const class AActor* Actor, const struct FJunoBiomeInfoQueryResult& PreviousEnvironmentResult, const struct FJunoBiomeInfoQueryResult& NewEnvironmentResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldWeatherLocationComponent", "HandleEnvironmentChanged");

	Params::JunoWorldWeatherLocationComponent_HandleEnvironmentChanged Parms{};

	Parms.Actor = Actor;
	Parms.PreviousEnvironmentResult = std::move(PreviousEnvironmentResult);
	Parms.NewEnvironmentResult = std::move(NewEnvironmentResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.AdditionalPushFrontierResultCondition
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EPushFrontierResult                     ResultFromLastPush                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  InCurrentRules                                         (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   InHome                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDestination                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InCurrentLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCurrentPushSteps                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentCost                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bShouldUseBestNodeInsteadOfMostRecentNode              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::AdditionalPushFrontierResultCondition(EPushFrontierResult ResultFromLastPush, const struct FLandmassPathfinderRules& InCurrentRules, const struct FVector& InHome, const struct FVector& InDestination, const struct FVector& InCurrentLocation, int32 InCurrentPushSteps, float InCurrentCost, bool* bShouldUseBestNodeInsteadOfMostRecentNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "AdditionalPushFrontierResultCondition");

	Params::LandmassPathfinder_AdditionalPushFrontierResultCondition Parms{};

	Parms.ResultFromLastPush = ResultFromLastPush;
	Parms.InCurrentRules = std::move(InCurrentRules);
	Parms.InHome = std::move(InHome);
	Parms.InDestination = std::move(InDestination);
	Parms.InCurrentLocation = std::move(InCurrentLocation);
	Parms.InCurrentPushSteps = InCurrentPushSteps;
	Parms.InCurrentCost = InCurrentCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bShouldUseBestNodeInsteadOfMostRecentNode != nullptr)
		*bShouldUseBestNodeInsteadOfMostRecentNode = Parms.bShouldUseBestNodeInsteadOfMostRecentNode;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ExecutePathfinderSync
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::ExecutePathfinderSync(const struct FVector& A, const struct FVector& B, TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "ExecutePathfinderSync");

	Params::LandmassPathfinder_ExecutePathfinderSync Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.FindNearestValidLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldProject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::FindNearestValidLocation(const struct FVector& InLocation, struct FVector* OutValidLocation, bool bShouldProject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "FindNearestValidLocation");

	Params::LandmassPathfinder_FindNearestValidLocation Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.bShouldProject = bShouldProject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValidLocation != nullptr)
		*OutValidLocation = std::move(Parms.OutValidLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy_0                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  Rules                                                  (Parm, NativeAccessSpecifierPublic)
// const TArray<class ULandmassPathfinder*>&InBackStopPaths                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::Initialize(class ALandscapeProxy* LandscapeProxy_0, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, const TArray<class ULandmassPathfinder*>& InBackStopPaths, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "Initialize");

	Params::LandmassPathfinder_Initialize Parms{};

	Parms.LandscapeProxy_0 = LandscapeProxy_0;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBackStopPaths = std::move(InBackStopPaths);
	Parms.InBlockingRoute = InBlockingRoute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.IsTargetLocationValid
// (Native, Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::IsTargetLocationValid(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "IsTargetLocationValid");

	Params::LandmassPathfinder_IsTargetLocationValid Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_GetPriorityList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::K2_GetPriorityList(TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "K2_GetPriorityList");

	Params::LandmassPathfinder_K2_GetPriorityList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_StepPathfinder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 OutLocations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          OutCosts                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>*                           bOutIsSnapped                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<EPathfinderNodeState>*           OutNodeStates                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::K2_StepPathfinder(TArray<struct FVector>* OutLocations, TArray<float>* OutCosts, TArray<bool>* bOutIsSnapped, TArray<EPathfinderNodeState>* OutNodeStates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "K2_StepPathfinder");

	Params::LandmassPathfinder_K2_StepPathfinder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocations != nullptr)
		*OutLocations = std::move(Parms.OutLocations);

	if (OutCosts != nullptr)
		*OutCosts = std::move(Parms.OutCosts);

	if (bOutIsSnapped != nullptr)
		*bOutIsSnapped = std::move(Parms.bOutIsSnapped);

	if (OutNodeStates != nullptr)
		*OutNodeStates = std::move(Parms.OutNodeStates);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.OnInitialize
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALandscapeProxy*                  InLandscapeProxy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  Rules                                                  (Parm, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnInitialize(class ALandscapeProxy* InLandscapeProxy, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "OnInitialize");

	Params::LandmassPathfinder_OnInitialize Parms{};

	Parms.InLandscapeProxy = InLandscapeProxy;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBlockingRoute = InBlockingRoute;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.OnStartPathfinder
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnStartPathfinder(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "OnStartPathfinder");

	Params::LandmassPathfinder_OnStartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestination
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestination(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "SetDestination");

	Params::LandmassPathfinder_SetDestination Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestinationActuallyReached
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestinationActuallyReached(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "SetDestinationActuallyReached");

	Params::LandmassPathfinder_SetDestinationActuallyReached Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.StartPathfinder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bFindNearestValidLocationForA                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bFindNearestValidLocationForB                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::StartPathfinder(const struct FVector& A, const struct FVector& B, const bool bFindNearestValidLocationForA, const bool bFindNearestValidLocationForB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "StartPathfinder");

	Params::LandmassPathfinder_StartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.bFindNearestValidLocationForA = bFindNearestValidLocationForA;
	Parms.bFindNearestValidLocationForB = bFindNearestValidLocationForB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.GetIsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::GetIsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "GetIsInitialized");

	Params::LandmassPathfinder_GetIsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.GetLandscapeBox
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox ULandmassPathfinder::GetLandscapeBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "GetLandscapeBox");

	Params::LandmassPathfinder_GetLandscapeBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ProjectLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsValidLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassPathfinder::ProjectLocation(const struct FVector& Location, bool* bOutIsValidLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "ProjectLocation");

	Params::LandmassPathfinder_ProjectLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsValidLocation != nullptr)
		*bOutIsValidLocation = Parms.bOutIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.LoadCurveSetAndAddSplineComponentsToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPathfinderGuideSetsDataAsset::LoadCurveSetAndAddSplineComponentsToActor(class AActor* InActor, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "LoadCurveSetAndAddSplineComponentsToActor");

	Params::PathfinderGuideSetsDataAsset_LoadCurveSetAndAddSplineComponentsToActor Parms{};

	Parms.InActor = InActor;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.SaveCurveSetFromSplintComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class USplineComponent*>&  SourceComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPathfinderGuideSetsDataAsset::SaveCurveSetFromSplintComponents(const TArray<class USplineComponent*>& SourceComponents, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "SaveCurveSetFromSplintComponents");

	Params::PathfinderGuideSetsDataAsset_SaveCurveSetFromSplintComponents Parms{};

	Parms.SourceComponents = std::move(SourceComponents);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "GetRandomGuideSet");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSetFromSeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSetFromSeed(int32 Seed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "GetRandomGuideSetFromSeed");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSetFromSeed Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoCaveVolume.OnPlayerEnteringCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveVolume::OnPlayerEnteringCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolume", "OnPlayerEnteringCaveVolume");

	Params::JunoCaveVolume_OnPlayerEnteringCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolume.OnPlayerLeavingCaveVolume
// (Event, Public, BlueprintEvent)
// Parameters:
// class AFortPlayerPawnAthena*            PlayerPawn                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoCaveVolume::OnPlayerLeavingCaveVolume(class AFortPlayerPawnAthena* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolume", "OnPlayerLeavingCaveVolume");

	Params::JunoCaveVolume_OnPlayerLeavingCaveVolume Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.JunoCaveVolume.RetrievePointProviders
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<class AJunoCaveLivingWorldStaticPointProvider*>*OutPointProviders                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void AJunoCaveVolume::RetrievePointProviders(TArray<class AJunoCaveLivingWorldStaticPointProvider*>* OutPointProviders)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoCaveVolume", "RetrievePointProviders");

	Params::JunoCaveVolume_RetrievePointProviders Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPointProviders != nullptr)
		*OutPointProviders = std::move(Parms.OutPointProviders);
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProviderCluster.AppendGlobalTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProviderCluster::AppendGlobalTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLivingWorldStaticPointProviderCluster", "AppendGlobalTags");

	Params::JunoLivingWorldStaticPointProviderCluster_AppendGlobalTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProviderCluster.OnCurrentPlaylistLoaded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             PlaylistName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     PlaylistContextTags                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProviderCluster::OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLivingWorldStaticPointProviderCluster", "OnCurrentPlaylistLoaded");

	Params::JunoLivingWorldStaticPointProviderCluster_OnCurrentPlaylistLoaded Parms{};

	Parms.PlaylistName = PlaylistName;
	Parms.PlaylistContextTags = std::move(PlaylistContextTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateCavePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoPOIData&              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateCavePOI(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreateCavePOI");

	Params::JunoPOIBlueprintLibrary_CreateCavePOI Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreatePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoPOIData&              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreatePOI(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreatePOI");

	Params::JunoPOIBlueprintLibrary_CreatePOI Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateRarePOIs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>&     PotentialSlots                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     UsedSlots                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateRarePOIs(const class AActor* Actor, const struct FRandomStream& RandomStream, const struct FDataRegistryType& DataRegistry, TArray<struct FJunoPOIManagerSlot>& PotentialSlots, TArray<struct FJunoPOIManagerSlot>* UsedSlots, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreateRarePOIs");

	Params::JunoPOIBlueprintLibrary_CreateRarePOIs Parms{};

	Parms.Actor = Actor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.DataRegistry = std::move(DataRegistry);
	Parms.PotentialSlots = std::move(PotentialSlots);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PotentialSlots = std::move(Parms.PotentialSlots);

	if (UsedSlots != nullptr)
		*UsedSlots = std::move(Parms.UsedSlots);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.FindBestPOISlots
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FJunoPOIManagerSlot>&PotentialSlots                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FJunoPOIManagerSlot>&AdditionalCompareSlots                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DesiredNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  DesiredMinDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     Remainder                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FBox&                      WorldTileBounds                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnforceMinDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::FindBestPOISlots(const TArray<struct FJunoPOIManagerSlot>& PotentialSlots, const TArray<struct FJunoPOIManagerSlot>& AdditionalCompareSlots, int32 DesiredNumber, double DesiredMinDistance, TArray<struct FJunoPOIManagerSlot>* Result, TArray<struct FJunoPOIManagerSlot>* Remainder, const struct FBox& WorldTileBounds, EJunoBiome Biome, bool bEnforceMinDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "FindBestPOISlots");

	Params::JunoPOIBlueprintLibrary_FindBestPOISlots Parms{};

	Parms.PotentialSlots = std::move(PotentialSlots);
	Parms.AdditionalCompareSlots = std::move(AdditionalCompareSlots);
	Parms.DesiredNumber = DesiredNumber;
	Parms.DesiredMinDistance = DesiredMinDistance;
	Parms.WorldTileBounds = std::move(WorldTileBounds);
	Parms.Biome = Biome;
	Parms.bEnforceMinDistance = bEnforceMinDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Remainder != nullptr)
		*Remainder = std::move(Parms.Remainder);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.GetMatchingPOIsFromDataRegistry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataRegistryType&         DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class FName>&                Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TSet<EJunoPOISize>&               Sizes                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TSet<EJunoBiome>&                 Biomes                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FPCGJunoWorldTilePOI>&Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoGetMatchingPOIsFromDataRegistryResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoWorldTilePOIType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::GetMatchingPOIsFromDataRegistry(const struct FDataRegistryType& DataRegistry, const TSet<class FName>& Tags, const TSet<EJunoPOISize>& Sizes, const TSet<EJunoBiome>& Biomes, const TArray<struct FPCGJunoWorldTilePOI>& Array, EJunoGetMatchingPOIsFromDataRegistryResult* Result, EJunoWorldTilePOIType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "GetMatchingPOIsFromDataRegistry");

	Params::JunoPOIBlueprintLibrary_GetMatchingPOIsFromDataRegistry Parms{};

	Parms.DataRegistry = std::move(DataRegistry);
	Parms.Tags = std::move(Tags);
	Parms.Sizes = std::move(Sizes);
	Parms.Biomes = std::move(Biomes);
	Parms.Array = std::move(Array);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkCavePOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkCavePOISlotUnused(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "MarkCavePOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkCavePOISlotUnused Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkPOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkPOISlotUnused(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "MarkPOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkPOISlotUnused Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryCavePOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryCavePOIState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EQueryPOIStateResult* Result, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "QueryCavePOIState");

	Params::JunoPOIBlueprintLibrary_QueryCavePOIState Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryPOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoPOISlotMetaData*            POISlotMetaData                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryPOIState(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EQueryPOIStateResult* Result, struct FJunoPOISlotMetaData* POISlotMetaData, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "QueryPOIState");

	Params::JunoPOIBlueprintLibrary_QueryPOIState Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (POISlotMetaData != nullptr)
		*POISlotMetaData = std::move(Parms.POISlotMetaData);

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.SetPOISlotMetaDatas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FJunoPOIManagerSlot>&POISlots                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FJunoPOISlotMetaData&      POISlotMetaData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EJunoSetSlotPOIMetaDataResult*          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::SetPOISlotMetaDatas(const class AActor* POISlotActor, const TArray<struct FJunoPOIManagerSlot>& POISlots, const struct FJunoPOISlotMetaData& POISlotMetaData, EJunoSetSlotPOIMetaDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "SetPOISlotMetaDatas");

	Params::JunoPOIBlueprintLibrary_SetPOISlotMetaDatas Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlots = std::move(POISlots);
	Parms.POISlotMetaData = std::move(POISlotMetaData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoProceduralFoundation.AddAdditionalWorld
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>&           World                                                  (Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoProceduralFoundation::AddAdditionalWorld(TSoftObjectPtr<class UWorld>& World)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoProceduralFoundation", "AddAdditionalWorld");

	Params::JunoProceduralFoundation_AddAdditionalWorld Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	World = Parms.World;
}


// Function JunoProceduralWorld.JunoRoadAINavigationCluster.ChangePatrolToFollow
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AAIController*              Controller                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AFortAthenaPatrolPath*            PatrolPath                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AFortAthenaPatrolPoint*     FirstPatrolPoint                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJunoRoadAINavigationCluster::ChangePatrolToFollow(const class AAIController* Controller, class AFortAthenaPatrolPath* PatrolPath, const class AFortAthenaPatrolPoint* FirstPatrolPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoRoadAINavigationCluster", "ChangePatrolToFollow");

	Params::JunoRoadAINavigationCluster_ChangePatrolToFollow Parms{};

	Parms.Controller = Controller;
	Parms.PatrolPath = PatrolPath;
	Parms.FirstPatrolPoint = FirstPatrolPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoRoadAINavigationCluster.FindConnectedPatrolPaths
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AFortAthenaPatrolPoint*     PatrolPoint                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AFortAthenaPatrolPath*      PatrolPathToExclude                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AFortAthenaPatrolPath*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AFortAthenaPatrolPath*> AJunoRoadAINavigationCluster::FindConnectedPatrolPaths(const class AFortAthenaPatrolPoint* PatrolPoint, const class AFortAthenaPatrolPath* PatrolPathToExclude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoRoadAINavigationCluster", "FindConnectedPatrolPaths");

	Params::JunoRoadAINavigationCluster_FindConnectedPatrolPaths Parms{};

	Parms.PatrolPoint = PatrolPoint;
	Parms.PatrolPathToExclude = PatrolPathToExclude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoRoadAINavigationCluster.AppendGlobalTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoRoadAINavigationCluster::AppendGlobalTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoRoadAINavigationCluster", "AppendGlobalTags");

	Params::JunoRoadAINavigationCluster_AppendGlobalTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoRoadAINavigationCluster.OnCurrentPlaylistLoaded
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             PlaylistName                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     PlaylistContextTags                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoRoadAINavigationCluster::OnCurrentPlaylistLoaded(class FName PlaylistName, const struct FGameplayTagContainer& PlaylistContextTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoRoadAINavigationCluster", "OnCurrentPlaylistLoaded");

	Params::JunoRoadAINavigationCluster_OnCurrentPlaylistLoaded Parms{};

	Parms.PlaylistName = PlaylistName;
	Parms.PlaylistContextTags = std::move(PlaylistContextTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassCluster.InitializeDentrogram
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramLeafAttributes>&InAttributes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULandmassCluster::InitializeDentrogram(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "InitializeDentrogram");

	Params::LandmassCluster_InitializeDentrogram Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InAttributes = std::move(InAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassCluster.K2_AddConnection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassCluster::K2_AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "K2_AddConnection");

	Params::LandmassCluster_K2_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetClustersAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramClusterOutput>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FDendrogramClusterOutput> ULandmassCluster::GetClustersAtLevel(int32 InLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetClustersAtLevel");

	Params::LandmassCluster_GetClustersAtLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetLeafCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetLeafCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetLeafCount");

	Params::LandmassCluster_GetLeafCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetTopLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetTopLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetTopLevel");

	Params::LandmassCluster_GetTopLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.CreateSplineComponentsFromGuideSetAndAddToActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPathfinderGuideSet&       GuideSet                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassFunctionLibrary::CreateSplineComponentsFromGuideSetAndAddToActor(class AActor* InActor, const struct FPathfinderGuideSet& GuideSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "CreateSplineComponentsFromGuideSetAndAddToActor");

	Params::LandmassFunctionLibrary_CreateSplineComponentsFromGuideSetAndAddToActor Parms{};

	Parms.InActor = InActor;
	Parms.GuideSet = std::move(GuideSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointLayerWidthRatio
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetControlPointLayerWidthRatio");

	Params::LandmassFunctionLibrary_GetControlPointLayerWidthRatio Parms{};

	Parms.InControlPoint = InControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassFunctionLibrary::GetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetControlPointLocation");

	Params::LandmassFunctionLibrary_GetControlPointLocation Parms{};

	Parms.InControlPoint = InControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ULandmassFunctionLibrary::GetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetControlPointRotation");

	Params::LandmassFunctionLibrary_GetControlPointRotation Parms{};

	Parms.InControlPoint = InControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointSideFalloff
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetControlPointSideFalloff");

	Params::LandmassFunctionLibrary_GetControlPointSideFalloff Parms{};

	Parms.InControlPoint = InControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetControlPointWidth
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetControlPointWidth");

	Params::LandmassFunctionLibrary_GetControlPointWidth Parms{};

	Parms.InControlPoint = InControlPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetLandscapeGradientAtLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D ULandmassFunctionLibrary::GetLandscapeGradientAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetLandscapeGradientAtLocation");

	Params::LandmassFunctionLibrary_GetLandscapeGradientAtLocation Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.GetLandscapeHeightAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULandmassFunctionLibrary::GetLandscapeHeightAtLocation(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "GetLandscapeHeightAtLocation");

	Params::LandmassFunctionLibrary_GetLandscapeHeightAtLocation Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsValidLocation != nullptr)
		*bIsValidLocation = Parms.bIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.LevelInstanceSetAndUpdateWorldAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class ALevelInstance*                   LevelInstance                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UWorld>&     WorldAsset                                             (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::LevelInstanceSetAndUpdateWorldAsset(class ALevelInstance* LevelInstance, const TSoftObjectPtr<class UWorld>& WorldAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "LevelInstanceSetAndUpdateWorldAsset");

	Params::LandmassFunctionLibrary_LevelInstanceSetAndUpdateWorldAsset Parms{};

	Parms.LevelInstance = LevelInstance;
	Parms.WorldAsset = WorldAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.ProjectLocationOnLandscape
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bIsValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassFunctionLibrary::ProjectLocationOnLandscape(class ALandscapeProxy* LandscapeProxy, const struct FVector& Location, bool* bIsValidLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "ProjectLocationOnLandscape");

	Params::LandmassFunctionLibrary_ProjectLocationOnLandscape Parms{};

	Parms.LandscapeProxy = LandscapeProxy;
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsValidLocation != nullptr)
		*bIsValidLocation = Parms.bIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointLayerWidthRatio
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLayerWidthRatio                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointLayerWidthRatio(class ULandscapeSplineControlPoint* InControlPoint, float InLayerWidthRatio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetControlPointLayerWidthRatio");

	Params::LandmassFunctionLibrary_SetControlPointLayerWidthRatio Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InLayerWidthRatio = InLayerWidthRatio;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointLocation(class ULandscapeSplineControlPoint* InControlPoint, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetControlPointLocation");

	Params::LandmassFunctionLibrary_SetControlPointLocation Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointRotation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  InRotation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointRotation(class ULandscapeSplineControlPoint* InControlPoint, const struct FRotator& InRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetControlPointRotation");

	Params::LandmassFunctionLibrary_SetControlPointRotation Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InRotation = std::move(InRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointSideFalloff
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InSideFalloff                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointSideFalloff(class ULandscapeSplineControlPoint* InControlPoint, float InSideFalloff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetControlPointSideFalloff");

	Params::LandmassFunctionLibrary_SetControlPointSideFalloff Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InSideFalloff = InSideFalloff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetControlPointWidth
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class ULandscapeSplineControlPoint*     InControlPoint                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InWidth                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetControlPointWidth(class ULandscapeSplineControlPoint* InControlPoint, float InWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetControlPointWidth");

	Params::LandmassFunctionLibrary_SetControlPointWidth Parms{};

	Parms.InControlPoint = InControlPoint;
	Parms.InWidth = InWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassFunctionLibrary.SetStaticMeshAffectDistanceField
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewValue                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassFunctionLibrary::SetStaticMeshAffectDistanceField(class UStaticMeshComponent* Mesh, bool bNewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LandmassFunctionLibrary", "SetStaticMeshAffectDistanceField");

	Params::LandmassFunctionLibrary_SetStaticMeshAffectDistanceField Parms{};

	Parms.Mesh = Mesh;
	Parms.bNewValue = bNewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRouteDefinition.FindLocationClosestToWorldLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutDistanceSqr                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UProceduralRouteDefinition::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, float* OutDistanceSqr) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRouteDefinition", "FindLocationClosestToWorldLocation");

	Params::ProceduralRouteDefinition_FindLocationClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDistanceSqr != nullptr)
		*OutDistanceSqr = Parms.OutDistanceSqr;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddAvoidancePrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRouteAvoidancePrimitive&  InPrimitive                                            (ConstParm, Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::AddAvoidancePrimitive(const struct FRouteAvoidancePrimitive& InPrimitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddAvoidancePrimitive");

	Params::LandmassProceduralRoute_AddAvoidancePrimitive Parms{};

	Parms.InPrimitive = std::move(InPrimitive);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddConnection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddConnection");

	Params::LandmassProceduralRoute_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddControlPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddControlPoint(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddControlPoint");

	Params::LandmassProceduralRoute_AddControlPoint Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.BeginGeneratePCG
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FLandmassPCGRouteInput>&Inputs                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::BeginGeneratePCG(const TArray<struct FLandmassPCGRouteInput>& Inputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "BeginGeneratePCG");

	Params::LandmassProceduralRoute_BeginGeneratePCG Parms{};

	Parms.Inputs = std::move(Inputs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.ClearCreatedLandscapeSplines
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::ClearCreatedLandscapeSplines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "ClearCreatedLandscapeSplines");

	Params::LandmassProceduralRoute_ClearCreatedLandscapeSplines Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.CustomTick
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::CustomTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "CustomTick");

	Params::LandmassProceduralRoute_CustomTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.FinishRoute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32*                                  OutRouteIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::FinishRoute(int32* OutRouteIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "FinishRoute");

	Params::LandmassProceduralRoute_FinishRoute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRouteIndex != nullptr)
		*OutRouteIndex = Parms.OutRouteIndex;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GenerateCluster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::GenerateCluster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GenerateCluster");

	Params::LandmassProceduralRoute_GenerateCluster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassCluster
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramLeafAttributes>&InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassCluster(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "InitLandmassCluster");

	Params::LandmassProceduralRoute_InitLandmassCluster Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InLeafAttributes = std::move(InLeafAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassClusterLeavesOnly
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FDendrogramLeafAttributes>&InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassClusterLeavesOnly(const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "InitLandmassClusterLeavesOnly");

	Params::LandmassProceduralRoute_InitLandmassClusterLeavesOnly Parms{};

	Parms.InLeafAttributes = std::move(InLeafAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.OnGenerationFinished
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::OnGenerationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "OnGenerationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.PutIntoDormancy
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::PutIntoDormancy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "PutIntoDormancy");

	Params::LandmassProceduralRoute_PutIntoDormancy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.RasterizeAllPendingRoutesToRouteGrid
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::RasterizeAllPendingRoutesToRouteGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "RasterizeAllPendingRoutesToRouteGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.ResetAllAndInitialize
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetAllLandscapeSplines                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::ResetAllAndInitialize(bool bResetAllLandscapeSplines)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "ResetAllAndInitialize");

	Params::LandmassProceduralRoute_ResetAllAndInitialize Parms{};

	Parms.bResetAllLandscapeSplines = bResetAllLandscapeSplines;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERouteGenerationState                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetCurrentRouteGenerationState(ERouteGenerationState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_SetCurrentRouteGenerationState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetEditorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetEditorTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetEditorTickEnabled");

	Params::LandmassProceduralRoute_SetEditorTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthAtPointIndex
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthAtPointIndex(int32 Index_0, float NewWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetWidthAtPointIndex");

	Params::LandmassProceduralRoute_SetWidthAtPointIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.NewWidth = NewWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthForLastAddedPoint
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthForLastAddedPoint(float NewWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetWidthForLastAddedPoint");

	Params::LandmassProceduralRoute_SetWidthForLastAddedPoint Parms{};

	Parms.NewWidth = NewWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.StartRoute
// (Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::StartRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "StartRoute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.WakeUpDormantRoute
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::WakeUpDormantRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "WakeUpDormantRoute");

	Params::LandmassProceduralRoute_WakeUpDormantRoute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERouteGenerationState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERouteGenerationState ALandmassProceduralRoute::GetCurrentRouteGenerationState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_GetCurrentRouteGenerationState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetLandmassCluster
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULandmassCluster*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULandmassCluster* ALandmassProceduralRoute::GetLandmassCluster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetLandmassCluster");

	Params::LandmassProceduralRoute_GetLandmassCluster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetRouteDefinitions
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRouteDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRouteDefinition*> ALandmassProceduralRoute::GetRouteDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetRouteDefinitions");

	Params::LandmassProceduralRoute_GetRouteDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideAnyLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideAnyLake(const struct FVector& Location, float Tolerance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideAnyLake");

	Params::LandmassProceduralRoute_IsInsideAnyLake Parms{};

	Parms.Location = std::move(Location);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideAnyLakeAccurate
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideAnyLakeAccurate(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideAnyLakeAccurate");

	Params::LandmassProceduralRoute_IsInsideAnyLakeAccurate Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AWaterBody*                 InLake                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Dilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideLake(const struct FVector& Location, const class AWaterBody* InLake, float Dilation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideLake");

	Params::LandmassProceduralRoute_IsInsideLake Parms{};

	Parms.Location = std::move(Location);
	Parms.InLake = InLake;
	Parms.Dilation = Dilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideOcean
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideOcean(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideOcean");

	Params::LandmassProceduralRoute_IsInsideOcean Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterBodyActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWaterBody*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWaterBody* UProceduralRiverDefinition::GetWaterBodyActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRiverDefinition", "GetWaterBodyActor");

	Params::ProceduralRiverDefinition_GetWaterBodyActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWaterSplineComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaterSplineComponent* UProceduralRiverDefinition::GetWaterSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRiverDefinition", "GetWaterSpline");

	Params::ProceduralRiverDefinition_GetWaterSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAudioIntensityAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetAudioIntensityAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetAudioIntensityAtDistanceAlongSpline");

	Params::ProceduralRivers_GetAudioIntensityAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetDepthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetDepthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetDepthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetDepthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetHalfWidthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetHalfWidthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetHalfWidthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetHalfWidthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetProceduralRiverActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AProceduralRivers::GetProceduralRiverActorTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetProceduralRiverActorTag");

	Params::ProceduralRivers_GetProceduralRiverActorTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetVelocityScalarAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetVelocityScalarAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetVelocityScalarAtDistanceAlongSpline");

	Params::ProceduralRivers_GetVelocityScalarAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetRiverMergeSearchNeighborGridSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetRiverMergeSearchNeighborGridSize");

	Params::ProceduralRivers_GetRiverMergeSearchNeighborGridSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.HaltRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::HaltRiverGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "HaltRiverGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "InitializeNeighborGrid");

	Params::ProceduralRivers_InitializeNeighborGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.RebuildLastRiver
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::RebuildLastRiver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "RebuildLastRiver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.SetRiverTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRiverTier                      InRiverTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRivers::SetRiverTier(ELandmassRiverTier InRiverTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "SetRiverTier");

	Params::ProceduralRivers_SetRiverTier Parms{};

	Parms.InRiverTier = InRiverTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.StartRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::StartRiverGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "StartRiverGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.SurfaceLocationOverride
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsOverriden                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AProceduralRivers::SurfaceLocationOverride(const struct FVector& InLocation, bool* bOutIsOverriden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "SurfaceLocationOverride");

	Params::ProceduralRivers_SurfaceLocationOverride Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (bOutIsOverriden != nullptr)
		*bOutIsOverriden = Parms.bOutIsOverriden;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.VisualizeAnchors
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::VisualizeAnchors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "VisualizeAnchors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableSourceAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableSourceAnchors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetAvailableSourceAnchors");

	Params::ProceduralRivers_GetAvailableSourceAnchors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableTargetAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableTargetAnchors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetAvailableTargetAnchors");

	Params::ProceduralRivers_GetAvailableTargetAnchors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ELandmassRiverTier                InRiverTier                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRiverGenRules*        OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::GetGenerationRules(const ELandmassRiverTier InRiverTier, struct FProceduralRiverGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetGenerationRules");

	Params::ProceduralRivers_GetGenerationRules Parms{};

	Parms.InRiverTier = InRiverTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRiverDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRiverDefinition*> AProceduralRivers::GetRiverDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetRiverDefinitions");

	Params::ProceduralRivers_GetRiverDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.EvaluateRouteAtLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UProceduralRoadDefinition*  InRoute                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformToWorld                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSegmentInterpResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSegmentInterpResult AProceduralRoads::EvaluateRouteAtLength(const class UProceduralRoadDefinition* InRoute, float InLength, bool bTransformToWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "EvaluateRouteAtLength");

	Params::ProceduralRoads_EvaluateRouteAtLength Parms{};

	Parms.InRoute = InRoute;
	Parms.InLength = InLength;
	Parms.bTransformToWorld = bTransformToWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadActorTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "GetProceduralRoadActorTag");

	Params::ProceduralRoads_GetProceduralRoadActorTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadLoopAnchorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   LoopIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadLoopAnchorTag(int32 LoopIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "GetProceduralRoadLoopAnchorTag");

	Params::ProceduralRoads_GetProceduralRoadLoopAnchorTag Parms{};

	Parms.LoopIndex = LoopIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.DisableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)

void AProceduralRoads::DisableOverrideGenRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "DisableOverrideGenRules");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.EnableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FProceduralRoadGenRules&   InOverrideGenRules                                     (Parm, NativeAccessSpecifierPublic)

void AProceduralRoads::EnableOverrideGenRules(const struct FProceduralRoadGenRules& InOverrideGenRules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "EnableOverrideGenRules");

	Params::ProceduralRoads_EnableOverrideGenRules Parms{};

	Parms.InOverrideGenRules = std::move(InOverrideGenRules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.GetAllControlPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ULandscapeSplineControlPoint*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULandscapeSplineControlPoint*> AProceduralRoads::GetAllControlPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetAllControlPoints");

	Params::ProceduralRoads_GetAllControlPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "InitializeNeighborGrid");

	Params::ProceduralRoads_InitializeNeighborGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.K2_GetRoadGridDataAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> AProceduralRoads::K2_GetRoadGridDataAtLocation(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "K2_GetRoadGridDataAtLocation");

	Params::ProceduralRoads_K2_GetRoadGridDataAtLocation Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.RemoveHardTurnControlPoint
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::RemoveHardTurnControlPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "RemoveHardTurnControlPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.SetRoadTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRoadTier                       InRoadTier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRoads::SetRoadTier(ELandmassRoadTier InRoadTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "SetRoadTier");

	Params::ProceduralRoads_SetRoadTier Parms{};

	Parms.InRoadTier = InRoadTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.UpdateLandscapeSplines
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::UpdateLandscapeSplines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "UpdateLandscapeSplines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ELandmassRoadTier                 InRoadTier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRoadGenRules*         OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::GetGenerationRules(const ELandmassRoadTier InRoadTier, struct FProceduralRoadGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetGenerationRules");

	Params::ProceduralRoads_GetGenerationRules Parms{};

	Parms.InRoadTier = InRoadTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRoadDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRoadDefinition*> AProceduralRoads::GetRoadDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetRoadDefinitions");

	Params::ProceduralRoads_GetRoadDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRoads::GetRoadMergeSearchNeighborGridSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetRoadMergeSearchNeighborGridSize");

	Params::ProceduralRoads_GetRoadMergeSearchNeighborGridSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLivingWorldLightStaticPointProvider.AppendFiltersTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoLivingWorldLightStaticPointProvider::AppendFiltersTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLivingWorldLightStaticPointProvider", "AppendFiltersTags");

	Params::JunoLivingWorldLightStaticPointProvider_AppendFiltersTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileForLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AJunoWorldTile*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoWorldTile* UJunoWorldRegistryManager::GetTileForLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoWorldRegistryManager", "GetTileForLocation");

	Params::JunoWorldRegistryManager_GetTileForLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetClosestEntryUsingTagQuery
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// EJunoWorldRegistryType                  EntryType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagQuery&         TagQuery                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   QueryLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWorldRegistryEntry          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FJunoWorldRegistryEntry UJunoWorldRegistryManager::GetClosestEntryUsingTagQuery(EJunoWorldRegistryType EntryType, const struct FGameplayTagQuery& TagQuery, const struct FVector& QueryLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetClosestEntryUsingTagQuery");

	Params::JunoWorldRegistryManager_GetClosestEntryUsingTagQuery Parms{};

	Parms.EntryType = EntryType;
	Parms.TagQuery = std::move(TagQuery);
	Parms.QueryLocation = std::move(QueryLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetBiomeAtLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoBiomeInfoQueryResult*       OutResult                                              (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetBiomeAtLocation(const struct FVector& Location, struct FJunoBiomeInfoQueryResult* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetBiomeAtLocation");

	Params::JunoWorldRegistryManager_GetBiomeAtLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetEventTilesAverageLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      EventName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldRegistryManager::GetEventTilesAverageLocation(const class UObject* WorldContextObject, const class FName& EventName, struct FVector* OutLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetEventTilesAverageLocation");

	Params::JunoWorldRegistryManager_GetEventTilesAverageLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetGlobalPOIs
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoGlobalPOIInfo>*      OutGlobalPOIs                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const class FName                       EventName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       POIName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetGlobalPOIs(const class UObject* WorldContextObject, TArray<struct FJunoGlobalPOIInfo>* OutGlobalPOIs, const class FName EventName, const class FName POIName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetGlobalPOIs");

	Params::JunoWorldRegistryManager_GetGlobalPOIs Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EventName = EventName;
	Parms.POIName = POIName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutGlobalPOIs != nullptr)
		*OutGlobalPOIs = std::move(Parms.OutGlobalPOIs);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetNormalizedTileLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutResult                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoWorldRegistryManager::GetNormalizedTileLocation(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FVector* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetNormalizedTileLocation");

	Params::JunoWorldRegistryManager_GetNormalizedTileLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileAtLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AJunoWorldTile*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoWorldTile* UJunoWorldRegistryManager::GetTileAtLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetTileAtLocation");

	Params::JunoWorldRegistryManager_GetTileAtLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileMiniMapTexture
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UJunoWorldRegistryManager::GetTileMiniMapTexture(const class UObject* WorldContextObject, const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetTileMiniMapTexture");

	Params::JunoWorldRegistryManager_GetTileMiniMapTexture Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetTileTagsForLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UJunoWorldRegistryManager::GetTileTagsForLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetTileTagsForLocation");

	Params::JunoWorldRegistryManager_GetTileTagsForLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWaterDirectionInformationAtLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeNearMisses                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   OutInWater                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoWaterLocationResult>*OutResult                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWaterDirectionInformationAtLocation(const struct FVector& Location, bool bIncludeNearMisses, bool* OutInWater, TArray<struct FJunoWaterLocationResult>* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetWaterDirectionInformationAtLocation");

	Params::JunoWorldRegistryManager_GetWaterDirectionInformationAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.bIncludeNearMisses = bIncludeNearMisses;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInWater != nullptr)
		*OutInWater = Parms.OutInWater;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWaterInformationInDirection
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWaterLocationResult*        OutResult                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWaterInformationInDirection(const struct FVector& Location, const struct FVector& Direction, struct FJunoWaterLocationResult* OutResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetWaterInformationInDirection");

	Params::JunoWorldRegistryManager_GetWaterInformationInDirection Parms{};

	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutResult != nullptr)
		*OutResult = std::move(Parms.OutResult);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldAnalyticsInfo
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoWorldAnalyticsInfoResult*   WorldAnalyticsInfo                                     (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWorldAnalyticsInfo(const class UObject* WorldContextObject, const struct FVector& WorldLocation, struct FJunoWorldAnalyticsInfoResult* WorldAnalyticsInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetWorldAnalyticsInfo");

	Params::JunoWorldRegistryManager_GetWorldAnalyticsInfo Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldAnalyticsInfo != nullptr)
		*WorldAnalyticsInfo = std::move(Parms.WorldAnalyticsInfo);
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldBounds
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBoxSphereBounds                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBoxSphereBounds UJunoWorldRegistryManager::GetWorldBounds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetWorldBounds");

	Params::JunoWorldRegistryManager_GetWorldBounds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoWorldRegistryManager.GetWorldDebugInfoText
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AFortPlayerPawn*            PlayerPawn                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoDebugWorldInfoResult*       WorldDebugInfo                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void UJunoWorldRegistryManager::GetWorldDebugInfoText(const class AFortPlayerPawn* PlayerPawn, struct FJunoDebugWorldInfoResult* WorldDebugInfo) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWorldRegistryManager", "GetWorldDebugInfoText");

	Params::JunoWorldRegistryManager_GetWorldDebugInfoText Parms{};

	Parms.PlayerPawn = PlayerPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (WorldDebugInfo != nullptr)
		*WorldDebugInfo = std::move(Parms.WorldDebugInfo);
}

}

