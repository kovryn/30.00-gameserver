#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: DelMarUI

#include "Basic.hpp"

#include "DelMarUI_classes.hpp"
#include "DelMarUI_parameters.hpp"


namespace SDK
{

// Function DelMarUI.DelMarUserWidget.BP_Hide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUserWidget::BP_Hide(bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "BP_Hide");

	Params::DelMarUserWidget_BP_Hide Parms{};

	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUserWidget.BP_Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUserWidget::BP_Show(bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "BP_Show");

	Params::DelMarUserWidget_BP_Show Parms{};

	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUserWidget.GetUIStateChartManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUIStateChartManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIStateChartManager* UDelMarUserWidget::GetUIStateChartManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "GetUIStateChartManager");

	Params::DelMarUserWidget_GetUIStateChartManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarUserWidget.HandleWidgetTransitionerStatusChanged
// (Final, Native, Protected)
// Parameters:
// class UWidgetTransitioner*              InTransitioner                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetTransitionerStatus               InStatus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUserWidget::HandleWidgetTransitionerStatusChanged(class UWidgetTransitioner* InTransitioner, EWidgetTransitionerStatus InStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "HandleWidgetTransitionerStatusChanged");

	Params::DelMarUserWidget_HandleWidgetTransitionerStatusChanged Parms{};

	Parms.InTransitioner = InTransitioner;
	Parms.InStatus = InStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUserWidget.SetDisplayEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUserWidget::SetDisplayEnabled(bool bEnabled, bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "SetDisplayEnabled");

	Params::DelMarUserWidget_SetDisplayEnabled Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUserWidget.GetWidgetTransitioner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetTransitioner*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetTransitioner* UDelMarUserWidget::GetWidgetTransitioner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "GetWidgetTransitioner");

	Params::DelMarUserWidget_GetWidgetTransitioner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarUserWidget.IsDisplayEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarUserWidget::IsDisplayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUserWidget", "IsDisplayEnabled");

	Params::DelMarUserWidget_IsDisplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarCountdownTimerWidget.SetInitialCountdownTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// double                                  InTime                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCountdownTimerWidget::SetInitialCountdownTime(double InTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCountdownTimerWidget", "SetInitialCountdownTime");

	Params::DelMarCountdownTimerWidget_SetInitialCountdownTime Parms{};

	Parms.InTime = InTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarCountdownTimerWidget.GetTimeRemainingSeconds
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarCountdownTimerWidget::GetTimeRemainingSeconds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCountdownTimerWidget", "GetTimeRemainingSeconds");

	Params::DelMarCountdownTimerWidget_GetTimeRemainingSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarCreativeUIDirector.OnVehicleAnyWheelsOnGroundChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bAnyWheelsOnGround                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarCreativeUIDirector::OnVehicleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bAnyWheelsOnGround)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCreativeUIDirector", "OnVehicleAnyWheelsOnGroundChanged");

	Params::DelMarCreativeUIDirector_OnVehicleAnyWheelsOnGroundChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bAnyWheelsOnGround = bAnyWheelsOnGround;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarCreativeUIDirector.OnVehicleEnter
// (Final, Native, Private)

void ADelMarCreativeUIDirector::OnVehicleEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCreativeUIDirector", "OnVehicleEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarCreativeUIDirector.OnVehicleExit
// (Final, Native, Private)

void ADelMarCreativeUIDirector::OnVehicleExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCreativeUIDirector", "OnVehicleExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarDriverCameraWidget.GetAnimationNames
// (Final, Native, Protected, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UDelMarDriverCameraWidget::GetAnimationNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDriverCameraWidget", "GetAnimationNames");

	Params::DelMarDriverCameraWidget_GetAnimationNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarListViewModel.GetElementAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMVVMViewModelBase*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMVVMViewModelBase* UDelMarListViewModel::GetElementAt(int32 InIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarListViewModel", "GetElementAt");

	Params::DelMarListViewModel_GetElementAt Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarListViewModel.GetElements
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class UMVVMViewModelBase*> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class UMVVMViewModelBase*> UDelMarListViewModel::GetElements() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarListViewModel", "GetElements");

	Params::DelMarListViewModel_GetElements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarViewModelBase.TryGetOwningLocalPlayer
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULocalPlayer*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULocalPlayer* UDelMarViewModelBase::TryGetOwningLocalPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarViewModelBase", "TryGetOwningLocalPlayer");

	Params::DelMarViewModelBase_TryGetOwningLocalPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarPlayerIndicatorsContainer.HandleIconOnlySettingChanged
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bUseIconOnly                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerIndicatorsContainer::HandleIconOnlySettingChanged(bool bUseIconOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorsContainer", "HandleIconOnlySettingChanged");

	Params::DelMarPlayerIndicatorsContainer_HandleIconOnlySettingChanged Parms{};

	Parms.bUseIconOnly = bUseIconOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPlayerIndicatorsContainer.HandleRacePlayersChanged
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TMap<int32, class UDelMarPlayerViewModel*>&RacePlayers                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarPlayerIndicatorsContainer::HandleRacePlayersChanged(const TMap<int32, class UDelMarPlayerViewModel*>& RacePlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorsContainer", "HandleRacePlayersChanged");

	Params::DelMarPlayerIndicatorsContainer_HandleRacePlayersChanged Parms{};

	Parms.RacePlayers = std::move(RacePlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPlayerIndicatorsContainer.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerIndicatorsContainer::HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorsContainer", "HandleViewTargetChanged");

	Params::DelMarPlayerIndicatorsContainer_HandleViewTargetChanged Parms{};

	Parms.InController = InController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPlayerIndicatorWidget.BP_HideIndicator
// (Event, Public, BlueprintEvent)

void UDelMarPlayerIndicatorWidget::BP_HideIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorWidget", "BP_HideIndicator");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarPlayerIndicatorWidget.BP_SetViewModel
// (Event, Public, BlueprintEvent)
// Parameters:
// class UDelMarPlayerViewModel*           ViewModel                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerIndicatorWidget::BP_SetViewModel(class UDelMarPlayerViewModel* ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorWidget", "BP_SetViewModel");

	Params::DelMarPlayerIndicatorWidget_BP_SetViewModel Parms{};

	Parms.ViewModel = ViewModel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarPlayerIndicatorWidget.BP_UpdateIndicator
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Opacity                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRearIndicator                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarRearAlertVerticalHint            VerticalHint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPlayerIndicatorWidget::BP_UpdateIndicator(float Scale, float Opacity, bool bRearIndicator, EDelMarRearAlertVerticalHint VerticalHint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerIndicatorWidget", "BP_UpdateIndicator");

	Params::DelMarPlayerIndicatorWidget_BP_UpdateIndicator Parms{};

	Parms.Scale = Scale;
	Parms.Opacity = Opacity;
	Parms.bRearIndicator = bRearIndicator;
	Parms.VerticalHint = VerticalHint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarExpandableHudWidget.BP_HandlePlayerPreferencesAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDelMarPlayerPreferencesComponent*InPlayerPreferences                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarExpandableHudWidget::BP_HandlePlayerPreferencesAdded(class UDelMarPlayerPreferencesComponent* InPlayerPreferences)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarExpandableHudWidget", "BP_HandlePlayerPreferencesAdded");

	Params::DelMarExpandableHudWidget_BP_HandlePlayerPreferencesAdded Parms{};

	Parms.InPlayerPreferences = InPlayerPreferences;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarExpandableHudWidget.HandleToggleAction
// (Final, Native, Protected, BlueprintCallable)

void UDelMarExpandableHudWidget::HandleToggleAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarExpandableHudWidget", "HandleToggleAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarExpandableHudWidget.HandleToggleSettingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bUseToggle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarExpandableHudWidget::HandleToggleSettingChanged(bool bUseToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarExpandableHudWidget", "HandleToggleSettingChanged");

	Params::DelMarExpandableHudWidget_HandleToggleSettingChanged Parms{};

	Parms.bUseToggle = bUseToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarExpandableHudWidget.SetTargetInterpTransformY
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   InTargetInterpTransformY                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarExpandableHudWidget::SetTargetInterpTransformY(float InTargetInterpTransformY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarExpandableHudWidget", "SetTargetInterpTransformY");

	Params::DelMarExpandableHudWidget_SetTargetInterpTransformY Parms{};

	Parms.InTargetInterpTransformY = InTargetInterpTransformY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPositionalTrackerWidget.UpdatePlayerPositions
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<class UDelMarPlayerViewModel*>&InPlayers                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDelMarPositionalTrackerWidget::UpdatePlayerPositions(const TArray<class UDelMarPlayerViewModel*>& InPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPositionalTrackerWidget", "UpdatePlayerPositions");

	Params::DelMarPositionalTrackerWidget_UpdatePlayerPositions Parms{};

	Parms.InPlayers = std::move(InPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarScreenBase.BP_Hide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarScreenBase::BP_Hide(bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "BP_Hide");

	Params::DelMarScreenBase_BP_Hide Parms{};

	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarScreenBase.BP_Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarScreenBase::BP_Show(bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "BP_Show");

	Params::DelMarScreenBase_BP_Show Parms{};

	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarScreenBase.GetUIStateChartManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUIStateChartManager*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUIStateChartManager* UDelMarScreenBase::GetUIStateChartManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "GetUIStateChartManager");

	Params::DelMarScreenBase_GetUIStateChartManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarScreenBase.HandleWidgetTransitionerStatusChanged
// (Final, Native, Protected)
// Parameters:
// class UWidgetTransitioner*              InTransitioner                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetTransitionerStatus               InStatus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarScreenBase::HandleWidgetTransitionerStatusChanged(class UWidgetTransitioner* InTransitioner, EWidgetTransitionerStatus InStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "HandleWidgetTransitionerStatusChanged");

	Params::DelMarScreenBase_HandleWidgetTransitionerStatusChanged Parms{};

	Parms.InTransitioner = InTransitioner;
	Parms.InStatus = InStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarScreenBase.SetDisplayEnabled
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipAnimation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarScreenBase::SetDisplayEnabled(bool bEnabled, bool bSkipAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "SetDisplayEnabled");

	Params::DelMarScreenBase_SetDisplayEnabled Parms{};

	Parms.bEnabled = bEnabled;
	Parms.bSkipAnimation = bSkipAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarScreenBase.GetWidgetTransitioner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetTransitioner*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetTransitioner* UDelMarScreenBase::GetWidgetTransitioner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "GetWidgetTransitioner");

	Params::DelMarScreenBase_GetWidgetTransitioner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarScreenBase.IsDisplayEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarScreenBase::IsDisplayEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarScreenBase", "IsDisplayEnabled");

	Params::DelMarScreenBase_IsDisplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarPostRaceLeaderboard.BP_UpdateLeaderboardFilter
// (Event, Protected, BlueprintEvent)

void UDelMarPostRaceLeaderboard::BP_UpdateLeaderboardFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceLeaderboard", "BP_UpdateLeaderboardFilter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarPostRaceScreen.BP_OnReadyUpChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPostRaceScreen::BP_OnReadyUpChanged(bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceScreen", "BP_OnReadyUpChanged");

	Params::DelMarPostRaceScreen_BP_OnReadyUpChanged Parms{};

	Parms.bReady = bReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarPostRaceScreen.RequestCountdown
// (Final, Native, Protected, BlueprintCallable)

void UDelMarPostRaceScreen::RequestCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceScreen", "RequestCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPostRaceScreen.ResetRun
// (Final, Native, Protected, BlueprintCallable)

void UDelMarPostRaceScreen::ResetRun()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceScreen", "ResetRun");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPostRaceScreen.UpdateVote
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDelMarPostRaceVote                     NewVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPostRaceScreen::UpdateVote(EDelMarPostRaceVote NewVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceScreen", "UpdateVote");

	Params::DelMarPostRaceScreen_UpdateVote Parms{};

	Parms.NewVote = NewVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPostRaceVoteWidget.BP_OnPostRaceVoteChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EDelMarPostRaceVote                     Vote                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPostRaceVoteWidget::BP_OnPostRaceVoteChanged(EDelMarPostRaceVote Vote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceVoteWidget", "BP_OnPostRaceVoteChanged");

	Params::DelMarPostRaceVoteWidget_BP_OnPostRaceVoteChanged Parms{};

	Parms.Vote = Vote;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarPostRaceVoteWidget.UpdateVote
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EDelMarPostRaceVote                     NewVote                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPostRaceVoteWidget::UpdateVote(EDelMarPostRaceVote NewVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceVoteWidget", "UpdateVote");

	Params::DelMarPostRaceVoteWidget_UpdateVote Parms{};

	Parms.NewVote = NewVote;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarQuestScreenContainer.HandleAthenaScreenDeactivated
// (Final, Native, Protected)

void UDelMarQuestScreenContainer::HandleAthenaScreenDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarQuestScreenContainer", "HandleAthenaScreenDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarQuestScreenContainer.HandleMapPanelExitButtonPressed
// (Final, Native, Protected)

void UDelMarQuestScreenContainer::HandleMapPanelExitButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarQuestScreenContainer", "HandleMapPanelExitButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarQuestScreenContainer.HandleToggleQuestList
// (Final, Native, Protected)

void UDelMarQuestScreenContainer::HandleToggleQuestList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarQuestScreenContainer", "HandleToggleQuestList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarRichTextInputSwitcher.SetInputText
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FText&                      InTextKBM                                              (Parm, NativeAccessSpecifierPublic)
// const class FText&                      InTextGamepad                                          (Parm, NativeAccessSpecifierPublic)
// const class FText&                      InTextTouch                                            (Parm, NativeAccessSpecifierPublic)

void UDelMarRichTextInputSwitcher::SetInputText(const class FText& InTextKBM, const class FText& InTextGamepad, const class FText& InTextTouch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRichTextInputSwitcher", "SetInputText");

	Params::DelMarRichTextInputSwitcher_SetInputText Parms{};

	Parms.InTextKBM = std::move(InTextKBM);
	Parms.InTextGamepad = std::move(InTextGamepad);
	Parms.InTextTouch = std::move(InTextTouch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.ClearSelection
// (Final, Native, Public, BlueprintCallable)

void UDelMarSelectionListViewModel::ClearSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "ClearSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.SelectNextElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowWrap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSelectionListViewModel::SelectNextElement(bool bAllowWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "SelectNextElement");

	Params::DelMarSelectionListViewModel_SelectNextElement Parms{};

	Parms.bAllowWrap = bAllowWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.SelectPreviousElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bAllowWrap                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSelectionListViewModel::SelectPreviousElement(bool bAllowWrap)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "SelectPreviousElement");

	Params::DelMarSelectionListViewModel_SelectPreviousElement Parms{};

	Parms.bAllowWrap = bAllowWrap;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.SetSelectedElement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMVVMViewModelBase*               InSelectedElement                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSelectionListViewModel::SetSelectedElement(class UMVVMViewModelBase* InSelectedElement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "SetSelectedElement");

	Params::DelMarSelectionListViewModel_SetSelectedElement Parms{};

	Parms.InSelectedElement = InSelectedElement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.SetSelectedIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InIndex                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarSelectionListViewModel::SetSelectedIndex(int32 InIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "SetSelectedIndex");

	Params::DelMarSelectionListViewModel_SetSelectedIndex Parms{};

	Parms.InIndex = InIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarSelectionListViewModel.GetSelectedIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarSelectionListViewModel::GetSelectedIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "GetSelectedIndex");

	Params::DelMarSelectionListViewModel_GetSelectedIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarSelectionListViewModel.HasSelection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarSelectionListViewModel::HasSelection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "HasSelection");

	Params::DelMarSelectionListViewModel_HasSelection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarSelectionListViewModel.SelectedElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMVVMViewModelBase*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMVVMViewModelBase* UDelMarSelectionListViewModel::SelectedElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarSelectionListViewModel", "SelectedElement");

	Params::DelMarSelectionListViewModel_SelectedElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchWidgetBase.GetPixelsPerInch
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTouchWidgetBase::GetPixelsPerInch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarTouchWidgetBase", "GetPixelsPerInch");

	Params::DelMarTouchWidgetBase_GetPixelsPerInch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchWidgetBase.CancelInputTracking
// (Final, Native, Protected, BlueprintCallable)

void UDelMarTouchWidgetBase::CancelInputTracking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "CancelInputTracking");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnActiveInputModeChanged
// (Final, Native, Private)
// Parameters:
// ECommonInputMode                        NewInputMode                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnActiveInputModeChanged(ECommonInputMode NewInputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnActiveInputModeChanged");

	Params::DelMarTouchWidgetBase_OnActiveInputModeChanged Parms{};

	Parms.NewInputMode = NewInputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnInputInjectionEnded
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EDelMarInputInjectionState              InInjectedState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnInputInjectionEnded(const struct FPointerEvent& InGestureEvent, EDelMarInputInjectionState InInjectedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnInputInjectionEnded");

	Params::DelMarTouchWidgetBase_OnInputInjectionEnded Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);
	Parms.InInjectedState = InInjectedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnInputInjectionStarted
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EDelMarInputInjectionState              InInjectedState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnInputInjectionStarted(const struct FPointerEvent& InGestureEvent, EDelMarInputInjectionState InInjectedState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnInputInjectionStarted");

	Params::DelMarTouchWidgetBase_OnInputInjectionStarted Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);
	Parms.InInjectedState = InInjectedState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnTrackedInputEnded
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bCancelled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnTrackedInputEnded(const struct FPointerEvent& InGestureEvent, bool bCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnTrackedInputEnded");

	Params::DelMarTouchWidgetBase_OnTrackedInputEnded Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);
	Parms.bCancelled = bCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnTrackedInputStarted
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnTrackedInputStarted(const struct FPointerEvent& InGestureEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnTrackedInputStarted");

	Params::DelMarTouchWidgetBase_OnTrackedInputStarted Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.OnTrackedInputUpdated
// (BlueprintCosmetic, Native, Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarTouchWidgetBase::OnTrackedInputUpdated(const struct FPointerEvent& InGestureEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "OnTrackedInputUpdated");

	Params::DelMarTouchWidgetBase_OnTrackedInputUpdated Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchWidgetBase.GetHitboxGeometry
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FGeometry                        ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FGeometry UDelMarTouchWidgetBase::GetHitboxGeometry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "GetHitboxGeometry");

	Params::DelMarTouchWidgetBase_GetHitboxGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchWidgetBase.IsGestureInsideHitbox
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPointerEvent&             InGestureEvent                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTouchWidgetBase::IsGestureInsideHitbox(const struct FPointerEvent& InGestureEvent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchWidgetBase", "IsGestureInsideHitbox");

	Params::DelMarTouchWidgetBase_IsGestureInsideHitbox Parms{};

	Parms.InGestureEvent = std::move(InGestureEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchActionButton.CanSetState
// (BlueprintCosmetic, Native, Event, Protected, BlueprintEvent)
// Parameters:
// EDelMarTouchActionButtonState           NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTouchActionButton::CanSetState(EDelMarTouchActionButtonState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "CanSetState");

	Params::DelMarTouchActionButton_CanSetState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchActionButton.SetBackgroundBrush
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSlateBrush&               Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarTouchActionButton::SetBackgroundBrush(const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "SetBackgroundBrush");

	Params::DelMarTouchActionButton_SetBackgroundBrush Parms{};

	Parms.Brush = std::move(Brush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarTouchActionButton.SetButtonState
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// EDelMarTouchActionButtonState           NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTouchActionButton::SetButtonState(EDelMarTouchActionButtonState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "SetButtonState");

	Params::DelMarTouchActionButton_SetButtonState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchActionButton.SetHighlightActive
// (BlueprintCosmetic, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchActionButton::SetHighlightActive(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "SetHighlightActive");

	Params::DelMarTouchActionButton_SetHighlightActive Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTouchActionButton.SetIconBrush
// (BlueprintCosmetic, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FSlateBrush&               Brush                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarTouchActionButton::SetIconBrush(const struct FSlateBrush& Brush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "SetIconBrush");

	Params::DelMarTouchActionButton_SetIconBrush Parms{};

	Parms.Brush = std::move(Brush);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarTouchActionButton.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDelMarTouchActionButtonState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarTouchActionButtonState UDelMarTouchActionButton::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "GetState");

	Params::DelMarTouchActionButton_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchActionButton.GetStateOnStopInputTracking
// (BlueprintCosmetic, Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    bInputCancelled                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarTouchActionButtonState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarTouchActionButtonState UDelMarTouchActionButton::GetStateOnStopInputTracking(bool bInputCancelled) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchActionButton", "GetStateOnStopInputTracking");

	Params::DelMarTouchActionButton_GetStateOnStopInputTracking Parms{};

	Parms.bInputCancelled = bInputCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchRegion.FindButtonByInputAction
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelMarTouchActionButton*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTouchActionButton* UDelMarTouchRegion::FindButtonByInputAction(class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchRegion", "FindButtonByInputAction");

	Params::DelMarTouchRegion_FindButtonByInputAction Parms{};

	Parms.InputAction = InputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarTouchRegion.SetHighlightForInputAction
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInputAction*                     InputAction                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTouchRegion::SetHighlightForInputAction(class UInputAction* InputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTouchRegion", "SetHighlightForInputAction");

	Params::DelMarTouchRegion_SetHighlightForInputAction Parms{};

	Parms.InputAction = InputAction;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarUICheatManager.DelMarAttachedWidgetSetEnabled
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarAttachedWidgetSetEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarAttachedWidgetSetEnabled");

	Params::DelMarUICheatManager_DelMarAttachedWidgetSetEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarCheckpointDebugWidgetSetVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarCheckpointDebugWidgetSetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarCheckpointDebugWidgetSetVisible");

	Params::DelMarUICheatManager_DelMarCheckpointDebugWidgetSetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarCloseTrackList
// (Final, Exec, Native, Protected)

void UDelMarUICheatManager::DelMarCloseTrackList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarCloseTrackList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarDismissDialog
// (Final, Exec, Native, Protected)

void UDelMarUICheatManager::DelMarDismissDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarDismissDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarDriverCameraSetHidden
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarDriverCameraSetHidden(bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarDriverCameraSetHidden");

	Params::DelMarUICheatManager_DelMarDriverCameraSetHidden Parms{};

	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarDriverCameraSetReactiveType
// (Final, Exec, Native, Protected)
// Parameters:
// int32                                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarDriverCameraSetReactiveType(int32 Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarDriverCameraSetReactiveType");

	Params::DelMarUICheatManager_DelMarDriverCameraSetReactiveType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarMapNameDebugWidgetSetVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarMapNameDebugWidgetSetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarMapNameDebugWidgetSetVisible");

	Params::DelMarUICheatManager_DelMarMapNameDebugWidgetSetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarOpenTrackList
// (Final, Exec, Native, Protected)

void UDelMarUICheatManager::DelMarOpenTrackList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarOpenTrackList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarPlayerIndicatorsVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarPlayerIndicatorsVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarPlayerIndicatorsVisible");

	Params::DelMarUICheatManager_DelMarPlayerIndicatorsVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarRequestDialogByTag
// (Final, Exec, Native, Protected)
// Parameters:
// const struct FGameplayTag&              tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarRequestDialogByTag(const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarRequestDialogByTag");

	Params::DelMarUICheatManager_DelMarRequestDialogByTag Parms{};

	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarRubberbandingWidgetSetVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarRubberbandingWidgetSetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarRubberbandingWidgetSetVisible");

	Params::DelMarUICheatManager_DelMarRubberbandingWidgetSetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarSetHint
// (Final, Exec, Native, Protected)
// Parameters:
// const class FText&                      HintText                                               (Parm, NativeAccessSpecifierPublic)
// float                                   RemoveAfterDelay                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarSetHint(const class FText& HintText, float RemoveAfterDelay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarSetHint");

	Params::DelMarUICheatManager_DelMarSetHint Parms{};

	Parms.HintText = std::move(HintText);
	Parms.RemoveAfterDelay = RemoveAfterDelay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarTouchHUD
// (Final, BlueprintCosmetic, Exec, Native, Protected)
// Parameters:
// const class FString&                    TouchHUDType                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarTouchHUD(const class FString& TouchHUDType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarTouchHUD");

	Params::DelMarUICheatManager_DelMarTouchHUD Parms{};

	Parms.TouchHUDType = std::move(TouchHUDType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarUISetVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarUISetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarUISetVisible");

	Params::DelMarUICheatManager_DelMarUISetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarUseToggleForExpandableHudWidget
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bUseToggle                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarUseToggleForExpandableHudWidget(bool bUseToggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarUseToggleForExpandableHudWidget");

	Params::DelMarUICheatManager_DelMarUseToggleForExpandableHudWidget Parms{};

	Parms.bUseToggle = bUseToggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.DelMarVehicleDebugWidgetSetVisible
// (Final, Exec, Native, Protected)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarUICheatManager::DelMarVehicleDebugWidgetSetVisible(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "DelMarVehicleDebugWidgetSetVisible");

	Params::DelMarUICheatManager_DelMarVehicleDebugWidgetSetVisible Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUICheatManager.OnAddedToCheatManagerNative
// (Final, Native, Protected, BlueprintCallable)

void UDelMarUICheatManager::OnAddedToCheatManagerNative()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUICheatManager", "OnAddedToCheatManagerNative");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.FastForward
// (Native, Public, BlueprintCallable)

void UUIAnimationController::FastForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "FastForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.GetDuration
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUIAnimationController::GetDuration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "GetDuration");

	Params::UIAnimationController_GetDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.UIAnimationController.JumpToBeginning
// (Native, Public, BlueprintCallable)

void UUIAnimationController::JumpToBeginning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "JumpToBeginning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.JumpToEnd
// (Native, Public, BlueprintCallable)

void UUIAnimationController::JumpToEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "JumpToEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.PlayBackward
// (Native, Public, BlueprintCallable)

void UUIAnimationController::PlayBackward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "PlayBackward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.PlayForward
// (Native, Public, BlueprintCallable)

void UUIAnimationController::PlayForward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "PlayForward");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.Rewind
// (Native, Public, BlueprintCallable)

void UUIAnimationController::Rewind()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "Rewind");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.Stop
// (Native, Public, BlueprintCallable)

void UUIAnimationController::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.SwitchPlayDirection
// (Native, Public, BlueprintCallable)

void UUIAnimationController::SwitchPlayDirection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "SwitchPlayDirection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.UIAnimationController.IsPlaying
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUIAnimationController::IsPlaying() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UIAnimationController", "IsPlaying");

	Params::UIAnimationController_IsPlaying Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.UITimelineAnimationController.CreateInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UUserWidget*                      WidgetTarget_0                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetAnimation*                 Animation_0                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUITimelineAnimationController*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUITimelineAnimationController* UUITimelineAnimationController::CreateInstance(class UUserWidget* WidgetTarget_0, class UWidgetAnimation* Animation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UITimelineAnimationController", "CreateInstance");

	Params::UITimelineAnimationController_CreateInstance Parms{};

	Parms.WidgetTarget_0 = WidgetTarget_0;
	Parms.Animation_0 = Animation_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.WidgetTransitioner.CreateInstance
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWidget*                          TargetWidget_0                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetTransitionerInitialStatus        InitialStatus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        HiddenVisibility_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        ShownVisibility_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AlwaysReverseInterruptedAnimations                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetTransitioner*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetTransitioner* UWidgetTransitioner::CreateInstance(class UWidget* TargetWidget_0, EWidgetTransitionerInitialStatus InitialStatus, ESlateVisibility HiddenVisibility_0, ESlateVisibility ShownVisibility_0, bool AlwaysReverseInterruptedAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WidgetTransitioner", "CreateInstance");

	Params::WidgetTransitioner_CreateInstance Parms{};

	Parms.TargetWidget_0 = TargetWidget_0;
	Parms.InitialStatus = InitialStatus;
	Parms.HiddenVisibility_0 = HiddenVisibility_0;
	Parms.ShownVisibility_0 = ShownVisibility_0;
	Parms.AlwaysReverseInterruptedAnimations = AlwaysReverseInterruptedAnimations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.WidgetTransitioner.AddHintedTransitionIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InAnimationHint                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIAnimationController*           InAnimationIn                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInvert                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::AddHintedTransitionIn(const struct FGameplayTag& InAnimationHint, class UUIAnimationController* InAnimationIn, const bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "AddHintedTransitionIn");

	Params::WidgetTransitioner_AddHintedTransitionIn Parms{};

	Parms.InAnimationHint = std::move(InAnimationHint);
	Parms.InAnimationIn = InAnimationIn;
	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.AddHintedTransitionOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InAnimationHint                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIAnimationController*           InAnimationOut                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInvert                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::AddHintedTransitionOut(const struct FGameplayTag& InAnimationHint, class UUIAnimationController* InAnimationOut, const bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "AddHintedTransitionOut");

	Params::WidgetTransitioner_AddHintedTransitionOut Parms{};

	Parms.InAnimationHint = std::move(InAnimationHint);
	Parms.InAnimationOut = InAnimationOut;
	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.AddHintedTransitionPair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InAnimationHint                                        (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUIAnimationController*           InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsTransitionIn                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::AddHintedTransitionPair(const struct FGameplayTag& InAnimationHint, class UUIAnimationController* InAnimation, const bool bIsTransitionIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "AddHintedTransitionPair");

	Params::WidgetTransitioner_AddHintedTransitionPair Parms{};

	Parms.InAnimationHint = std::move(InAnimationHint);
	Parms.InAnimation = InAnimation;
	Parms.bIsTransitionIn = bIsTransitionIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.BP_Hide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bSkipAnimation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     AnimationHints                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void UWidgetTransitioner::BP_Hide(const bool bSkipAnimation, const struct FGameplayTagContainer& AnimationHints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "BP_Hide");

	Params::WidgetTransitioner_BP_Hide Parms{};

	Parms.bSkipAnimation = bSkipAnimation;
	Parms.AnimationHints = std::move(AnimationHints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.BP_Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidget*                          TargetWidget_0                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWidgetTransitionerInitialStatus        InitialStatus                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        HiddenVisibility_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESlateVisibility                        ShownVisibility_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AlwaysReverseInterruptedAnimations                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetTransitioner*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetTransitioner* UWidgetTransitioner::BP_Initialize(class UWidget* TargetWidget_0, EWidgetTransitionerInitialStatus InitialStatus, ESlateVisibility HiddenVisibility_0, ESlateVisibility ShownVisibility_0, bool AlwaysReverseInterruptedAnimations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "BP_Initialize");

	Params::WidgetTransitioner_BP_Initialize Parms{};

	Parms.TargetWidget_0 = TargetWidget_0;
	Parms.InitialStatus = InitialStatus;
	Parms.HiddenVisibility_0 = HiddenVisibility_0;
	Parms.ShownVisibility_0 = ShownVisibility_0;
	Parms.AlwaysReverseInterruptedAnimations = AlwaysReverseInterruptedAnimations;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.WidgetTransitioner.BP_Show
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bSkipAnimation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     AnimationHints                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void UWidgetTransitioner::BP_Show(const bool bSkipAnimation, const struct FGameplayTagContainer& AnimationHints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "BP_Show");

	Params::WidgetTransitioner_BP_Show Parms{};

	Parms.bSkipAnimation = bSkipAnimation;
	Parms.AnimationHints = std::move(AnimationHints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.SetNormalTransitionIn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUIAnimationController*           InAnimationIn                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInvert                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::SetNormalTransitionIn(class UUIAnimationController* InAnimationIn, const bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "SetNormalTransitionIn");

	Params::WidgetTransitioner_SetNormalTransitionIn Parms{};

	Parms.InAnimationIn = InAnimationIn;
	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.SetNormalTransitionOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUIAnimationController*           InAnimationOut                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bInvert                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::SetNormalTransitionOut(class UUIAnimationController* InAnimationOut, const bool bInvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "SetNormalTransitionOut");

	Params::WidgetTransitioner_SetNormalTransitionOut Parms{};

	Parms.InAnimationOut = InAnimationOut;
	Parms.bInvert = bInvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.SetNormalTransitionPair
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UUIAnimationController*           InAnimation                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bIsTransitionIn                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetTransitioner::SetNormalTransitionPair(class UUIAnimationController* InAnimation, const bool bIsTransitionIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "SetNormalTransitionPair");

	Params::WidgetTransitioner_SetNormalTransitionPair Parms{};

	Parms.InAnimation = InAnimation;
	Parms.bIsTransitionIn = bIsTransitionIn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.WidgetTransitioner.GetTransitionerStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EWidgetTransitionerStatus               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EWidgetTransitionerStatus UWidgetTransitioner::GetTransitionerStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "GetTransitionerStatus");

	Params::WidgetTransitioner_GetTransitionerStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.WidgetTransitioner.IsHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetTransitioner::IsHidden() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetTransitioner", "IsHidden");

	Params::WidgetTransitioner_IsHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarActionWidget.SetEnhancedInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInputAction*                     InInputAction                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarActionWidget::SetEnhancedInputAction(class UInputAction* InInputAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "SetEnhancedInputAction");

	Params::DelMarActionWidget_SetEnhancedInputAction Parms{};

	Parms.InInputAction = InInputAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarActionWidget.SetIconRimBrush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FSlateBrush&               InIconRimBrush                                         (Parm, NativeAccessSpecifierPublic)

void UDelMarActionWidget::SetIconRimBrush(const struct FSlateBrush& InIconRimBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "SetIconRimBrush");

	Params::DelMarActionWidget_SetIconRimBrush Parms{};

	Parms.InIconRimBrush = std::move(InIconRimBrush);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarActionWidget.SetInputAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       InputActionRow                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarActionWidget::SetInputAction(const struct FDataTableRowHandle& InputActionRow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "SetInputAction");

	Params::DelMarActionWidget_SetInputAction Parms{};

	Parms.InputActionRow = std::move(InputActionRow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarActionWidget.SetInputActions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<struct FDataTableRowHandle>&NewInputActions                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDelMarActionWidget::SetInputActions(const TArray<struct FDataTableRowHandle>& NewInputActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "SetInputActions");

	Params::DelMarActionWidget_SetInputActions Parms{};

	Parms.NewInputActions = std::move(NewInputActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarActionWidget.GetDisplayText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UDelMarActionWidget::GetDisplayText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "GetDisplayText");

	Params::DelMarActionWidget_GetDisplayText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarActionWidget.GetIcon
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush UDelMarActionWidget::GetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "GetIcon");

	Params::DelMarActionWidget_GetIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarActionWidget.IsHeldAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarActionWidget::IsHeldAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarActionWidget", "IsHeldAction");

	Params::DelMarActionWidget_IsHeldAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarDialogBase.DismissDialog
// (Final, Native, Public, BlueprintCallable)

void UDelMarDialogBase::DismissDialog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDialogBase", "DismissDialog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarLoadingScreenHelper.PrepareDelMarLoadingScreen
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarLoadingScreenHelper::PrepareDelMarLoadingScreen(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLoadingScreenHelper", "PrepareDelMarLoadingScreen");

	Params::DelMarLoadingScreenHelper_PrepareDelMarLoadingScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarUIDirector.SetLoadingScreenVisibiliy
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bVisible                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarUIDirector::SetLoadingScreenVisibiliy(bool bVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarUIDirector", "SetLoadingScreenVisibiliy");

	Params::DelMarUIDirector_SetLoadingScreenVisibiliy Parms{};

	Parms.bVisible = bVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarAttachedWidgetComponent.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarAttachedWidgetComponent::HandleViewTargetChanged(class AFortPlayerController* InController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarAttachedWidgetComponent", "HandleViewTargetChanged");

	Params::DelMarAttachedWidgetComponent_HandleViewTargetChanged Parms{};

	Parms.InController = InController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarStartlineCountdownWidget.BP_OnActiveIntervalsChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   NumActiveIntervals                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStartlineCountdownWidget::BP_OnActiveIntervalsChanged(int32 NumActiveIntervals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "BP_OnActiveIntervalsChanged");

	Params::DelMarStartlineCountdownWidget_BP_OnActiveIntervalsChanged Parms{};

	Parms.NumActiveIntervals = NumActiveIntervals;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarStartlineCountdownWidget.BP_OnCountdownStarted
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   TotalIntervals                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStartlineCountdownWidget::BP_OnCountdownStarted(int32 TotalIntervals)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "BP_OnCountdownStarted");

	Params::DelMarStartlineCountdownWidget_BP_OnCountdownStarted Parms{};

	Parms.TotalIntervals = TotalIntervals;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarStartlineCountdownWidget.BP_OnRaceStarted
// (Event, Public, BlueprintEvent)

void UDelMarStartlineCountdownWidget::BP_OnRaceStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "BP_OnRaceStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarStartlineCountdownWidget.BP_OnStartlineBoostActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   PercentageMaxBonusSpeedEarned                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStartlineCountdownWidget::BP_OnStartlineBoostActivated(float PercentageMaxBonusSpeedEarned)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "BP_OnStartlineBoostActivated");

	Params::DelMarStartlineCountdownWidget_BP_OnStartlineBoostActivated Parms{};

	Parms.PercentageMaxBonusSpeedEarned = PercentageMaxBonusSpeedEarned;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarStartlineCountdownWidget.BP_OnStartlineBoostFailed
// (Event, Public, BlueprintEvent)

void UDelMarStartlineCountdownWidget::BP_OnStartlineBoostFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "BP_OnStartlineBoostFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarStartlineCountdownWidget.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Old                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarStartlineCountdownWidget::HandleViewTargetChanged(class AFortPlayerController* PC, class AActor* Old, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "HandleViewTargetChanged");

	Params::DelMarStartlineCountdownWidget_HandleViewTargetChanged Parms{};

	Parms.PC = PC;
	Parms.Old = Old;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarStartlineCountdownWidget.GetNumActiveIntervals
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarStartlineCountdownWidget::GetNumActiveIntervals() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "GetNumActiveIntervals");

	Params::DelMarStartlineCountdownWidget_GetNumActiveIntervals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarStartlineCountdownWidget.GetNumTotalIntervals
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarStartlineCountdownWidget::GetNumTotalIntervals() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarStartlineCountdownWidget", "GetNumTotalIntervals");

	Params::DelMarStartlineCountdownWidget_GetNumTotalIntervals Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarCheckpointTrackerEntryWidget.BP_OnDisplayedCheckpointChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FDelMarSectionData&        InSectionData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const bool                              bNewEntry                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarCheckpointTrackerEntryWidget::BP_OnDisplayedCheckpointChanged(const struct FDelMarSectionData& InSectionData, const bool bNewEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpointTrackerEntryWidget", "BP_OnDisplayedCheckpointChanged");

	Params::DelMarCheckpointTrackerEntryWidget_BP_OnDisplayedCheckpointChanged Parms{};

	Parms.InSectionData = std::move(InSectionData);
	Parms.bNewEntry = bNewEntry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarCheckpointTrackerWidget.UpdateCheckpoints
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// const TArray<struct FDelMarSectionData>&InCheckpoints                                          (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UDelMarCheckpointTrackerWidget::UpdateCheckpoints(const TArray<struct FDelMarSectionData>& InCheckpoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarCheckpointTrackerWidget", "UpdateCheckpoints");

	Params::DelMarCheckpointTrackerWidget_UpdateCheckpoints Parms{};

	Parms.InCheckpoints = std::move(InCheckpoints);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarDebugRubberbandingWidget.BP_OnRubberbandingUpdated
// (Event, Public, BlueprintEvent)

void UDelMarDebugRubberbandingWidget::BP_OnRubberbandingUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDebugRubberbandingWidget", "BP_OnRubberbandingUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarDebugVehicleWidget.BP_OnVehicleUpdated
// (Event, Public, BlueprintEvent)

void UDelMarDebugVehicleWidget::BP_OnVehicleUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDebugVehicleWidget", "BP_OnVehicleUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarReadyUpWidget.BP_OnReadyUpChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bReady                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarReadyUpWidget::BP_OnReadyUpChanged(bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarReadyUpWidget", "BP_OnReadyUpChanged");

	Params::DelMarReadyUpWidget_BP_OnReadyUpChanged Parms{};

	Parms.bReady = bReady;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarReadyUpWidget.BP_ReadyUp
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const bool                              bReady                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarReadyUpWidget::BP_ReadyUp(const bool bReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarReadyUpWidget", "BP_ReadyUp");

	Params::DelMarReadyUpWidget_BP_ReadyUp Parms{};

	Parms.bReady = bReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarTurboBonusZoneWidget.BP_OnTurboZoneStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// EDelMarTurboZoneState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTurboBonusZoneWidget::BP_OnTurboZoneStateChanged(EDelMarTurboZoneState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTurboBonusZoneWidget", "BP_OnTurboZoneStateChanged");

	Params::DelMarTurboBonusZoneWidget_BP_OnTurboZoneStateChanged Parms{};

	Parms.NewState = NewState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarTurboBonusZoneWidget.HandleTurboStateChange
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTurboBonusZoneWidget::HandleTurboStateChange(EDelMarTurboZoneState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTurboBonusZoneWidget", "HandleTurboStateChange");

	Params::DelMarTurboBonusZoneWidget_HandleTurboStateChange Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPositionalTrackerEntryWidget.RefreshPlayerInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsTargetPlayer                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPositionalTrackerEntryWidget::RefreshPlayerInfo(bool IsTargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPositionalTrackerEntryWidget", "RefreshPlayerInfo");

	Params::DelMarPositionalTrackerEntryWidget_RefreshPlayerInfo Parms{};

	Parms.IsTargetPlayer = IsTargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPositionalTrackerEntryWidget.SetDisplayedPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDelMarPlayerViewModel*           InPlayerModel                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarPositionalTrackerEntryWidget::SetDisplayedPlayer(class UDelMarPlayerViewModel* InPlayerModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPositionalTrackerEntryWidget", "SetDisplayedPlayer");

	Params::DelMarPositionalTrackerEntryWidget_SetDisplayedPlayer Parms{};

	Parms.InPlayerModel = InPlayerModel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPostRaceRankedRecap.GetFailsafeDelayDuration
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarPostRaceRankedRecap::GetFailsafeDelayDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPostRaceRankedRecap", "GetFailsafeDelayDuration");

	Params::DelMarPostRaceRankedRecap_GetFailsafeDelayDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarDebugTrackEntry.BP_OnTrackButtonPressed
// (Native, Protected, BlueprintCallable)

void UDelMarDebugTrackEntry::BP_OnTrackButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDebugTrackEntry", "BP_OnTrackButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarDebugTrackList.BP_OnExitButtonPressed
// (Final, Native, Protected, BlueprintCallable)

void UDelMarDebugTrackList::BP_OnExitButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarDebugTrackList", "BP_OnExitButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarBoundActionButton.BP_OnActionProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// const float                             HoldPercentage                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBoundActionButton::BP_OnActionProgress(const float HoldPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBoundActionButton", "BP_OnActionProgress");

	Params::DelMarBoundActionButton_BP_OnActionProgress Parms{};

	Parms.HoldPercentage = HoldPercentage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarBoundActionButton.BP_OnInputActionUpdated
// (Event, Protected, BlueprintEvent)

void UDelMarBoundActionButton::BP_OnInputActionUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBoundActionButton", "BP_OnInputActionUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarUI.DelMarBoundActionButton.BP_SetText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      ButtonText                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarBoundActionButton::BP_SetText(const class FText& ButtonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBoundActionButton", "BP_SetText");

	Params::DelMarBoundActionButton_BP_SetText Parms{};

	Parms.ButtonText = std::move(ButtonText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarUI.DelMarBladeMenuTriggerUIStateComponent.NativeHandleCursorModeChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bCursorModeEnabled                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      CursorModeContentWidget                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarBladeMenuTriggerUIStateComponent::NativeHandleCursorModeChanged(bool bCursorModeEnabled, class FName ActionName, class UUserWidget* CursorModeContentWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarBladeMenuTriggerUIStateComponent", "NativeHandleCursorModeChanged");

	Params::DelMarBladeMenuTriggerUIStateComponent_NativeHandleCursorModeChanged Parms{};

	Parms.bCursorModeEnabled = bCursorModeEnabled;
	Parms.ActionName = ActionName;
	Parms.CursorModeContentWidget = CursorModeContentWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarGameplayContextUpdaterUIStateComponent.HandleSpectatorViewTargetChange
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OldViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarGameplayContextUpdaterUIStateComponent::HandleSpectatorViewTargetChange(class AFortPlayerController* PlayerController, class AActor* OldViewTarget, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGameplayContextUpdaterUIStateComponent", "HandleSpectatorViewTargetChange");

	Params::DelMarGameplayContextUpdaterUIStateComponent_HandleSpectatorViewTargetChange Parms{};

	Parms.PlayerController = PlayerController;
	Parms.OldViewTarget = OldViewTarget;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarGameplayContextUpdaterUIStateComponent.HandleTouchControlsLayoutChanged
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              Layout                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarGameplayContextUpdaterUIStateComponent::HandleTouchControlsLayoutChanged(const struct FGameplayTag& Layout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarGameplayContextUpdaterUIStateComponent", "HandleTouchControlsLayoutChanged");

	Params::DelMarGameplayContextUpdaterUIStateComponent_HandleTouchControlsLayoutChanged Parms{};

	Parms.Layout = std::move(Layout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarLocalPlayerSettingsViewModel.HandleNameplatesSettingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarLocalPlayerSettingsViewModel::HandleNameplatesSettingChanged(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarLocalPlayerSettingsViewModel", "HandleNameplatesSettingChanged");

	Params::DelMarLocalPlayerSettingsViewModel_HandleNameplatesSettingChanged Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPlayerRaceStateViewModel.HandleRaceReset
// (Final, Native, Protected)

void UDelMarPlayerRaceStateViewModel::HandleRaceReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerRaceStateViewModel", "HandleRaceReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarPlayerViewModel.GetPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AFortPlayerState*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AFortPlayerState* UDelMarPlayerViewModel::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarPlayerViewModel", "GetPlayerState");

	Params::DelMarPlayerViewModel_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRaceViewModel.HandleFinalRacePositionsChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<struct FDelMarFinalRacePositionEntry>&FinalRacePositions                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FDelMarEvent_RunRecorded&  RecordedRun                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UDelMarRaceViewModel::HandleFinalRacePositionsChanged(const TArray<struct FDelMarFinalRacePositionEntry>& FinalRacePositions, const struct FDelMarEvent_RunRecorded& RecordedRun)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceViewModel", "HandleFinalRacePositionsChanged");

	Params::DelMarRaceViewModel_HandleFinalRacePositionsChanged Parms{};

	Parms.FinalRacePositions = std::move(FinalRacePositions);
	Parms.RecordedRun = std::move(RecordedRun);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarRaceViewModel.HandleViewTargetChanged
// (Final, Native, Protected)
// Parameters:
// class AFortPlayerController*            PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Old                                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewViewTarget                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarRaceViewModel::HandleViewTargetChanged(class AFortPlayerController* PC, class AActor* Old, class AActor* NewViewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRaceViewModel", "HandleViewTargetChanged");

	Params::DelMarRaceViewModel_HandleViewTargetChanged Parms{};

	Parms.PC = PC;
	Parms.Old = Old;
	Parms.NewViewTarget = NewViewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleAnyWheelsOnGroundChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TScriptInterface<class IDelMarVehicleInterface>&VehicleRef                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleAnyWheelsOnGroundChanged(const TScriptInterface<class IDelMarVehicleInterface>& VehicleRef, bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleAnyWheelsOnGroundChanged");

	Params::DelMarVehicleViewModel_HandleAnyWheelsOnGroundChanged Parms{};

	Parms.VehicleRef = VehicleRef;
	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleDemolishPressDurationUpdated
// (Final, Native, Protected)
// Parameters:
// float                                   PressedDurationPercentage                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleDemolishPressDurationUpdated(float PressedDurationPercentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleDemolishPressDurationUpdated");

	Params::DelMarVehicleViewModel_HandleDemolishPressDurationUpdated Parms{};

	Parms.PressedDurationPercentage = PressedDurationPercentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleDriftActivated
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleDriftActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleDriftActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleDriftDeactivated
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleDriftDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleDriftDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleDriftSlipAngleRatioChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleDriftSlipAngleRatioChanged(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleDriftSlipAngleRatioChanged");

	Params::DelMarVehicleViewModel_HandleDriftSlipAngleRatioChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleMissedCheckpointCountdownCancelled
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleMissedCheckpointCountdownCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleMissedCheckpointCountdownCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleMissedCheckpointCountdownInitiated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_MissedCheckpointDemoCountdown&Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleMissedCheckpointCountdownInitiated(const struct FDelMarEvent_MissedCheckpointDemoCountdown& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleMissedCheckpointCountdownInitiated");

	Params::DelMarVehicleViewModel_HandleMissedCheckpointCountdownInitiated Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleOnThrottleInput
// (Final, Native, Protected)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleOnThrottleInput(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleOnThrottleInput");

	Params::DelMarVehicleViewModel_HandleOnThrottleInput Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleOnVehicleDemolished
// (Final, Native, Protected)
// Parameters:
// const struct FGameplayTag&              CausedByTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleOnVehicleDemolished(const struct FGameplayTag& CausedByTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleOnVehicleDemolished");

	Params::DelMarVehicleViewModel_HandleOnVehicleDemolished Parms{};

	Parms.CausedByTag = std::move(CausedByTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandlePotentialDriftBoostChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandlePotentialDriftBoostChanged(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandlePotentialDriftBoostChanged");

	Params::DelMarVehicleViewModel_HandlePotentialDriftBoostChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleReturnToTrackCountdownCancelled
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleReturnToTrackCountdownCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleReturnToTrackCountdownCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleReturnToTrackCountdownInitiated
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_ReturnToTrackDemoCountdown&Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleReturnToTrackCountdownInitiated(const struct FDelMarEvent_ReturnToTrackDemoCountdown& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleReturnToTrackCountdownInitiated");

	Params::DelMarVehicleViewModel_HandleReturnToTrackCountdownInitiated Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleSpeedometerSpeedChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleSpeedometerSpeedChanged(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleSpeedometerSpeedChanged");

	Params::DelMarVehicleViewModel_HandleSpeedometerSpeedChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleStartlineBoostActivated
// (Final, Native, Protected)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleStartlineBoostActivated(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleStartlineBoostActivated");

	Params::DelMarVehicleViewModel_HandleStartlineBoostActivated Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleStartlineBoostFailed
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleStartlineBoostFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleStartlineBoostFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleToggleThrottleSettingChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleToggleThrottleSettingChanged(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleToggleThrottleSettingChanged");

	Params::DelMarVehicleViewModel_HandleToggleThrottleSettingChanged Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleTurboBonusZoneChanged
// (Final, Native, Protected)
// Parameters:
// EDelMarTurboZoneState                   InTurboBonusZoneState                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleTurboBonusZoneChanged(EDelMarTurboZoneState InTurboBonusZoneState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleTurboBonusZoneChanged");

	Params::DelMarVehicleViewModel_HandleTurboBonusZoneChanged Parms{};

	Parms.InTurboBonusZoneState = InTurboBonusZoneState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleTurboChargesUpdated
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleTurboChargesUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleTurboChargesUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleUnderthrustPercentChanged
// (Final, Native, Protected)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleUnderthrustPercentChanged(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleUnderthrustPercentChanged");

	Params::DelMarVehicleViewModel_HandleUnderthrustPercentChanged Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleVehicleWheelsLeftGround
// (Final, Native, Protected)

void UDelMarVehicleViewModel::HandleVehicleWheelsLeftGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleVehicleWheelsLeftGround");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.HandleWrongwayIndication
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FDelMarEvent_VehicleWrongwayStatus&Event                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::HandleWrongwayIndication(const struct FDelMarEvent_VehicleWrongwayStatus& Event)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "HandleWrongwayIndication");

	Params::DelMarVehicleViewModel_HandleWrongwayIndication Parms{};

	Parms.Event = std::move(Event);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarVehicleViewModel.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AFortPlayerState*                 InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarVehicleViewModel::Initialize(class AFortPlayerState* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarVehicleViewModel", "Initialize");

	Params::DelMarVehicleViewModel_Initialize Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarUI.DelMarRankedPlacementChangeVM.GetCurrentPlacement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarRankedPlacementVM*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarRankedPlacementVM* UDelMarRankedPlacementChangeVM::GetCurrentPlacement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementChangeVM", "GetCurrentPlacement");

	Params::DelMarRankedPlacementChangeVM_GetCurrentPlacement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementChangeVM.GetInitialPlacement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDelMarRankedPlacementVM*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarRankedPlacementVM* UDelMarRankedPlacementChangeVM::GetInitialPlacement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementChangeVM", "GetInitialPlacement");

	Params::DelMarRankedPlacementChangeVM_GetInitialPlacement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementChangeVM.GetIsDataValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarRankedPlacementChangeVM::GetIsDataValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementChangeVM", "GetIsDataValid");

	Params::DelMarRankedPlacementChangeVM_GetIsDataValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementChangeVM.GetPositionDelta
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarRankedPlacementChangeVM::GetPositionDelta() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementChangeVM", "GetPositionDelta");

	Params::DelMarRankedPlacementChangeVM_GetPositionDelta Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.GetIsDataValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarRankedPlacementVM::GetIsDataValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "GetIsDataValid");

	Params::DelMarRankedPlacementVM_GetIsDataValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.GetIsUnranked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarRankedPlacementVM::GetIsUnranked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "GetIsUnranked");

	Params::DelMarRankedPlacementVM_GetIsUnranked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.GetPlayerPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarRankedPlacementVM::GetPlayerPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "GetPlayerPosition");

	Params::DelMarRankedPlacementVM_GetPlayerPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.GetProgressTowardNextTier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarRankedPlacementVM::GetProgressTowardNextTier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "GetProgressTowardNextTier");

	Params::DelMarRankedPlacementVM_GetProgressTowardNextTier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.GetTierIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarRankedPlacementVM::GetTierIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "GetTierIndex");

	Params::DelMarRankedPlacementVM_GetTierIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedPlacementVM.TierDisplayData
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FFortHabaneroTier                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFortHabaneroTier UDelMarRankedPlacementVM::TierDisplayData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedPlacementVM", "TierDisplayData");

	Params::DelMarRankedPlacementVM_TierDisplayData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedRecapVM.GetUnrankedTierData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFortHabaneroTier*               OutUnrankedTierData                                    (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarRankedRecapVM::GetUnrankedTierData(struct FFortHabaneroTier* OutUnrankedTierData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedRecapVM", "GetUnrankedTierData");

	Params::DelMarRankedRecapVM_GetUnrankedTierData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutUnrankedTierData != nullptr)
		*OutUnrankedTierData = std::move(Parms.OutUnrankedTierData);

	return Parms.ReturnValue;
}


// Function DelMarUI.DelMarRankedRecapVM.QueryProgress
// (Final, Native, Private)

void UDelMarRankedRecapVM::QueryProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarRankedRecapVM", "QueryProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}

}

