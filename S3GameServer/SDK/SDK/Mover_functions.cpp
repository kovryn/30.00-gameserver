#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Mover

#include "Basic.hpp"

#include "Mover_classes.hpp"
#include "Mover_parameters.hpp"


namespace SDK
{

// Function Mover.AirMovementUtils.ComputeControlledFreeMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFreeMoveParams&           InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UAirMovementUtils::ComputeControlledFreeMove(const struct FFreeMoveParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AirMovementUtils", "ComputeControlledFreeMove");

	Params::AirMovementUtils_ComputeControlledFreeMove Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.AirMovementUtils.IsValidLandingSpot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult*               OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAirMovementUtils::IsValidLandingSpot(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Location, const struct FHitResult& Hit, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AirMovementUtils", "IsValidLandingSpot");

	Params::AirMovementUtils_IsValidLandingSpot Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Location = std::move(Location);
	Parms.Hit = std::move(Hit);
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	return Parms.ReturnValue;
}


// Function Mover.AirMovementUtils.TryMoveToFallAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult*               OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAirMovementUtils::TryMoveToFallAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AirMovementUtils", "TryMoveToFallAlongSurface");

	Params::AirMovementUtils_TryMoveToFallAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.AddMovementModeFromClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UBaseMovementMode>    MovementMode                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseMovementMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseMovementMode* UMoverComponent::AddMovementModeFromClass(class FName ModeName, TSubclassOf<class UBaseMovementMode> MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "AddMovementModeFromClass");

	Params::MoverComponent_AddMovementModeFromClass Parms{};

	Parms.ModeName = ModeName;
	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.AddMovementModeFromObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseMovementMode*                MovementMode                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::AddMovementModeFromObject(class FName ModeName, class UBaseMovementMode* MovementMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "AddMovementModeFromObject");

	Params::MoverComponent_AddMovementModeFromObject Parms{};

	Parms.ModeName = ModeName;
	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.HandleImpact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverOnImpactParams*            ImpactParams                                           (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMoverComponent::HandleImpact(struct FMoverOnImpactParams* ImpactParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "HandleImpact");

	Params::MoverComponent_HandleImpact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ImpactParams != nullptr)
		*ImpactParams = std::move(Parms.ImpactParams);
}


// Function Mover.MoverComponent.K2_QueueLayeredMove
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32&                            MoveAsRawData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::K2_QueueLayeredMove(const int32& MoveAsRawData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "K2_QueueLayeredMove");

	Params::MoverComponent_K2_QueueLayeredMove Parms{};

	Parms.MoveAsRawData = MoveAsRawData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverComponent.OnBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMoverComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "OnBeginOverlap");

	Params::MoverComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverComponent.PhysicsVolumeChanged
// (Native, Protected)
// Parameters:
// class APhysicsVolume*                   NewVolume                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "PhysicsVolumeChanged");

	Params::MoverComponent_PhysicsVolumeChanged Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverComponent.QueueNextMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DesiredModeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldReenter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::QueueNextMode(class FName DesiredModeName, bool bShouldReenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "QueueNextMode");

	Params::MoverComponent_QueueNextMode Parms{};

	Parms.DesiredModeName = DesiredModeName;
	Parms.bShouldReenter = bShouldReenter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverComponent.RemoveMovementMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ModeName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::RemoveMovementMode(class FName ModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "RemoveMovementMode");

	Params::MoverComponent_RemoveMovementMode Parms{};

	Parms.ModeName = ModeName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.SetGravityOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bOverrideGravity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GravityAcceleration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::SetGravityOverride(bool bOverrideGravity, const struct FVector& GravityAcceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "SetGravityOverride");

	Params::MoverComponent_SetGravityOverride Parms{};

	Parms.bOverrideGravity = bOverrideGravity;
	Parms.GravityAcceleration = std::move(GravityAcceleration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverComponent.FindMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UBaseMovementMode>    MovementMode                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseMovementMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseMovementMode* UMoverComponent::FindMovementMode(TSubclassOf<class UBaseMovementMode> MovementMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "FindMovementMode");

	Params::MoverComponent_FindMovementMode Parms{};

	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.FindSharedSettings_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObject>              SharedSetting                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UObject*                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UObject* UMoverComponent::FindSharedSettings_BP(TSubclassOf<class UObject> SharedSetting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "FindSharedSettings_BP");

	Params::MoverComponent_FindSharedSettings_BP Parms{};

	Parms.SharedSetting = SharedSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.FindSharedSettings_Mutable_BP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObject>              SharedSetting                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UMoverComponent::FindSharedSettings_Mutable_BP(TSubclassOf<class UObject> SharedSetting) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "FindSharedSettings_Mutable_BP");

	Params::MoverComponent_FindSharedSettings_Mutable_BP Parms{};

	Parms.SharedSetting = SharedSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetFutureTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   FutureSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverComponent::GetFutureTrajectory(float FutureSeconds, float SamplesPerSecond) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetFutureTrajectory");

	Params::MoverComponent_GetFutureTrajectory Parms{};

	Parms.FutureSeconds = FutureSeconds;
	Parms.SamplesPerSecond = SamplesPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetGravityAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetGravityAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetGravityAcceleration");

	Params::MoverComponent_GetGravityAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetLastInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverInputCmdContext      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMoverInputCmdContext UMoverComponent::GetLastInputCmd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetLastInputCmd");

	Params::MoverComponent_GetLastInputCmd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UMoverComponent::GetMovementBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetMovementBase");

	Params::MoverComponent_GetMovementBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementBaseBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMoverComponent::GetMovementBaseBoneName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetMovementBaseBoneName");

	Params::MoverComponent_GetMovementBaseBoneName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementIntent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetMovementIntent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetMovementIntent");

	Params::MoverComponent_GetMovementIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetMovementModeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UMoverComponent::GetMovementModeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetMovementModeName");

	Params::MoverComponent_GetMovementModeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetSimBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMoverBlackboard*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMoverBlackboard* UMoverComponent::GetSimBlackboard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetSimBlackboard");

	Params::MoverComponent_GetSimBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetSyncState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverSyncState            ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMoverSyncState UMoverComponent::GetSyncState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetSyncState");

	Params::MoverComponent_GetSyncState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetTargetOrientation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMoverComponent::GetTargetOrientation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetTargetOrientation");

	Params::MoverComponent_GetTargetOrientation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetUpDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetUpDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetUpDirection");

	Params::MoverComponent_GetUpDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.GetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverComponent::GetVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "GetVelocity");

	Params::MoverComponent_GetVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.HasValidCachedInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::HasValidCachedInputCmd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "HasValidCachedInputCmd");

	Params::MoverComponent_HasValidCachedInputCmd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.HasValidCachedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::HasValidCachedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "HasValidCachedState");

	Params::MoverComponent_HasValidCachedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverComponent.K2_FindActiveLayeredMove
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool*                                   DidSucceed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  TargetAsRawBytes                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverComponent::K2_FindActiveLayeredMove(bool* DidSucceed, int32* TargetAsRawBytes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "K2_FindActiveLayeredMove");

	Params::MoverComponent_K2_FindActiveLayeredMove Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DidSucceed != nullptr)
		*DidSucceed = Parms.DidSucceed;

	if (TargetAsRawBytes != nullptr)
		*TargetAsRawBytes = Parms.TargetAsRawBytes;
}


// Function Mover.MoverComponent.TryGetFloorCheckHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult*                      OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMoverComponent::TryGetFloorCheckHitResult(struct FHitResult* OutHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverComponent", "TryGetFloorCheckHitResult");

	Params::MoverComponent_TryGetFloorCheckHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	return Parms.ReturnValue;
}


// Function Mover.CharacterMoverComponent.IsAirborne
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMoverComponent::IsAirborne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMoverComponent", "IsAirborne");

	Params::CharacterMoverComponent_IsAirborne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.CharacterMoverComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMoverComponent::IsFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMoverComponent", "IsFalling");

	Params::CharacterMoverComponent_IsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.CharacterMoverComponent.IsOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMoverComponent::IsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMoverComponent", "IsOnGround");

	Params::CharacterMoverComponent_IsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.CharacterMoverComponent.IsSlopeSliding
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterMoverComponent::IsSlopeSliding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMoverComponent", "IsSlopeSliding");

	Params::CharacterMoverComponent_IsSlopeSliding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.FloorQueryUtils.IsHitSurfaceWalkable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFloorQueryUtils::IsHitSurfaceWalkable(const struct FHitResult& Hit, float MaxWalkSlopeCosine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FloorQueryUtils", "IsHitSurfaceWalkable");

	Params::FloorQueryUtils_IsHitSurfaceWalkable Parms{};

	Parms.Hit = std::move(Hit);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.GroundMovementUtils.CanStepUpOnHitSurface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroundMovementUtils::CanStepUpOnHitSurface(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundMovementUtils", "CanStepUpOnHitSurface");

	Params::GroundMovementUtils_CanStepUpOnHitSurface Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.GroundMovementUtils.ComputeControlledGroundMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGroundMoveParams&         InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UGroundMovementUtils::ComputeControlledGroundMove(const struct FGroundMoveParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundMovementUtils", "ComputeControlledGroundMove");

	Params::GroundMovementUtils_ComputeControlledGroundMove Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.GroundMovementUtils.ComputeDeflectedMoveOntoRamp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   OrigMoveDelta                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                RampHitResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHitFromLineTrace                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UGroundMovementUtils::ComputeDeflectedMoveOntoRamp(const struct FVector& OrigMoveDelta, const struct FHitResult& RampHitResult, float MaxWalkSlopeCosine, const bool bHitFromLineTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundMovementUtils", "ComputeDeflectedMoveOntoRamp");

	Params::GroundMovementUtils_ComputeDeflectedMoveOntoRamp Parms{};

	Parms.OrigMoveDelta = std::move(OrigMoveDelta);
	Parms.RampHitResult = std::move(RampHitResult);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;
	Parms.bHitFromLineTrace = bHitFromLineTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.GroundMovementUtils.TryWalkToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxStepHeight                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGroundMovementUtils::TryWalkToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord, float MaxWalkSlopeCosine, float MaxStepHeight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GroundMovementUtils", "TryWalkToSlideAlongSurface");

	Params::GroundMovementUtils_TryWalkToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;
	Parms.MaxStepHeight = MaxStepHeight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.TurnGeneratorInterface.GetTurn
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  TargetOrientation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMoverTickStartData&       FullStartState                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverDefaultSyncState&    MoverState                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProposedMove&             ProposedMove                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UMoverBlackboard*                 SimBlackboard                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ITurnGeneratorInterface::GetTurn(const struct FRotator& TargetOrientation, const struct FMoverTickStartData& FullStartState, const struct FMoverDefaultSyncState& MoverState, const struct FMoverTimeStep& TimeStep, const struct FProposedMove& ProposedMove, class UMoverBlackboard* SimBlackboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TurnGeneratorInterface", "GetTurn");

	Params::TurnGeneratorInterface_GetTurn Parms{};

	Parms.TargetOrientation = std::move(TargetOrientation);
	Parms.FullStartState = std::move(FullStartState);
	Parms.MoverState = std::move(MoverState);
	Parms.TimeStep = std::move(TimeStep);
	Parms.ProposedMove = std::move(ProposedMove);
	Parms.SimBlackboard = SimBlackboard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetLocationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetLocationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetLocationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetLocationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromInputs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FCharacterDefaultInputs&   Inputs                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromInputs(const struct FCharacterDefaultInputs& Inputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetMoveDirectionIntentFromInputs");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs Parms{};

	Parms.Inputs = std::move(Inputs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetMoveDirectionIntentFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetOrientationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMoverDataModelBlueprintLibrary::GetOrientationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetOrientationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetOrientationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetVelocityFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetVelocityFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetVelocityFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetVelocityFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.SetMoveIntent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FCharacterDefaultInputs&         Inputs                                                 (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldDirectionIntent                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataModelBlueprintLibrary::SetMoveIntent(struct FCharacterDefaultInputs& Inputs, const struct FVector& WorldDirectionIntent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "SetMoveIntent");

	Params::MoverDataModelBlueprintLibrary_SetMoveIntent Parms{};

	Parms.Inputs = std::move(Inputs);
	Parms.WorldDirectionIntent = std::move(WorldDirectionIntent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Inputs = std::move(Parms.Inputs);
}


// Function Mover.MoverDebugComponent.OnHistoryTrackingRollback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnHistoryTrackingRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnHistoryTrackingRollback");

	Params::MoverDebugComponent_OnHistoryTrackingRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.OnMovementSimRollback
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnMovementSimRollback");

	Params::MoverDebugComponent_OnMovementSimRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.OnMovementSimTick
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimTick(const struct FMoverTimeStep& TimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnMovementSimTick");

	Params::MoverDebugComponent_OnMovementSimTick Parms{};

	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.SetHistoryTracking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsToTrack                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDebugComponent::SetHistoryTracking(float SecondsToTrack, float SamplesPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "SetHistoryTracking");

	Params::MoverDebugComponent_SetHistoryTracking Parms{};

	Parms.SecondsToTrack = SecondsToTrack;
	Parms.SamplesPerSecond = SamplesPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.GetPastTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverDebugComponent::GetPastTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "GetPastTrajectory");

	Params::MoverDebugComponent_GetPastTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverNetworkPhysicsLiaisonComponent.OnComponentPhysicsStateChanged
// (Final, Native, Protected)
// Parameters:
// class UPrimitiveComponent*              ChangedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EComponentPhysicsStateChange            StateChange                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverNetworkPhysicsLiaisonComponent::OnComponentPhysicsStateChanged(class UPrimitiveComponent* ChangedComponent, EComponentPhysicsStateChange StateChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverNetworkPhysicsLiaisonComponent", "OnComponentPhysicsStateChanged");

	Params::MoverNetworkPhysicsLiaisonComponent_OnComponentPhysicsStateChanged Parms{};

	Parms.ChangedComponent = ChangedComponent;
	Parms.StateChange = StateChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverInputProducerInterface.ProduceInput
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// int32                                   SimTimeMs                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMoverInputCmdContext*           InputCmdResult                                         (Parm, OutParm, NativeAccessSpecifierPublic)

void IMoverInputProducerInterface::ProduceInput(int32 SimTimeMs, struct FMoverInputCmdContext* InputCmdResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MoverInputProducerInterface", "ProduceInput");

	Params::MoverInputProducerInterface_ProduceInput Parms{};

	Parms.SimTimeMs = SimTimeMs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InputCmdResult != nullptr)
		*InputCmdResult = std::move(Parms.InputCmdResult);
}


// Function Mover.MoverDataCollectionLibrary.ClearDataFromCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverDataCollection&            Collection                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::ClearDataFromCollection(struct FMoverDataCollection& Collection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataCollectionLibrary", "ClearDataFromCollection");

	Params::MoverDataCollectionLibrary_ClearDataFromCollection Parms{};

	Parms.Collection = std::move(Collection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Collection = std::move(Parms.Collection);
}


// Function Mover.MoverDataCollectionLibrary.K2_AddDataToCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverDataCollection&            Collection                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32&                            SourceAsRawBytes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_AddDataToCollection(struct FMoverDataCollection& Collection, const int32& SourceAsRawBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataCollectionLibrary", "K2_AddDataToCollection");

	Params::MoverDataCollectionLibrary_K2_AddDataToCollection Parms{};

	Parms.Collection = std::move(Collection);
	Parms.SourceAsRawBytes = SourceAsRawBytes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Collection = std::move(Parms.Collection);
}


// Function Mover.MoverDataCollectionLibrary.K2_GetDataFromCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   DidSucceed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMoverDataCollection&      Collection                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  TargetAsRawBytes                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_GetDataFromCollection(bool* DidSucceed, const struct FMoverDataCollection& Collection, int32* TargetAsRawBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataCollectionLibrary", "K2_GetDataFromCollection");

	Params::MoverDataCollectionLibrary_K2_GetDataFromCollection Parms{};

	Parms.Collection = std::move(Collection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DidSucceed != nullptr)
		*DidSucceed = Parms.DidSucceed;

	if (TargetAsRawBytes != nullptr)
		*TargetAsRawBytes = Parms.TargetAsRawBytes;
}


// Function Mover.BaseMovementModeTransition.K2_OnTrigger
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UBaseMovementModeTransition::K2_OnTrigger(const struct FSimulationTickParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementModeTransition", "K2_OnTrigger");

	Params::BaseMovementModeTransition_K2_OnTrigger Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.BaseMovementModeTransition.K2_OnEvaluate
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FTransitionEvalResult            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTransitionEvalResult UBaseMovementModeTransition::K2_OnEvaluate(const struct FSimulationTickParams& Params_0) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementModeTransition", "K2_OnEvaluate");

	Params::BaseMovementModeTransition_K2_OnEvaluate Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.WaterMovementUtils.ComputeControlledWaterMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FWaterMoveParams&          InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UWaterMovementUtils::ComputeControlledWaterMove(const struct FWaterMoveParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WaterMovementUtils", "ComputeControlledWaterMove");

	Params::WaterMovementUtils_ComputeControlledWaterMove Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.WaterMovementUtils.UpdateWaterSplineData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FUpdateWaterSplineDataParams&UpdateWaterSplineDataParams                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FWaterCheckResult*               OutWaterResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UWaterMovementUtils::UpdateWaterSplineData(const struct FUpdateWaterSplineDataParams& UpdateWaterSplineDataParams, struct FWaterCheckResult* OutWaterResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WaterMovementUtils", "UpdateWaterSplineData");

	Params::WaterMovementUtils_UpdateWaterSplineData Parms{};

	Parms.UpdateWaterSplineDataParams = std::move(UpdateWaterSplineDataParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWaterResult != nullptr)
		*OutWaterResult = std::move(Parms.OutWaterResult);
}


// Function Mover.BaseMovementMode.K2_OnRegistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FName                       ModeName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseMovementMode::K2_OnRegistered(const class FName ModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnRegistered");

	Params::BaseMovementMode_K2_OnRegistered Parms{};

	Parms.ModeName = ModeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.BaseMovementMode.K2_OnSimulationTick
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMoverTickEndData UBaseMovementMode::K2_OnSimulationTick(const struct FSimulationTickParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnSimulationTick");

	Params::BaseMovementMode_K2_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnUnregistered
// (Event, Protected, BlueprintEvent)

void UBaseMovementMode::K2_OnUnregistered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnUnregistered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mover.BaseMovementMode.GetBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMoverBlackboard*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMoverBlackboard* UBaseMovementMode::GetBlackboard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetBlackboard");

	Params::BaseMovementMode_GetBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetBlackboard_Mutable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverBlackboard*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverBlackboard* UBaseMovementMode::GetBlackboard_Mutable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetBlackboard_Mutable");

	Params::BaseMovementMode_GetBlackboard_Mutable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetMoverComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverComponent* UBaseMovementMode::GetMoverComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetMoverComponent");

	Params::BaseMovementMode_GetMoverComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnGenerateMove
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FMoverTickStartData&       StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UBaseMovementMode::K2_OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnGenerateMove");

	Params::BaseMovementMode_K2_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.FallingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData*               OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "OnSimulationTick");

	Params::FallingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FallingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverTickStartData&       StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFallingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "OnGenerateMove");

	Params::FallingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.FallingMode.ProcessLanded
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFloorCheckResult&         FloorResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRelativeBaseInfo*               BaseInfo                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData*               TickEndData                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::ProcessLanded(const struct FFloorCheckResult& FloorResult, struct FVector* Velocity, struct FRelativeBaseInfo* BaseInfo, struct FMoverTickEndData* TickEndData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "ProcessLanded");

	Params::FallingMode_ProcessLanded Parms{};

	Parms.FloorResult = std::move(FloorResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);

	if (BaseInfo != nullptr)
		*BaseInfo = std::move(Parms.BaseInfo);

	if (TickEndData != nullptr)
		*TickEndData = std::move(Parms.TickEndData);
}


// Function Mover.FlyingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData*               OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFlyingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyingMode", "OnSimulationTick");

	Params::FlyingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FlyingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverTickStartData&       StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFlyingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyingMode", "OnGenerateMove");

	Params::FlyingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.SwimmingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData*               OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void USwimmingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingMode", "OnSimulationTick");

	Params::SwimmingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.SwimmingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverTickStartData&       StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void USwimmingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingMode", "OnGenerateMove");

	Params::SwimmingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.WalkingMode.GetTurnGenerator
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UWalkingMode::GetTurnGenerator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "GetTurnGenerator");

	Params::WalkingMode_GetTurnGenerator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.WalkingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMoverTickEndData*               OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UWalkingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "OnSimulationTick");

	Params::WalkingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.WalkingMode.SetTurnGeneratorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UObject>              TurnGeneratorClass                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWalkingMode::SetTurnGeneratorClass(TSubclassOf<class UObject> TurnGeneratorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "SetTurnGeneratorClass");

	Params::WalkingMode_SetTurnGeneratorClass Parms{};

	Parms.TurnGeneratorClass = TurnGeneratorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.WalkingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMoverTickStartData&       StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UWalkingMode::OnGenerateMove(const struct FMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "OnGenerateMove");

	Params::WalkingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.BasedMovementUtils.GetMovementBaseTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat*                           OutQuat                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::GetMovementBaseTransform(const class UPrimitiveComponent* MovementBase, const class FName BoneName, struct FVector* OutLocation, struct FQuat* OutQuat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "GetMovementBaseTransform");

	Params::BasedMovementUtils_GetMovementBaseTransform Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutQuat != nullptr)
		*OutQuat = std::move(Parms.OutQuat);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.IsADynamicBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::IsADynamicBase(const class UPrimitiveComponent* MovementBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "IsADynamicBase");

	Params::BasedMovementUtils_IsADynamicBase Parms{};

	Parms.MovementBase = MovementBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.IsBaseSimulatingPhysics
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::IsBaseSimulatingPhysics(const class UPrimitiveComponent* MovementBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "IsBaseSimulatingPhysics");

	Params::BasedMovementUtils_IsBaseSimulatingPhysics Parms{};

	Parms.MovementBase = MovementBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformBasedDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformBasedDirectionToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformBasedDirectionToWorld");

	Params::BasedMovementUtils_TransformBasedDirectionToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalDirection = std::move(LocalDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformBasedLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformBasedLocationToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformBasedLocationToWorld");

	Params::BasedMovementUtils_TransformBasedLocationToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformBasedRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformBasedRotatorToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformBasedRotatorToWorld");

	Params::BasedMovementUtils_TransformBasedRotatorToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalRotator = std::move(LocalRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformDirectionToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformDirectionToLocal(const struct FQuat& BaseQuat, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformDirectionToLocal");

	Params::BasedMovementUtils_TransformDirectionToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);
}


// Function Mover.BasedMovementUtils.TransformDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformDirectionToWorld(const struct FQuat& BaseQuat, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformDirectionToWorld");

	Params::BasedMovementUtils_TransformDirectionToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalDirection = std::move(LocalDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);
}


// Function Mover.BasedMovementUtils.TransformLocationToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformLocationToLocal(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformLocationToLocal");

	Params::BasedMovementUtils_TransformLocationToLocal Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);
}


// Function Mover.BasedMovementUtils.TransformLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformLocationToWorld(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformLocationToWorld");

	Params::BasedMovementUtils_TransformLocationToWorld Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);
}


// Function Mover.BasedMovementUtils.TransformRotatorToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformRotatorToLocal(const struct FQuat& BaseQuat, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformRotatorToLocal");

	Params::BasedMovementUtils_TransformRotatorToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);
}


// Function Mover.BasedMovementUtils.TransformRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UBasedMovementUtils::TransformRotatorToWorld(const struct FQuat& BaseQuat, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformRotatorToWorld");

	Params::BasedMovementUtils_TransformRotatorToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalRotator = std::move(LocalRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);
}


// Function Mover.BasedMovementUtils.TransformWorldDirectionToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformWorldDirectionToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformWorldDirectionToBased");

	Params::BasedMovementUtils_TransformWorldDirectionToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformWorldLocationToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformWorldLocationToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformWorldLocationToBased");

	Params::BasedMovementUtils_TransformWorldLocationToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);

	return Parms.ReturnValue;
}


// Function Mover.BasedMovementUtils.TransformWorldRotatorToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBasedMovementUtils::TransformWorldRotatorToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BasedMovementUtils", "TransformWorldRotatorToBased");

	Params::BasedMovementUtils_TransformWorldRotatorToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.CanEscapeGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   PriorVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::CanEscapeGravity(const struct FVector& PriorVelocity, const struct FVector& NewVelocity, const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "CanEscapeGravity");

	Params::MovementUtils_CanEscapeGravity Parms{};

	Parms.PriorVelocity = std::move(PriorVelocity);
	Parms.NewVelocity = std::move(NewVelocity);
	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeAngularVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  From                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurningRateLimit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMovementUtils::ComputeAngularVelocity(const struct FRotator& From, const struct FRotator& To, float DeltaSeconds, float TurningRateLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeAngularVelocity");

	Params::MovementUtils_ComputeAngularVelocity Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.TurningRateLimit = TurningRateLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeCombinedVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FComputeCombinedVelocityParams&InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeCombinedVelocity(const struct FComputeCombinedVelocityParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeCombinedVelocity");

	Params::MovementUtils_ComputeCombinedVelocity Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeDirectionIntent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   MoveInput                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoveInputType                          MoveInputType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeDirectionIntent(const struct FVector& MoveInput, EMoveInputType MoveInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeDirectionIntent");

	Params::MovementUtils_ComputeDirectionIntent Parms{};

	Parms.MoveInput = std::move(MoveInput);
	Parms.MoveInputType = MoveInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeSlideDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PctOfDeltaToMove                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeSlideDelta(const struct FVector& Delta, const float PctOfDeltaToMove, const struct FVector& Normal, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeSlideDelta");

	Params::MovementUtils_ComputeSlideDelta Parms{};

	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Normal = std::move(Normal);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FComputeVelocityParams&    InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocity(const struct FComputeVelocityParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocity");

	Params::MovementUtils_ComputeVelocity Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromGravity(const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocityFromGravity");

	Params::MovementUtils_ComputeVelocityFromGravity Parms{};

	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromPositions
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   FromPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ToPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromPositions(const struct FVector& FromPos, const struct FVector& ToPos, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocityFromPositions");

	Params::MovementUtils_ComputeVelocityFromPositions Parms{};

	Parms.FromPos = std::move(FromPos);
	Parms.ToPos = std::move(ToPos);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ConstrainToPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlane&                    MovementPlane                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintainMagnitude                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ConstrainToPlane(const struct FVector& Vector, const struct FPlane& MovementPlane, bool bMaintainMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ConstrainToPlane");

	Params::MovementUtils_ConstrainToPlane Parms{};

	Parms.Vector = std::move(Vector);
	Parms.MovementPlane = std::move(MovementPlane);
	Parms.bMaintainMagnitude = bMaintainMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsExceedingMaxSpeed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsExceedingMaxSpeed(const struct FVector& Velocity, float InMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "IsExceedingMaxSpeed");

	Params::MovementUtils_IsExceedingMaxSpeed Parms{};

	Parms.Velocity = std::move(Velocity);
	Parms.InMaxSpeed = InMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryMoveToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMoverComponent*                  MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryMoveToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TryMoveToSlideAlongSurface");

	Params::MovementUtils_TryMoveToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TrySafeMoveUpdatedComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     NewRotation                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ETeleportType                           Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::TrySafeMoveUpdatedComponent(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Delta, const struct FQuat& NewRotation, bool bSweep, struct FHitResult* OutHit, ETeleportType Teleport, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TrySafeMoveUpdatedComponent");

	Params::MovementUtils_TrySafeMoveUpdatedComponent Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Delta = std::move(Delta);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.CreateProxyObjectForPlayMoverMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMoverComponent*                  InMoverComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayMoverMontageCallbackProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayMoverMontageCallbackProxy* UPlayMoverMontageCallbackProxy::CreateProxyObjectForPlayMoverMontage(class UMoverComponent* InMoverComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayMoverMontageCallbackProxy", "CreateProxyObjectForPlayMoverMontage");

	Params::PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage Parms{};

	Parms.InMoverComponent = InMoverComponent;
	Parms.MontageToPlay = MontageToPlay;
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.OnMoverMontageEnded
// (Final, Native, Protected)
// Parameters:
// class FName                             IgnoredNotifyName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayMoverMontageCallbackProxy::OnMoverMontageEnded(class FName IgnoredNotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayMoverMontageCallbackProxy", "OnMoverMontageEnded");

	Params::PlayMoverMontageCallbackProxy_OnMoverMontageEnded Parms{};

	Parms.IgnoredNotifyName = IgnoredNotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

